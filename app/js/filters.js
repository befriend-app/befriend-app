befriend.filters = {
    data: {
        filters: null,
        options: null,
        collapsed: {},
    },
    secondaries: {
        activeEl: null,
    },
    sections: {
        music: {
            is_interest: true,
            token: 'music',
            name: 'Music',
            endpoint: `/filters/music`,
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 476.17 512.001"><path d="M149.313,82.855v272.542c-15.859-14.147-36.757-22.76-59.632-22.76-49.45,0-89.681,40.231-89.681,89.682s40.231,89.682,89.681,89.682c49.389,0,89.578-40.13,89.68-89.495h.002v-219.031l266.757-67.621v147.195c-15.859-14.147-36.757-22.76-59.631-22.76-49.451,0-89.682,40.231-89.682,89.681s40.231,89.682,89.682,89.682,89.681-40.232,89.681-89.682V0L149.313,82.855ZM89.682,481.95c-32.88,0-59.631-26.75-59.631-59.632s26.75-59.632,59.631-59.632,59.632,26.75,59.632,59.632c-.001,32.882-26.751,59.632-59.632,59.632ZM179.363,172.476v-66.238L446.12,38.618v66.237l-266.757,67.621ZM386.489,409.602c-32.881,0-59.632-26.751-59.632-59.632s26.75-59.631,59.632-59.631,59.631,26.75,59.631,59.631-26.75,59.632-59.631,59.632Z"/></svg>`,
            importance: {
                active: true,
                default: 5
            }
        },
        work: {
            is_interest: true,
            token: 'work',
            name: 'Work',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 488 432"><path d="M456,72h-104v-32c-.0273-22.082-17.918-39.9727-40-40h-144c-22.082.0273-39.9727,17.918-40,40v32H24c-13.2539,0-24,10.7461-24,24v178.0781c.0508,10.1484,6.4453,19.1758,16,22.5859v111.3359c0,13.2539,10.7461,24,24,24h400c13.2539,0,24-10.7461,24-24v-111.3281c9.5547-3.4141,15.9531-12.4453,16-22.5938V96c0-13.2539-10.7461-24-24-24ZM144,40c0-13.2539,10.7461-24,24-24h144c13.2539,0,24,10.7461,24,24v32h-16v-32c0-4.418-3.582-8-8-8h-144c-4.418,0-8,3.582-8,8v32h-16v-32ZM304,72h-128v-24h128v24ZM448,408c0,4.418-3.582,8-8,8H40c-4.418,0-8-3.582-8-8v-108.5859l176,24.2734v20.3125c0,13.2539,10.7461,24,24,24h16c13.2539,0,24-10.7461,24-24v-20.3125l176-24.2734v108.5859ZM256,344c0,4.418-3.582,8-8,8h-16c-4.418,0-8-3.582-8-8v-48c0-4.418,3.582-8,8-8h16c4.418,0,8,3.582,8,8v48ZM464,274.0781c.0039,3.9883-2.9297,7.3711-6.8789,7.9297l-2.2188.3047-182.9023,25.2227v-11.5352c0-13.2539-10.7461-24-24-24h-16c-13.2539,0-24,10.7461-24,24v11.5352l-185.1133-25.5273c-3.9492-.5547-6.8906-3.9375-6.8867-7.9297V96c0-4.418,3.582-8,8-8h432c4.418,0,8,3.582,8,8v178.0781Z"/></svg>`,
            importance: {
                active: true,
                default: 4
            }
        },
        instruments: {
            is_interest: true,
            token: 'instruments',
            name: 'Instruments',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.0001 511.846"><path d="M488.9347,328.303c-3.9248-5.1988-5.3417-11.9144-3.8888-18.4131,1.6899-7.5056,2.4059-15.2383,2.1279-22.9809-1.3769-38.9381-27.6517-72.2395-64.6618-82.997v-112.7885l13.1074-23.5808c.62-1.1149.945-2.3689.945-3.6438V18.4981c0-10.1995-8.2976-18.4981-18.4981-18.4981h-41.341c-10.1995,0-18.4971,8.2976-18.4971,18.4981v45.3998c0,1.2749.325,2.5289.945,3.6438l13.1114,23.5868v112.7735c-14.4733,4.2218-27.7436,12.1014-38.4381,22.7929v-24.4898h7.4606c4.1418,0,7.4996-3.3578,7.4996-7.4996s-3.3578-7.4996-7.4996-7.4996h-189.8607c-4.1418,0-7.4996,3.3578-7.4996,7.4996s3.3578,7.4996,7.4996,7.4996h6.8387v56.7712c-32.3854,27.1607-50.8875,66.7107-50.8875,109.0927,0,34.4763,12.3204,66.1277,32.7854,90.7896l-23.5028,40.315c-2.0859,3.5788-.876,8.1696,2.7019,10.2565,1.1879.692,2.4869,1.0209,3.7708,1.0209,2.5809,0,5.0928-1.3329,6.4857-3.7238l21.204-36.3722c25.6367,24.8048,60.533,40.096,98.9382,40.096,16.5752,0,32.8164-2.8249,48.2726-8.3956,3.8968-1.4039,5.9167-5.7017,4.5128-9.5985-1.4039-3.8958-5.7007-5.9167-9.5985-4.5128-13.8203,4.9807-28.3506,7.5066-43.1869,7.5066-70.2396,0-127.3838-57.1442-127.3838-127.3838-1.3889-68.5977,58.7341-128.4877,127.3838-127.3838,22.5639,0,44.4948,5.9207,63.8279,17.1432-3.9528,10.2525-6.0497,21.216-6.0497,32.3244,0,6.8487.782,13.6893,2.3219,20.328,1.4089,6.0957-.006,12.5264-3.8788,17.6401-1.1,1.4509-2.1519,2.9279-3.1768,4.4188-11.7104-17.3601-31.6174-28.3366-53.0444-28.3366-35.2163,0-63.8669,28.6506-63.8669,63.8669s28.6506,63.8669,63.8669,63.8669c12.6944,0,25.0818-3.8608,35.5193-10.8335,11.0145,51.8505,57.2012,90.7456,112.1075,90.7446,64.8888.08,114.9144-53.6544,114.5914-114.5994-.001-25.1078-7.9756-48.9486-23.0639-68.9436h0ZM397.3972,310.3258c-3.4808,0-6.8637.42-10.1125,1.1899v-19.0731h20.229v19.0741c-3.2508-.771-6.6347-1.191-10.1165-1.191ZM387.2836,254.3356h20.229v23.1089h-20.229v-23.1089ZM387.2836,239.3363v-23.0989h20.229v23.0989h-20.229ZM407.5127,96.6833v28.3376h-20.229v-28.3376h20.229ZM407.5127,140.0212v23.1089h-20.229v-23.1089h20.229ZM407.5127,178.1293v23.1089h-20.229v-23.1089h20.229ZM373.2283,18.4981c0-1.9289,1.5689-3.4988,3.4978-3.4988h41.341c1.9289,0,3.4988,1.5689,3.4988,3.4988v43.4559l-10.9655,19.727h-26.4077l-10.9645-19.726V18.4981ZM318.847,243.5461c-11.5674-6.4307-23.9308-11.1715-36.7582-14.1493v-27.1887h36.7582v41.338ZM208.8524,202.2081v29.4026c-12.5024,3.7348-24.4368,9.2046-35.5683,16.3352v-45.7368h35.5683v-.001ZM223.8516,228.0199v-25.8107h43.2379v24.5458c-5.7157-.695-11.4924-1.0669-17.3092-1.0669-8.8046-.001-17.4681.789-25.9287,2.3319ZM249.7804,416.9376c-26.9457,0-48.8676-21.9219-48.8676-48.8676s21.9219-48.8676,48.8676-48.8676c18.9791,0,36.3982,11.2555,44.3348,28.3126-8.1446,16.8742-12.2754,36.5412-11.1184,56.3783-9.0516,8.4296-20.724,13.0444-33.2164,13.0444h0ZM468.1387,467.3632c-18.1821,18.4761-44.2438,29.6315-70.7306,29.4856-54.4493-.005-99.0442-44.0159-99.6001-98.5492-.245-21.7959,6.6927-43.2849,20.148-61.12,6.5677-8.6716,8.9506-19.6341,6.5367-30.0815-1.2839-5.5347-1.9359-11.2354-1.9359-16.9442,0-17.1741,5.9657-33.9513,16.7982-47.2397,8.6736-10.6395,20.14-18.6981,32.9294-23.2699v98.6182c-11.3124,7.9366-18.7281,21.066-18.7281,35.9032,0,16.1452,8.8346,30.9395,23.0569,38.6091,3.6468,1.9669,8.1946.604,10.1605-3.0418s.604-8.1946-3.0418-10.1605c-9.3615-5.0478-15.1763-14.7833-15.1763-25.4067,0-15.9032,12.9384-28.8406,28.8416-28.8406s28.8416,12.9374,28.8416,28.8406c0,10.7635-5.9277,20.558-15.4692,25.5627-3.6678,1.9239-5.0828,6.4577-3.1588,10.1245,1.3409,2.5569,3.9488,4.0178,6.6477,4.0178,1.174,0,2.3649-.276,3.4768-.859,14.4973-7.6036,23.5018-22.4889,23.5018-38.8461,0-14.8353-7.4146-27.9646-18.7251-35.9012v-98.6172c28.6096,10.1675,48.5776,36.8502,49.6726,67.7957.231,6.4597-.364,12.9034-1.7739,19.1641-2.4169,10.8135-.029,22.0159,6.5517,30.7325,13.1074,17.3702,20.036,38.0862,20.036,59.9101,0,26.4377-10.2495,51.3375-28.8596,70.1136h0Z"/><path d="M83.9885,203.3111c-4.1418,0-7.4996,3.3578-7.4996,7.4996v291.4828c0,4.1418,3.3578,7.4996,7.4996,7.4996s7.4996-3.3578,7.4996-7.4996V210.8107c0-4.1418-3.3578-7.4996-7.4996-7.4996Z"/><path d="M144.8315,153.5795c2.0519.569,4.1388.851,6.2117.851,3.9378,0,7.8306-1.0169,11.3515-3.0089,5.3747-3.0419,9.2436-7.9936,10.8965-13.9573l.028-.104c1.6499-5.9507.883-12.1874-2.1579-17.5621s-7.9936-9.2436-13.9453-10.8935L29.3371,73.4534c-5.9497-1.6479-12.1884-.883-17.5621,2.1579-5.3747,3.0419-9.2435,7.9936-10.8965,13.9573l-.028.104c-1.6499,5.9507-.883,12.1874,2.1579,17.5621,3.0409,5.3747,7.9936,9.2436,13.9453,10.8935l59.5361,16.5052v41.19c0,4.1418,3.3578,7.4996,7.4996,7.4996s7.4996-3.3578,7.4996-7.4996v-37.0322l53.3424,14.7883ZM15.3078,93.6674l.028-.104c.579-2.0899,1.9379-3.8298,3.8258-4.8978,1.8869-1.0679,4.0778-1.3379,6.1687-.758l127.8788,35.4513c4.3148,1.1959,6.8517,5.6797,5.6517,10.0065l-.028.104c-.579,2.0899-1.9379,3.8298-3.8258,4.8978-1.8869,1.0669-4.0778,1.3389-6.1687.758L20.9595,103.6739c-4.3148-1.1969-6.8517-5.6797-5.6517-10.0065h0Z"/><path d="M429.7225,432.4049h-65.6868c-4.1418,0-7.4996,3.3578-7.4996,7.4996s3.3578,7.4996,7.4996,7.4996h65.6868c4.1418,0,7.4996-3.3578,7.4996-7.4996s-3.3578-7.4996-7.4996-7.4996Z"/></svg>`,
            importance: {
                active: true,
                default: 6
            }
        },
        availability: {
            token: 'availability',
            name: 'Availability',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M138.6667,320h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM85.3333,298.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M138.6667,448h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM85.3333,426.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M288,320h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM234.6667,298.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M288,448h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM234.6667,426.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M437.3333,320h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM384,298.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M458.6667,512H53.3333c-29.3973,0-53.3333-23.936-53.3333-53.3333V96c0-29.3973,23.936-53.3333,53.3333-53.3333h405.3333c29.3973,0,53.3333,23.936,53.3333,53.3333v362.6667c0,29.3973-23.936,53.3333-53.3333,53.3333ZM53.3333,64c-17.6427,0-32,14.3573-32,32v362.6667c0,17.6427,14.3573,32,32,32h405.3333c17.6427,0,32-14.3573,32-32V96c0-17.6427-14.3573-32-32-32H53.3333Z"/><path d="M501.3333,192H10.6667c-5.888,0-10.6667-4.7787-10.6667-10.6667s4.7787-10.6667,10.6667-10.6667h490.6667c5.888,0,10.6667,4.7787,10.6667,10.6667s-4.7787,10.6667-10.6667,10.6667Z"/><path d="M117.3333,106.6667c-5.888,0-10.6667-4.7787-10.6667-10.6667V10.6667c0-5.888,4.7787-10.6667,10.6667-10.6667s10.6667,4.7787,10.6667,10.6667v85.3333c0,5.888-4.7787,10.6667-10.6667,10.6667Z"/><path d="M394.6667,106.6667c-5.888,0-10.6667-4.7787-10.6667-10.6667V10.6667c0-5.888,4.7787-10.6667,10.6667-10.6667s10.6667,4.7787,10.6667,10.6667v85.3333c0,5.888-4.7787,10.6667-10.6667,10.6667Z"/></svg>`
        },
        modes: {
            token: 'modes',
            name: 'Modes',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 469.976 374.017">
                    <path class="outline" d="M197.396,258.637l-33.524-6.472c.032-.676.104-1.348.104-2.032v-20.844c19.9322-11.3726,34.5883-30.1323,40.8-52.224,16.9671-2.0638,29.0486-17.4913,26.9848-34.4583-1.0477-8.6131-5.6629-16.3909-12.7208-21.4377l1.012-15.344C223.6666,51.1135,182.2443,3.8308,127.5327.2163c-29.6844-1.9611-58.6839,9.4926-79.0167,31.2088-18.8774,19.9906-28.5213,46.9727-26.592,74.4l1.012,15.344c-13.9034,9.9415-17.1152,29.2717-7.1737,43.1752,5.0467,7.058,12.8245,11.6732,21.4377,12.7208,6.2117,22.0917,20.8678,40.8514,40.8,52.224v20.844c0,.684.072,1.356.104,2.032l-33.528,6.472C18.7156,263.6609.0331,286.2932,0,312.637v54.38c.0022,3.8557,3.1203,6.9846,6.976,7h228c3.8651-.0022,6.9978-3.1349,7-7v-54.376c-.0315-26.3466-18.7166-48.9815-44.58-54.004ZM207.572,161.985c.26-2.724.4-5.484.4-8.28v-22.836c8.5444,3.8486,12.3511,13.8952,8.5024,22.4396-1.7631,3.9142-4.9442,7.0146-8.9024,8.6764h0ZM35.884,104.901c-3.0886-46.9975,32.5066-87.6002,79.5041-90.6888,25.4863-1.6749,50.3816,8.1617,67.8399,26.8048,16.2122,17.1684,24.4953,40.3407,22.84,63.896l-.692,10.756c-.9707-.1387-1.9547-.2307-2.952-.276-19.696-6.748-36-26.552-36.16-26.752-2.1433-2.6336-5.8656-3.3532-8.836-1.708-53.116,29.528-115.656,28.4-116.268,28.4-1.5244-.0167-3.0474.0984-4.552.344l-.724-10.776ZM23.976,146.321c.0157-6.6657,3.9255-12.7073,10-15.452v22.836c0,2.8.144,5.556.4,8.28-6.2971-2.6598-10.3926-8.8282-10.4-15.664ZM47.976,153.705v-24.44c18-.504,66.368-4.116,111.272-27.428,9.7588,10.693,21.5691,19.3134,34.728,25.348v26.52c0,40.3168-32.6832,73-73,73s-73-32.6832-73-73ZM120.976,240.705c9.8805.0048,19.6889-1.6823,29-4.988v14.4c0,16.0163-12.9837,29-29,29s-29-12.9837-29-29v-14.4c9.3111,3.3058,19.1195,4.9928,29,4.988ZM227.976,360.017H13.976v-47.376c.024-19.6404,13.9521-36.5141,33.232-40.26l33.788-6.52c8.6524,22.0804,33.5663,32.9658,55.6466,24.3134,11.1371-4.3642,19.9491-13.1762,24.3134-24.3134l33.788,6.52c19.2799,3.7459,33.208,20.6196,33.232,40.26v47.376Z M429.704,269.905l-13.396-2.588,15.452-1.368c16.2248-1.468,28.5575-15.2238,28.252-31.512l-2-99.964c-1.1376-53.2281-45.2097-95.4558-98.4378-94.3182-51.6266,1.1034-93.2148,42.6916-94.3182,94.3182l-2,99.968c-.2635,16.2755,12.0554,30.0066,28.264,31.504l15.456,1.372-13.412,2.588c-23.3664,4.5435-40.2448,24.996-40.272,48.8v48.312c.0022,3.8651,3.1349,6.9978,7,7h202.684c3.8651-.0022,6.9978-3.1349,7-7v-48.32c-.0311-23.801-16.9085-44.2491-40.272-48.792ZM361.64,241.5051c-35.3807-.0418-64.0551-28.7073-64.108-64.088v-23.068c11.4219-5.3275,21.695-12.8315,30.244-22.092,39.284,20.24,81.42,23.652,97.964,24.18v20.98c-.0463,35.3823-28.7177,64.0537-64.1,64.1v-.012ZM336.656,251.345c16.2012,5.5708,33.7988,5.5708,50,0v11.792c0,13.8071-11.1929,25-25,25s-25-11.1929-25-25v-11.792ZM277.252,234.7171l2-99.956c.9511-45.4983,38.6058-81.611,84.1041-80.6599,44.1592.9231,79.7368,36.5007,80.6599,80.6599l2,99.976c.1641,8.9305-6.6001,16.4699-15.496,17.272l-29.864,2.644v-9.6801c24.1594-13.9227,39.061-39.672,39.096-67.556v-27.908c.0003-1.8871-.7612-3.6943-2.112-5.012-1.3415-1.3316-3.1706-2.0545-5.06-2-.568.036-55.792,1.08-102.944-25.136-2.9692-1.6478-6.6925-.9297-8.836,1.704-.148.18-14.856,18.068-32.432,23.772-2.8839.9388-4.836,3.6271-4.836,6.66v27.92c.035,27.8955,14.9489,53.6535,39.124,67.572v9.66l-29.896-2.644c-8.8928-.8246-15.6507-8.3582-15.508-17.288ZM455.976,360.017h-188.68v-41.32c.0235-17.0948,12.1441-31.7817,28.924-35.048l29.388-5.664c8.1882,19.9077,30.9645,29.4081,50.8721,21.2199,9.6219-3.9576,17.2623-11.5979,21.2199-21.2199l29.348,5.664c16.7815,3.2646,28.9041,17.9519,28.928,35.048v41.32Z"></path>
                </svg>`
        },
        reviews: {
            token: 'reviews',
            name: 'Reviews',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 29 28.9766"><defs><style>.reviews-icon-cls1{fill-rule:evenodd;}</style></defs><path class="reviews-icon-cls1" d="M25.2466,13.9834c-.272.0459-.4556.3037-.4097.5762.1084.6406.1631,1.2852.1631,1.917,0,3.5242-1.5708,6.7053-4.1017,8.8234-.442-2.8699-2.4796-5.1718-5.1854-5.9955,1.0757-.7176,1.787-1.9402,1.787-3.3279,0-2.2061-1.7944-4-4-4s-4,1.7939-4,4c0,1.3877.7113,2.6104,1.787,3.3279-2.7057.8237-4.7433,3.1255-5.1854,5.9955-2.5309-2.1181-4.1017-5.2992-4.1017-8.8234,0-.6318.0547-1.2764.1631-1.917.0459-.2725-.1377-.5303-.4097-.5762-.2783-.0469-.5303.1377-.5767.4102-.1172.6943-.1768,1.3955-.1768,2.083,0,6.1406,4.3857,11.3232,10.4282,12.3232.0273.0049.0552.0068.082.0068.2402,0,.4521-.1738.4927-.418.0454-.2725-.1392-.5303-.4116-.5752-1.6849-.2789-3.2263-.9159-4.5611-1.8195.2412-3.3932,3.0299-6.0174,6.4698-6.0174s6.2286,2.6242,6.4698,6.0174c-1.3348.9036-2.8762,1.5406-4.5611,1.8195-.2725.0449-.457.3027-.4116.5752.0405.2441.2524.418.4927.418.0269,0,.0547-.002.082-.0068,6.0425-1,10.4282-6.1826,10.4282-12.3232,0-.6875-.0596-1.3887-.1768-2.083-.0464-.2725-.3013-.458-.5767-.4102ZM10.5,15.9766c0-1.6543,1.3457-3,3-3s3,1.3457,3,3-1.3457,3-3,3-3-1.3457-3-3Z"/><path class="reviews-icon-cls1" d="M18.9756,3.9551c-.0591-.1816-.2153-.3135-.4038-.3408l-3.1948-.4639-1.4287-2.8955c-.168-.3398-.7285-.3398-.8965,0l-1.4287,2.8955-3.1948.4639c-.1885.0273-.3447.1592-.4038.3408-.0586.1807-.0098.3799.1265.5127l2.312,2.2529-.5459,3.1816c-.0322.1885.0449.3779.1987.4893.1548.1123.3584.1289.5269.0381l2.8574-1.5029,2.8574,1.5029c.0732.0391.1533.0576.2329.0576.1035,0,.2065-.0322.2939-.0957.1538-.1113.231-.3008.1987-.4893l-.5459-3.1816,2.312-2.2529c.1362-.1328.1851-.332.1265-.5127ZM15.6509,6.1875c-.1177.1152-.1714.2803-.1436.4434l.4189,2.4424-2.1934-1.1533c-.0732-.0381-.1528-.0576-.2329-.0576s-.1597.0195-.2329.0576l-2.1934,1.1533.4189-2.4424c.0278-.1631-.0259-.3281-.1436-.4434l-1.7744-1.7285,2.4521-.3564c.1631-.0244.3037-.126.3765-.2734l1.0967-2.2227,1.0967,2.2227c.0728.1475.2134.249.3765.2734l2.4521.3564-1.7744,1.7285Z"/><path class="reviews-icon-cls1" d="M1.5351,12c-.0322.1885.0449.3779.1987.4893.1553.1123.3594.1279.5269.0381l2.2393-1.1777,2.2393,1.1777c.0732.0391.1533.0576.2329.0576.1035,0,.2065-.0322.2939-.0957.1538-.1113.231-.3008.1987-.4893l-.4277-2.4932,1.812-1.7656c.1362-.1328.1851-.332.1265-.5127-.0591-.1816-.2153-.3135-.4038-.3408l-2.5039-.3633-1.1196-2.2695c-.168-.3398-.7285-.3398-.8965,0l-1.1196,2.2695-2.5039.3633c-.1885.0273-.3447.1592-.4038.3408-.0586.1807-.0098.3799.1265.5127l1.812,1.7656-.4277,2.4932ZM1.5747,7.7324l1.7612-.2559c.1631-.0244.3037-.126.3765-.2734l.7876-1.5967.7876,1.5967c.0728.1475.2134.249.3765.2734l1.7612.2559-1.2744,1.2412c-.1177.1152-.1714.2803-.1436.4434l.3008,1.7539-1.5752-.8281c-.0732-.0381-.1528-.0576-.2329-.0576s-.1597.0195-.2329.0576l-1.5752.8281.3008-1.7539c.0278-.1631-.0259-.3281-.1436-.4434l-1.2744-1.2412Z"/><path class="reviews-icon-cls1" d="M26.5718,6.8877l-2.5039-.3633-1.1196-2.2695c-.168-.3398-.7285-.3398-.8965,0l-1.1196,2.2695-2.5039.3633c-.1885.0273-.3447.1592-.4038.3408-.0586.1807-.0098.3799.1265.5127l1.812,1.7656-.4277,2.4932c-.0322.1885.0449.3779.1987.4893.1548.1123.3584.1279.5269.0381l2.2393-1.1777,2.2393,1.1777c.0732.0391.1533.0576.2329.0576.1035,0,.2065-.0322.2939-.0957.1538-.1113.231-.3008.1987-.4893l-.4277-2.4932,1.812-1.7656c.1362-.1328.1851-.332.1265-.5127-.0591-.1816-.2153-.3135-.4038-.3408ZM24.1509,8.9736c-.1177.1152-.1714.2803-.1436.4434l.3008,1.7539-1.5752-.8281c-.0732-.0381-.1528-.0576-.2329-.0576s-.1597.0195-.2329.0576l-1.5752.8281.3008-1.7539c.0278-.1631-.0259-.3281-.1436-.4434l-1.2744-1.2412,1.7612-.2559c.1631-.0244.3037-.126.3765-.2734l.7876-1.5967.7876,1.5967c.0728.1475.2134.249.3765.2734l1.7612.2559-1.2744,1.2412Z"/><circle cx="13.5" cy="28.4766" r=".5"/></svg>`
        },
        ages: {
            token: 'ages',
            name: 'Age',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 433.2848 484.2606"><path d="M389.6874,441.4878H37.5974c-3.8212,0-6.9189-3.0977-6.9189-6.9189v-150.8947c0-3.8212,3.0977-6.9189,6.9189-6.9189s6.9189,3.0977,6.9189,6.9189v143.9758h338.2521v-143.9758c0-3.8212,3.0977-6.9189,6.9189-6.9189s6.9189,3.0977,6.9189,6.9189v150.8947c0,3.8212-3.0977,6.9189-6.9189,6.9189Z"/><path d="M235.6515,189.9989c-3.8212,0-6.9189-3.0977-6.9189-6.9189v-87.0123h-30.1803v87.0123c0,3.8212-3.0977,6.9189-6.9189,6.9189s-6.9189-3.0977-6.9189-6.9189v-87.6627c.0076-7.2915,5.9167-13.2006,13.2082-13.2082h31.4326c7.2942.0038,13.2075,5.914,13.2151,13.2082v87.6627c0,3.8212-3.0977,6.9189-6.9189,6.9189Z"/><path d="M213.6424,76.8262c-13.9946-.0152-25.3357-11.3563-25.3509-25.3509,0-11.0703,14.7304-39.597,19.2415-48.0865,2.1068-3.3741,6.5501-4.4015,9.9242-2.2946.9294.5804,1.7142,1.3652,2.2946,2.2946,4.5111,8.4895,19.2415,37.0439,19.2415,48.0865-.0153,13.9946-11.3563,25.3356-25.3509,25.3509ZM213.6424,21.9246c-5.104,9.3088-8.9742,19.2425-11.5131,29.5507.0048,6.3585,5.1633,11.5092,11.5218,11.5044,6.3517-.0048,11.4996-5.1527,11.5044-11.5044-2.5388-10.3082-6.4091-20.2419-11.5131-29.5507Z"/><path d="M213.6424,96.1092c-3.8212,0-6.9189-3.0977-6.9189-6.9189v-19.283c0-3.8212,3.0977-6.9189,6.9189-6.9189s6.9189,3.0977,6.9189,6.9189v19.283c0,3.8212-3.0977,6.9189-6.9189,6.9189Z"/><path d="M280.7559,290.5931c-13.8526.1544-27.2732-4.8185-37.6804-13.9624-16.7421-14.924-42.0134-14.924-58.7555,0-21.6794,18.6154-53.7022,18.6154-75.3816,0-16.7603-14.9319-42.0506-14.9319-58.8108,0-6.0497,5.0154-12.9482,8.9075-20.3693,11.4923-5.6912,1.7797-11.8893.7527-16.7023-2.7676-4.7582-3.4634-7.5596-9.0044-7.5278-14.8895v-55.9533c.0267-21.1726,17.1859-38.3287,38.3585-38.3516h339.5114c21.1726.0229,38.3318,17.1789,38.3585,38.3516v55.9533c.0281,5.891-2.7814,11.4354-7.5486,14.8964-4.7969,3.552-11.0089,4.5818-16.6954,2.7676-7.4116-2.584-14.3007-6.4738-20.3416-11.4854-16.7342-14.917-41.9936-14.917-58.7278,0-10.411,9.1404-23.8341,14.1085-37.6873,13.9485ZM213.6908,251.605c13.8526-.1544,27.2732,4.8185,37.6804,13.9624,16.7456,14.9219,42.0168,14.9219,58.7624,0,21.6638-18.6152,53.6763-18.6152,75.3401,0,4.8033,4.0515,10.2874,7.2188,16.1972,9.3544,1.4777.4809,3.0963.2236,4.352-.6919,1.2053-.8632,1.9131-2.2607,1.8958-3.7431v-55.9741c-.0191-13.5333-10.9873-24.4985-24.5206-24.5137H43.8867c-13.5334.0152-24.5016,10.9804-24.5206,24.5137v55.9533c-.0131,1.4779.6909,2.8706,1.8889,3.7362,1.259.92,2.884,1.1775,4.3658.6919,5.92-2.1349,11.4137-5.3046,16.2249-9.3613,10.4118-9.1453,23.8372-14.1183,37.6943-13.9624,13.8571-.1559,27.2825,4.817,37.6943,13.9624,16.7478,14.9229,42.0215,14.9229,58.7693,0,10.4147-9.1318,23.8371-14.0921,37.6873-13.9278Z"/><path d="M389.6874,375.4744c-14.3104.1994-28.2237-4.7066-39.2441-13.8378-18.0802-15.0518-44.3284-15.0518-62.4087,0-22.8872,18.4852-55.5733,18.4852-78.4605,0-18.0659-15.0482-44.3013-15.0482-62.3671,0-11.0167,9.1282-24.9246,14.0339-39.2303,13.8378-14.3022.2001-28.207-4.7063-39.2164-13.8378-8.6599-7.452-19.7533-11.4674-31.1767-11.2848-3.8212,0-6.9189-3.0977-6.9189-6.9189s3.0977-6.9189,6.9189-6.9189c14.3022-.2001,28.207,4.7063,39.2164,13.8378,18.0659,15.0482,44.3013,15.0482,62.3671,0,22.8828-18.483,55.5639-18.483,78.4467,0,18.0713,15.0476,44.3097,15.0476,62.381,0,22.8979-18.4843,55.5903-18.4843,78.4882,0,8.6684,7.4561,19.7719,11.4716,31.2043,11.2848,3.8212,0,6.9189,3.0977,6.9189,6.9189s-3.0977,6.9189-6.9189,6.9189Z"/><path d="M420.3658,484.2606H6.9189c-3.8212,0-6.9189-3.0977-6.9189-6.9189v-28.5129c.0114-11.692,9.4868-21.1674,21.1788-21.1788h384.9271c11.692.0115,21.1673,9.4868,21.1788,21.1788v28.5129c0,3.8212-3.0977,6.9189-6.9189,6.9189ZM13.8378,470.4227h399.6091v-21.594c-.0038-4.0527-3.2882-7.3372-7.341-7.341H21.1788c-4.0527.0038-7.3371,3.2882-7.341,7.341v21.594Z"/></svg>`
        },
        genders: {
            token: 'genders',
            name: 'Gender',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 495.114 512.0002"><path d="M454.451,247.8192h-.073c-13.284,0-24.795,7.735-30.268,18.937l-45.856-45.857c17.131-27.83,24.362-61.106,20.364-93.722-4.077-33.256-19.752-64.327-44.138-87.49C327.157,13.7342,291.226-.3898,253.256.0082c-37.944.367-73.621,15.142-100.462,41.604-10.967,10.813-19.99,23.062-26.911,36.323C55.163,85.8582,0,146.0072,0,218.8132c0,32.31,11.16,63.918,31.423,89.001,2.604,3.224,7.329,3.728,10.556,1.122,3.225-2.605,3.728-7.331,1.122-10.556-18.113-22.421-28.088-50.678-28.088-79.567,0-62.004,44.747-113.739,103.639-124.638-4.224,11.334-7.025,23.223-8.298,35.451-36.733,12.982-63.124,48.058-63.124,89.187,0,52.13,42.411,94.54,94.539,94.54,27.254,0,51.841-11.602,69.109-30.114,9.004,2.857,18.299,4.846,27.752,5.888,2.697.297,5.398.511,8.1.656-18.324,27.087-46.928,46.927-80.842,53.471-3.532.681-6.084,3.773-6.084,7.37v39.504c0,4.146,3.36,7.506,7.506,7.506h20.567c9.961,0,18.065,8.091,18.065,18.035,0,9.961-8.104,18.065-18.065,18.065h-20.567c-4.146,0-7.506,3.36-7.506,7.506v37.702c0,4.837-1.871,9.371-5.262,12.763-3.414,3.406-7.95,5.283-12.773,5.283-9.962,0-18.065-8.095-18.065-18.045v-37.703c0-4.146-3.36-7.506-7.506-7.506h-20.567c-9.951,0-18.045-8.104-18.045-18.065,0-9.944,8.095-18.035,18.045-18.035h20.567c4.146,0,7.506-3.36,7.506-7.506v-39.504c0-3.597-2.552-6.689-6.084-7.37-18.301-3.531-35.248-10.904-50.374-21.912-3.35-2.439-8.046-1.702-10.485,1.652-2.44,3.351-1.701,8.046,1.652,10.485,15.232,11.086,32.121,18.877,50.28,23.205v25.938h-13.061c-18.228,0-33.058,14.825-33.058,33.047,0,18.239,14.83,33.078,33.058,33.078h13.061v30.195c0,18.228,14.839,33.058,33.078,33.058,8.827,0,17.13-3.434,23.384-9.674,6.232-6.233,9.664-14.538,9.664-23.384v-30.195h13.061c18.239,0,33.078-14.839,33.078-33.078,0-18.222-14.839-33.047-33.078-33.047h-13.063v-25.94c38.689-9.24,70.649-34.11,89.68-67.038,23.34-1.609,46.152-8.808,66.098-21.086l45.857,45.858c-11.203,5.476-18.938,17.003-18.938,30.34,0,18.561,15.102,33.663,33.664,33.663h73.501c12.922,0,23.435-10.513,23.435-23.435v-73.502c0-18.561-15.101-33.663-33.663-33.663h0ZM141.768,298.3412c-43.851,0-79.527-35.676-79.527-79.528,0-32.4,19.481-60.307,47.33-72.694.301,38.311,15.34,74.264,42.476,101.402,12.571,12.57,27.343,22.659,43.415,29.846-14.159,13-33.002,20.974-53.694,20.974ZM473.102,354.9842c0,4.644-3.779,8.422-8.422,8.422h-73.501c-10.284,0-18.651-8.366-18.651-18.724,0-10.284,8.367-18.65,18.651-18.65,3.036,0,5.773-1.829,6.935-4.634s.52-6.033-1.626-8.181l-55.471-55.471c-2.831-2.831-6.565-4.295-10.347-4.295-2.669,0-5.364.729-7.782,2.223-24.487,15.123-53.823,21.712-82.611,18.531-29.64-3.269-56.478-16.167-77.611-37.301-24.69-24.689-38.218-57.515-38.095-92.432.124-34.913,13.891-67.646,38.764-92.169,49.205-48.512,130.719-49.308,180.808-1.732,21.866,20.77,35.922,48.625,39.575,78.432,3.594,29.313-2.921,59.211-18.346,84.187-3.608,5.845-2.756,13.3,2.072,18.129l55.47,55.47c2.147,2.146,5.374,2.788,8.181,1.626,2.805-1.161,4.634-3.899,4.634-6.935,0-10.284,8.366-18.65,18.65-18.65h.073c10.284,0,18.65,8.366,18.65,18.65v73.504Z"/><path d="M343.921,122.2012c-4.088.689-6.844,4.561-6.155,8.649,4.532,26.895-4.259,54.448-23.517,73.705-9.013,9.014-19.581,15.54-30.845,19.611.068-1.778.114-3.56.114-5.352,0-59.901-37.337-111.238-89.953-131.97.484-.508.951-1.026,1.449-1.524,32.873-32.873,86.362-32.873,119.235,0,4.909,4.909,9.192,10.386,12.729,16.279,2.134,3.555,6.744,4.705,10.3,2.572,3.554-2.134,4.706-6.745,2.572-10.3-4.168-6.943-9.21-13.392-14.985-19.168-38.728-38.726-101.74-38.726-140.468,0-38.726,38.727-38.726,101.74,0,140.468,19.364,19.363,44.798,29.045,70.234,29.045s50.87-9.682,70.234-29.045c22.685-22.686,33.041-55.14,27.704-86.815-.688-4.088-4.552-6.843-8.648-6.155h0ZM170.367,144.6202c29.757,11.514,50.929,40.415,50.929,74.193,0,1.175-.034,2.342-.087,3.504-9.516-4.097-18.434-10.002-26.194-17.763-16.518-16.517-24.729-38.238-24.648-59.934ZM235.938,227.1062c.239-2.734.37-5.498.37-8.293,0-41.627-27.039-77.044-64.467-89.64,1.983-10.5,5.974-20.687,11.957-29.954,49.287,17.38,84.707,64.424,84.707,119.593,0,3.122-.125,6.219-.351,9.293-10.685,1.724-21.634,1.39-32.216-.999h0Z"/></svg>`,
            importance: {
                active: false,
                default: 10
            }
        },
        activityTypes: {
            token: 'activity_types',
            name: 'Activity Types',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 415.9976 409.0015"><path d="M21.4841,152.0738C9.6343,152.0738,0,161.7081,0,173.554s9.6343,21.4841,21.4841,21.4841c4.6455,0,8.9244-1.5212,12.4427-4.037,3.335,26.6835,14.1433,51.4753,30.7089,71.7346-11.4949.4057-20.7352,9.8176-20.7352,21.4061,0,11.8498,9.6343,21.4841,21.4841,21.4841,11.7406,0,21.2852-9.4783,21.449-21.1877,6.0731,4.7625,12.5402,9.0765,19.4168,12.821l-12.2399,29.5816c-1.0765,2.6095.1599,5.6012,2.7655,6.6816.6436.2613,1.3028.3862,1.9581.3862,2.0088,0,3.9083-1.1858,4.7235-3.1555l11.9785-28.9458c3.7991,1.7201,7.6723,3.3272,11.6665,4.7235.5578.195,1.1273.2847,1.6889.2847,2.1102,0,4.0878-1.3184,4.825-3.4247.9322-2.668-.472-5.5817-3.1399-6.5178-17.5641-6.1355-33.135-15.8556-46.151-28.076l72.3431-72.347c3.3467,2.4417,7.2277,4.1775,11.448,4.9771v15.216c0,2.824,2.2896,5.1097,5.1136,5.1097s5.1136-2.2857,5.1136-5.1097v-15.1496c4.3296-.7528,8.3198-2.4768,11.7523-4.9498l6.3111,6.3072c.9985.9985,2.3052,1.4978,3.6119,1.4978,1.3106,0,2.6173-.4993,3.6158-1.4978,1.9971-1.9971,1.9971-5.2306,0-7.2277l-6.4242-6.4242c2.1258-3.1789,3.6119-6.8103,4.3179-10.7108h102.424c-.4447,11.959-2.4066,23.7347-6.0458,35.054-.862,2.6875.6163,5.5661,3.3037,6.432,2.6836.8581,5.57-.6124,6.432-3.3076,2.6914-8.3705,4.4817-16.9829,5.5583-25.7162,3.53,2.547,7.8284,4.0878,12.5051,4.0878,11.842,0,21.4802-9.6343,21.4802-21.4841s-9.6382-21.4802-21.4802-21.4802c-4.6533,0-8.9361,1.5212-12.4544,4.0448-3.0892-24.8893-12.6611-47.7932-27.0229-66.9253,10.3325-1.5524,18.3052-10.4027,18.3052-21.1565,0-11.8498-9.6382-21.4841-21.4802-21.4841-10.4885,0-19.2101,7.5592-21.0824,17.5134-19.959-16.1482-44.3958-26.9409-71.1378-30.2291,2.4768-3.5027,3.9668-7.7503,3.9668-12.353,0-11.8498-9.6382-21.4841-21.4841-21.4841s-21.4841,9.6343-21.4841,21.4841c0,4.6299,1.5056,8.8932,4.0097,12.4076-24.9049,3.1399-47.8088,12.7781-66.9292,27.2062-1.3808-10.5236-10.3091-18.6991-21.1994-18.6991-11.8459,0-21.4802,9.6343-21.4802,21.4841,0,10.6328,7.7777,19.4207,17.9346,21.1253-16.1638,19.9278-26.976,44.3373-30.3071,71.052-3.5027-2.4924-7.7621-3.9863-12.3764-3.9863ZM21.4841,184.8148c-6.2057,0-11.2608-5.0551-11.2608-11.2608s5.0551-11.2569,11.2608-11.2569,11.253,5.0512,11.253,11.2569-5.0473,11.2608-11.253,11.2608ZM173.4448,191.7187c-10.1141,0-18.3481-8.2262-18.3481-18.3442s8.234-18.3481,18.3481-18.3481,18.3442,8.234,18.3442,18.3481-8.2301,18.3442-18.3442,18.3442ZM145.3571,178.4881c.6982,3.8498,2.157,7.4305,4.236,10.5782l-72.4445,72.4445c-20.3803-22.3773-32.8034-51.5962-33.9931-83.0227h102.2016ZM197.2107,157.5462l72.3743-72.3743c20.3178,22.0614,33.1428,51.1125,34.4222,83.0929h-102.4786c-.7099-3.9044-2.196-7.5397-4.3179-10.7187ZM190.0922,150.2015c-3.374-2.43-7.2862-4.1424-11.5339-4.9147V43.0891c32.3003,1.2248,61.6244,14.2252,83.8067,34.8434l-72.2729,72.269ZM168.3312,145.2869c-4.3023.7801-8.2613,2.5275-11.6626,5.0083l-72.152-72.152c22.1589-20.6884,51.4909-33.7708,83.8145-35.0501v102.1938ZM149.593,157.6827c-2.079,3.1477-3.5378,6.7323-4.236,10.5821H43.0969c1.2755-31.8712,14.0107-60.8365,34.2115-82.8706l72.2846,72.2885ZM65.3845,295.4026c-6.2057,0-11.2608-5.0551-11.2608-11.2608s5.0551-11.2569,11.2608-11.2569,11.253,5.0512,11.253,11.2569-5.0473,11.2608-11.253,11.2608ZM325.7058,162.2971c6.2057,0,11.253,5.0512,11.253,11.2569s-5.0473,11.2608-11.253,11.2608-11.2569-5.0551-11.2569-11.2608,5.0512-11.2569,11.2569-11.2569ZM283.0535,56.7761c6.2057,0,11.253,5.0551,11.253,11.2608s-5.0473,11.253-11.253,11.253-11.2569-5.0473-11.2569-11.253,5.0512-11.2608,11.2569-11.2608ZM173.316,10.2233c6.2057,0,11.2569,5.0551,11.2569,11.2608s-5.0512,11.253-11.2569,11.253-11.2608-5.0473-11.2608-11.253,5.0551-11.2608,11.2608-11.2608ZM56.4562,63.8828c0-6.2057,5.0512-11.2608,11.2569-11.2608s11.2569,5.0551,11.2569,11.2608-5.0512,11.2569-11.2569,11.2569-11.2569-5.0512-11.2569-11.2569Z"/><path d="M5.1136,375.5428h18.7849c2.0985.0429,4.1502.0624,6.1823.0624.7567,0,1.4627-.0312,2.2116-.0351v28.3178c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1097-2.2896,5.1097-5.1136v-28.5753c11.6353-.4954,22.1199-1.6577,31.4968-3.452v32.0272c0,2.824,2.2857,5.1136,5.1097,5.1136,2.8279,0,5.1136-2.2896,5.1136-5.1136v-34.3597c12.3608-3.2101,22.6621-7.567,31.2783-12.7898v47.1496c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1136-2.2896,5.1136-5.1136v-54.2953c16.351-13.2696,25.1896-30.194,31.2744-47.3368v101.6322c0,2.824,2.2857,5.1136,5.1097,5.1136,2.8279,0,5.1136-2.2896,5.1136-5.1136v-135.5004c7.1224-20.5675,20.3217-33.5172,30.8493-40.9867v176.4872c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1136-2.2896,5.1136-5.1136v-182.7241c3.0736-1.5719,5.098-2.3481,5.2501-2.4027.1677-.0702,11.998-5.0005,27.4285-4.2048v189.3316c0,2.824,2.2896,5.1136,5.1136,5.1136,2.8279,0,5.1136-2.2896,5.1136-5.1136v-187.9235c3.6275.8113,7.3369,1.9581,11.0619,3.6431,7.4656,3.3779,14.194,8.4134,20.2164,14.9585v169.3219c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1097-2.2896,5.1097-5.1136v-155.6155c4.7976,7.9103,8.9517,17.1545,12.4154,27.7562,4.9537,15.1731,11.4402,26.8473,18.43,35.9005v91.9588c0,2.824,2.2896,5.1136,5.1136,5.1136s5.1136-2.2896,5.1136-5.1136v-80.7448c6.9936,6.4476,14.0224,10.7967,20.1891,13.6792,4.4232,2.0673,8.6475,3.5261,12.4973,4.5636v62.5021c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1097-2.2896,5.1097-5.1136v-60.4933c5.3827.6553,8.7684.4291,8.862.4213l18.3208-.0039c2.824,0,5.1097-2.2935,5.1097-5.1136,0-2.8279-2.2896-5.1136-5.1097-5.1136l-18.6874.0195c-2.0088.0975-49.6303,2.668-70.3499-60.7507-10.3676-31.7464-26.6874-52.817-48.4953-62.623-28.5636-12.8561-55.7112-1.3457-56.5225-.9829-1.685.5929-41.3417,15.1145-54.1705,61.7337l-.9439,3.4364c-6.6114,24.195-13.6792,50.2076-36.743,68.1968-.4057.2535-.7957.5188-1.1156.8737-18.4729,13.8859-46.9233,22.744-92.8638,21.8313H5.1136c-2.8279,0-5.1136,2.2857-5.1136,5.1136,0,2.824,2.2857,5.1097,5.1136,5.1097Z"/></svg>`
        },
        verifications: {
            token: 'verifications',
            name: 'Verifications',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 425.382 494"><path d="M410.213,67.013L213.021.627c-2.484-.836-5.174-.836-7.658,0L8.171,67.013c-4.883,1.644-8.171,6.221-8.171,11.373v164.825c0,122.08,87.022,227.462,206.92,250.572.75.145,1.511.217,2.271.217s1.521-.072,2.271-.217c119.897-23.11,206.92-128.492,206.92-250.572V78.386c.001-5.153-3.287-9.73-8.169-11.373h0ZM394.383,243.211c0,109.829-77.738,204.737-185.191,226.557-107.453-21.82-185.191-116.728-185.191-226.557V87.008L209.192,24.662l185.191,62.346v156.203ZM186.917,290.563l126.273-120.9c4.787-4.583,12.383-4.418,16.967.369,4.583,4.787,4.418,12.383-.369,16.967l-134.402,128.683c-2.317,2.219-5.308,3.332-8.3,3.332-2.908,0-5.818-1.052-8.116-3.161l-74.957-68.838c-4.881-4.483-5.204-12.074-.722-16.956,4.483-4.881,12.075-5.203,16.956-.722l66.67,61.226Z"/></svg>`
        },
        networks: {
            token: 'networks',
            name: 'Networks',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 487 480"><path d="M384,192c52.9375,0,96-43.0625,96-96S436.9375,0,384,0c-38.4414,0-71.5859,22.7617-86.9023,55.4727l-25.707-9.4883c.3047-1.9688.6094-3.9375.6094-5.9844,0-22.0547-17.9453-40-40-40s-40,17.9453-40,40,17.9453,40,40,40c14.3281,0,26.8242-7.6406,33.8867-18.9922l25.6641,9.4727c-2.2539,8.1445-3.5508,16.6719-3.5508,25.5195,0,10.4805,1.7422,20.543,4.8633,29.9922l-87.9844,37.2891c-16.1094-30.457-48.0859-51.2812-84.8789-51.2812-11.9219,0-23.2969,2.2891-33.8398,6.2734l-22.1289-46.5039c9.6406-7.3125,15.9688-18.7695,15.9688-31.7695C80,17.9453,62.0547,0,40,0S0,17.9453,0,40s17.9453,40,40,40c3.3281,0,6.5195-.5273,9.6172-1.3047l22.1016,46.457c-28.4883,16.6719-47.7188,47.5195-47.7188,82.8477,0,33.1836,16.9297,62.4727,42.5938,79.7188l-14.6328,26.3047c-3.8086-1.1992-7.7695-2.0234-11.9609-2.0234-22.0547,0-40,17.9453-40,40s17.9453,40,40,40,40-17.9453,40-40c0-12.1133-5.5273-22.8555-14.0547-30.1914l14.6641-26.3594c12.0312,5.4453,25.3438,8.5508,39.3906,8.5508,21.9531,0,42.1445-7.4883,58.3359-19.9375l31.4883,34.6406c-15.9688,17.1523-25.8242,40.0664-25.8242,65.2969,0,4.8945.4883,9.6641,1.1914,14.3594l-37.0469,8.793c-6.375-13.6328-20.1289-23.1523-36.1445-23.1523-22.0547,0-40,17.9453-40,40s17.9453,40,40,40,40-17.9453,40-40c0-.4414-.1211-.8555-.1289-1.2969l36.9766-8.7656c12.6094,38.3086,48.6719,66.0625,91.1523,66.0625,52.9375,0,96-43.0625,96-96,0-16.4141-4.1523-31.8711-11.4492-45.3906l46.9922-30.5547c7.2656,7.3594,17.3281,11.9453,28.457,11.9453,22.0547,0,40-17.9453,40-40s-17.9453-40-40-40-40,17.9453-40,40c0,5.168,1.0625,10.0781,2.8555,14.6172l-47.1016,30.6211c-9.4258-12.1172-21.6641-21.9023-35.7539-28.3984l39.0469-108.2461c7.9688,2.1484,16.3125,3.4062,24.9531,3.4062ZM232,64c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM16,40c0-13.2305,10.7695-24,24-24s24,10.7695,24,24-10.7695,24-24,24-24-10.7695-24-24ZM40,376c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM112,448c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM440,256c13.2305,0,24,10.7695,24,24s-10.7695,24-24,24-24-10.7695-24-24,10.7695-24,24-24ZM336.8867,160.5117c3.5703-18.5039,19.8828-32.5117,39.1133-32.5117h16c19.2305,0,35.543,14.0078,39.1133,32.5117-13.2344,9.6875-29.4883,15.4883-47.1133,15.4883s-33.8789-5.8008-47.1133-15.4883ZM384,112c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM384,16c44.1133,0,80,35.8867,80,80,0,20-7.4336,38.2734-19.6172,52.3125-5.6055-14.7617-17.293-26.543-31.8555-32.3594,7.082-7.2188,11.4727-17.0742,11.4727-27.9531,0-22.0547-17.9453-40-40-40s-40,17.9453-40,40c0,10.8789,4.3906,20.7344,11.4727,27.9531-14.5625,5.8164-26.25,17.5977-31.8555,32.3594-12.1836-14.0391-19.6172-32.3125-19.6172-52.3125,0-44.1133,35.8867-80,80-80ZM40,208c0-44.1133,35.8867-80,80-80s80,35.8867,80,80c0,20.0625-7.4805,38.3828-19.7266,52.4414-5.5859-14.8164-17.2969-26.6562-31.8984-32.4883,7.0742-7.2188,11.4648-17.0742,11.4648-27.9531,0-22.0547-17.9453-40-40-40s-40,17.9453-40,40c0,10.8789,4.3906,20.7344,11.4727,27.9531-14.5195,5.7891-26.1914,17.5273-31.8164,32.2305-12.1133-14.0234-19.4961-32.2383-19.4961-52.1836ZM95.8398,200c0-13.2305,10.7695-24,24-24s24,10.7695,24,24-10.7695,24-24,24-24-10.7695-24-24ZM72.7539,272.4062c3.6055-18.4531,19.8945-32.4062,39.0859-32.4062h16c19.2656,0,35.6094,14.0547,39.1289,32.6172-13.207,9.6289-29.4102,15.3828-46.9688,15.3828-17.6875,0-33.9922-5.8398-47.2461-15.5938ZM232.7539,448.4062c3.6055-18.4531,19.8945-32.4062,39.0859-32.4062h16c19.2656,0,35.6094,14.0547,39.1289,32.6172-13.207,9.6289-29.4102,15.3828-46.9688,15.3828-17.6875,0-33.9922-5.8398-47.2461-15.5938ZM279.8398,400c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM360,384c0,20.0625-7.4805,38.3828-19.7266,52.4414-5.5859-14.8164-17.2969-26.6562-31.8984-32.4883,7.0742-7.2188,11.4648-17.0742,11.4648-27.9531,0-22.0547-17.9453-40-40-40s-40,17.9453-40,40c0,10.8789,4.3906,20.7344,11.4727,27.9531-14.5195,5.7891-26.1914,17.5273-31.8164,32.2305-12.1133-14.0234-19.4961-32.2383-19.4961-52.1836,0-44.1133,35.8867-80,80-80s80,35.8867,80,80ZM304.9531,291.4062c-7.9688-2.1484-16.3125-3.4062-24.9531-3.4062-21.9531,0-42.1445,7.4883-58.3359,19.9375l-31.4883-34.6406c15.9688-17.1523,25.8242-40.0664,25.8242-65.2969,0-10.4805-1.7422-20.543-4.8633-29.9922l87.9844-37.2891c9.8555,18.6328,25.6719,33.5859,44.8867,42.4414l-39.0547,108.2461Z"/></svg>`
        },
        distance: {
            token: 'distance',
            name: 'Distance',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30.3688 25.9848"><defs><style>.distance-icon-cls-1{fill-rule:evenodd;}</style></defs><path class="distance-icon-cls-1" d="M3.5723,17.9278c-.8842-.2233-1.5396-1.0246-1.5396-1.9781,0-1.1254.9139-2.0395,2.0392-2.0395s2.0388.9141,2.0388,2.0395c0,.9534-.6551,1.7548-1.5393,1.9781v3.5597c0,.9278.3683,1.8174,1.024,2.4733.6557.6562,1.5454,1.0246,2.4726,1.0246h1.9983c1.9314,0,3.497-1.5661,3.497-3.4979V4.4972c0-2.4838,2.0129-4.4972,4.4957-4.4972h1.9983c1.1925,0,2.3359.4738,3.1791,1.3172.8433.8437,1.3169,1.9874,1.3169,3.1801v3.0194c.8842.2229,1.5393,1.0246,1.5393,1.9777,0,1.1258-.9135,2.0399-2.0388,2.0399s-2.0392-.9142-2.0392-2.0399c0-.9531.6554-1.7548,1.5396-1.9777v-3.0194c0-.9274-.3686-1.8174-1.0244-2.4733s-1.5451-1.0246-2.4726-1.0246h-1.9983c-1.9311,0-3.4966,1.5661-3.4966,3.4983v16.99c0,2.4838-2.0129,4.4972-4.4961,4.4972h-1.9983c-1.1921,0-2.3359-.4738-3.1788-1.3172-.8433-.8434-1.3169-1.9874-1.3169-3.1801v-3.5597ZM4.0719,16.99c.5739,0,1.0397-.466,1.0397-1.0402,0-.5738-.4658-1.0402-1.0397-1.0402s-1.04.4664-1.04,1.0402c0,.5742.4661,1.0402,1.04,1.0402ZM23.8891,8.4674c-.4958.079-.8753.5092-.8753,1.027,0,.5742.4661,1.0402,1.04,1.0402s1.0397-.466,1.0397-1.0402c0-.5178-.3795-.948-.8753-1.027-.0515.0179-.1067.0276-.1644.0276s-.1132-.0097-.1647-.0276h0ZM4.0801,1.4899c2.2506,0,4.0637,1.5595,4.0637,4.1269,0,.7352-.3332,1.7069-.8211,2.7-1.068,2.1726-2.847,4.4813-2.847,4.4813-.0945.1225-.2404.1941-.3949.1945-.1548,0-.3008-.0716-.3956-.1937,0,0-1.7872-2.3083-2.86-4.4813-.4907-.9935-.8252-1.9652-.8252-2.7008C0,3.0501,1.8301,1.4899,4.0801,1.4899ZM4.0801,2.4896c-1.7023,0-3.0809,1.1857-3.0809,3.1272,0,.6173.31,1.4241.7216,2.2581.7246,1.4673,1.7882,2.9984,2.3584,3.7811.5678-.7831,1.6259-2.3134,2.3468-3.7803.4102-.834.7188-1.6412.7188-2.2589,0-1.9407-1.363-3.1272-3.0646-3.1272h0ZM23.9723,12.5017c2.4354,0,4.3965,1.6879,4.3965,4.4661,0,.7982-.3628,1.8528-.8931,2.9311-1.1655,2.3721-3.1079,4.8921-3.1079,4.8921-.0945.1225-.2404.1941-.3949.1945-.1548,0-.3008-.0712-.3956-.1937,0,0-1.9512-2.5199-3.1222-4.8921-.5326-1.0787-.8975-2.1337-.8975-2.9319,0-2.7775,1.9798-4.4661,4.4146-4.4661h0ZM23.9723,13.5014c-1.8867,0-3.4155,1.314-3.4155,3.4664,0,.6804.34,1.57.7942,2.4896.8095,1.6396,2.0061,3.3524,2.6202,4.193.6118-.841,1.8022-2.553,2.608-4.1923.4518-.9196.7904-1.81.7904-2.4904,0-2.1519-1.5113-3.4664-3.3974-3.4664Z"/></svg>`
        },
        life_stages: {
            token: 'life_stages',
            endpoint: '/filters/life-stages',
            name: 'Life Stage',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480.612 511.998"><path d="M353.336,304.254c-.597-6.81-4.287-12.756-10.124-16.315-7.295-4.446-16.499-4.113-23.453.851l-54.336,38.798-4.514-41.989c-1.378-12.815-12.136-22.479-25.024-22.479-12.507,0-23.227,9.344-24.933,21.734l-7.727,56.096-35.227-47.339c-4.688-6.301-12.454-9.719-20.27-8.916-7.967.817-14.724,5.649-18.073,12.924-3.349,7.276-2.626,15.55,1.934,22.134l58.567,84.569c-.742,43.266-21.788,96.837-22.005,97.383-.918,2.316-.63,4.937.77,6.998,1.4,2.061,3.73,3.295,6.221,3.295h113.93c2.637,0,5.081-1.381,6.441-3.639,1.361-2.258,1.439-5.065.208-7.396-.273-.512-26.729-51.326-24.576-112.704l75.063-66.176c5.128-4.521,7.727-11.019,7.128-17.829ZM336.262,310.802l-77.464,68.294c-1.52,1.34-2.434,3.236-2.537,5.259-2.547,50.02,12.68,93.11,21.021,112.606h-91.357v-.001c6.568-18.761,19.292-59.665,19.292-94.956,0-1.53-.467-3.024-1.338-4.281l-59.925-86.53c-2.163-3.123-1.166-6.133-.636-7.283.529-1.149,2.168-3.864,5.946-4.252,2.56-.263,5.125.86,6.669,2.934l46.201,62.086c1.822,2.449,4.945,3.555,7.904,2.794,2.957-.76,5.162-3.232,5.578-6.257l10.235-74.306c.687-4.986,5.001-8.747,10.034-8.747,5.187,0,9.516,3.889,10.071,9.046l5.89,54.783c.286,2.657,1.96,4.963,4.398,6.057,2.438,1.094,5.275.81,7.448-.741l64.807-46.275c2.038-1.457,4.742-1.556,6.884-.25,1.713,1.045,2.796,2.79,2.971,4.788s-.5871,3.905-2.0921,5.232Z"/><path d="M468.612,217.611c0-17.421-5.677-34.482-16.092-48.65,4.817-7.583,7.337-16.204,7.337-25.25,0-26.82-22.669-48.639-50.533-48.639-.222,0-.445.001-.668.004-10.156-33.16-42.274-56.599-78.83-56.599-7.579,0-15.043.987-22.268,2.941C293.669,16.054,266.317,0,236.067,0c-33.816,0-63.873,20.305-75.595,50.206-7.214-1.692-14.606-2.547-22.059-2.547-41.936,0-78.765,27.298-89.69,65.656-24.365,3.586-42.711,23.707-42.711,48.009,0,12.353,4.961,24.224,13.59,33.15C7.052,207.384,0,224.377,0,242.264c0,32.569,22.964,60.362,55.359,68.018,6.867,39.992,41.276,70.819,83.862,74.224,4.126.328,7.765-2.756,8.096-6.897.331-4.14-2.757-7.764-6.897-8.095-37.323-2.984-67.128-30.89-70.871-66.353-.357-3.379-2.935-6.098-6.288-6.636-27.941-4.479-48.221-27.299-48.221-54.261,0-16.238,7.505-31.574,20.592-42.073,1.84-1.477,2.881-3.731,2.811-6.089s-1.243-4.547-3.168-5.911c-9.039-6.409-14.223-16.202-14.223-26.867,0-18.053,14.919-32.772,33.963-33.508,3.431-.132,6.337-2.573,7.061-5.93,7.39-34.295,39.494-59.187,76.337-59.187,8.386,0,16.676,1.281,24.643,3.807,1.941.615,4.051.417,5.845-.55s3.118-2.621,3.669-4.583c7.667-27.28,33.778-46.333,63.498-46.333,26.63,0,50.458,15.11,60.704,38.495,1.584,3.619,5.703,5.394,9.421,4.062,7.562-2.707,15.514-4.079,23.633-4.079,31.812,0,59.476,21.487,65.778,51.091.823,3.867,4.5,6.43,8.412,5.88,1.762-.25,3.548-.377,5.308-.377,19.57,0,35.493,15.072,35.493,33.599,0,7.559-2.601,14.703-7.52,20.661-2.322,2.812-2.291,6.883.07,9.66,10.6,12.465,16.204,27.534,16.204,43.579,0,31.953-22.743,59.628-55.308,67.302-2.025.477-3.762,1.772-4.798,3.577-1.035,1.805-1.277,3.959-.666,5.948,6.404,20.864-.909,36.955-8.17,46.78-12.625,17.082-35.205,28.559-56.185,28.559-2.162,0-4.344-.101-6.485-.301-4.145-.38-7.8,2.654-8.186,6.79-.386,4.135,2.655,7.8,6.789,8.186,2.604.243,5.255.366,7.881.366,25.916,0,52.718-13.604,68.28-34.659,11.608-15.705,15.869-34.155,12.317-52.656,35.4319-11.516,59.5719-43.392,59.5719-79.892Z"/></svg>`,
            importance: {
                active: true,
                default: 7
            }
        },
        relationship: {
            token: 'relationship',
            endpoint: '/filters/relationship',
            name: 'Relationship Status',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 66 52.022"><g><path d="M58.545,29.362c-1.875-1.082-4.052-1.579-6.199-1.436-.948-1.935-2.469-3.567-4.344-4.65-1.659-.957-3.543-1.463-5.449-1.463-3.891,0-7.516,2.092-9.458,5.458-5.147,8.913,4.238,22.789,4.64,23.375.516.752,1.333,1.225,2.252,1.296.184.013,1.175.08,2.625.08,5.771,0,16.035-1.007,19.929-7.751,3.007-5.211,1.215-11.9-3.996-14.909ZM60.808,43.271c-3.392,5.874-12.856,6.751-18.196,6.751h-.002c-1.379,0-2.306-.063-2.479-.075-.303-.023-.576-.181-.748-.432-.373-.544-9.081-13.409-4.557-21.244,1.587-2.75,4.547-4.458,7.726-4.458,1.556,0,3.094.413,4.449,1.195,1.711.987,3.061,2.537,3.8,4.362.171.425.611.681,1.065.615,1.914-.269,3.964.12,5.677,1.108,4.258,2.459,5.722,7.922,3.265,12.178Z"/><path d="M31.959,44.327c-1.347.739-2.313,1.211-2.665,1.379-.805.385-1.785.385-2.588,0-2.529-1.209-24.706-12.259-24.706-27.706C2,9.178,9.178,2,18,2c3.411,0,6.666,1.058,9.411,3.059.351.256.827.256,1.178,0,2.746-2.001,6-3.059,9.411-3.059,8.822,0,16,7.178,16,16,0,2.359-.545,4.78-1.622,7.193-.225.505.002,1.096.506,1.32.504.228,1.096-.001,1.321-.506,1.191-2.671,1.795-5.364,1.795-8.007C56,8.075,47.925,0,38,0c-3.596,0-7.038,1.046-10,3.031-2.962-1.985-6.404-3.031-10-3.031C8.075,0,0,8.075,0,18c0,16.671,23.198,28.246,25.843,29.511.669.32,1.416.489,2.157.489s1.487-.169,2.157-.489c.368-.176,1.373-.667,2.764-1.43.484-.266.662-.873.396-1.357-.266-.485-.874-.665-1.358-.397Z"/></g></svg>`,
            importance: {
                active: true,
                default: 8
            }
        },
        languages: {
            token: 'languages',
            endpoint: '/filters/languages',
            name: 'Languages',
            icon: `<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 682.6671 682.6666"><defs><style>.language-cls-1,.language-cls-2{fill:none;}.language-cls-2{stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:26.6667px;}.language-cls-3{clip-path:url(#clippath);}</style><clipPath id="clippath"><rect class="language-cls-1" y="0" width="682.6666" height="682.6666"/></clipPath></defs><g id="g369"><g id="g371"><g class="language-cls-3"><g id="g373"><g id="g379"><path id="path381" class="language-cls-2" d="M177.3333,493.324l57.072-149.8493c1.1667-2.852,5.2027-2.856,6.3747-.0067l56.5533,149.856"/></g><g id="g383"><path id="path385" class="language-cls-2" d="M195.1324,456.0034h84.6893"/></g><g id="g387"><path id="path389" class="language-cls-2" d="M356,130h178.6667"/></g><g id="g391"><path id="path393" class="language-cls-2" d="M477.5027,130v12.9133c0,67.28-50.08,124.04-116.836,132.42h0"/></g><g id="g395"><path id="path397" class="language-cls-2" d="M413.164,130v12.9133c0,67.28,50.08,124.04,116.836,132.42h0"/></g><g id="g399"><path id="path401" class="language-cls-2" d="M445.3333,130v-48"/></g><g id="g403"><path id="path405" class="language-cls-2" d="M385.3338,13.3333h-106.616c-31.692,0-57.384,25.692-57.384,57.3853v215.896c0,31.6933,25.692,57.3853,57.384,57.3853h233.2827l99.948,85.3333v-85.3333h0c31.6933,0,57.3853-25.692,57.3853-57.3853V70.7187c0-31.6933-25.692-57.3853-57.3853-57.3853h-106.6147"/></g><g id="g407"><path id="path409" class="language-cls-2" d="M461.3333,344v182.6147c0,31.6933-25.692,57.3853-57.3853,57.3853h-233.2813l-99.948,85.3333v-85.3333h0c-31.6933,0-57.3853-25.692-57.3853-57.3853v-215.896c0-31.6933,25.692-57.3853,57.3853-57.3853h150.6147"/></g><g id="g411"><path id="path413" class="language-cls-2" d="M445.3333,13.3333h0"/></g></g></g></g></g></svg>`,
            importance: {
                active: true,
                default: 8
            }
        },
        politics: {
            token: 'politics',
            endpoint: '/filters/politics',
            name: 'Politics',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 508.8916"><path d="M256,130.9697c13.2734,0,24.0664-10.7969,24.0664-24.0664s-10.7969-24.0703-24.0664-24.0703-24.0664,10.7969-24.0664,24.0703,10.7969,24.0664,24.0664,24.0664ZM256,97.833c5,0,9.0664,4.0703,9.0664,9.0703,0,4.9961-4.0664,9.0664-9.0664,9.0664s-9.0664-4.0664-9.0664-9.0664,4.0664-9.0703,9.0664-9.0703Z"/><path d="M504.5,460.7627h-9.0664v-25.6328c0-4.1406-3.3594-7.5-7.5-7.5h-25.6328v-25.6328c0-4.1406-3.3555-7.5-7.5-7.5h-9.0625v-164.1289h9.0625c4.1445,0,7.5-3.3594,7.5-7.5v-25.6328h25.6328c4.1445,0,7.5-3.3594,7.5-7.5v-33.1328c0-4.1406-3.3555-7.5-7.5-7.5h-14.2227L260.2695,1.333c-2.5664-1.7773-5.9688-1.7773-8.5391,0L38.293,149.1025h-14.2266c-4.1406,0-7.5,3.3555-7.5,7.5v33.1328c0,4.1406,3.3594,7.5,7.5,7.5h25.6328v25.6328c0,4.1406,3.3594,7.5,7.5,7.5h9.0664v164.1289h-9.0664c-4.1406,0-7.5,3.3555-7.5,7.5v25.6328h-25.6328c-4.1406,0-7.5,3.3594-7.5,7.5v25.6328H7.5c-4.1445,0-7.5,3.3555-7.5,7.5v33.1289c0,4.1445,3.3555,7.5,7.5,7.5h497c4.1445,0,7.5-3.3555,7.5-7.5v-33.1289c0-4.1406-3.3555-7.5-7.5-7.5ZM447.3008,427.6299h-67.832v-18.1328h67.832v18.1328ZM396.0312,394.4971v-164.1289h34.7031v164.1289h-34.7031ZM447.3008,215.3682h-67.832v-18.1328h67.832v18.1328ZM371.9688,230.3682h9.0625v164.1289h-9.0625c-4.1445,0-7.5,3.3555-7.5,7.5v25.6328h-59.5508v-25.6328c0-4.1445-3.3594-7.5-7.5-7.5h-9.0664v-164.1289h9.0664c4.1406,0,7.5-3.3594,7.5-7.5v-25.6328h59.5508v25.6328c0,4.1406,3.3555,7.5,7.5,7.5ZM222.0859,197.2354h67.832v18.1328h-67.832v-18.1328ZM238.6484,230.3682h34.7031v164.1289h-34.7031v-164.1289ZM289.918,409.4971v18.1328h-67.832v-18.1328h67.832ZM31.5664,164.1025h130.8828c4.1445,0,7.5-3.3594,7.5-7.5,0-4.1445-3.3555-7.5-7.5-7.5h-97.8047L256,16.6221l191.3594,132.4805h-254.9102c-4.1406,0-7.5,3.3555-7.5,7.5,0,4.1406,3.3594,7.5,7.5,7.5h287.9844v18.1328H31.5664v-18.1328ZM64.6992,197.2354h67.8359v18.1328h-67.8359v-18.1328ZM115.9688,230.3682v164.1289h-34.7031v-164.1289h34.7031ZM64.6992,409.4971h67.8359v18.1328h-67.8359v-18.1328ZM140.0352,394.4971h-9.0664v-164.1289h9.0664c4.1406,0,7.5-3.3594,7.5-7.5v-25.6328h59.5508v25.6328c0,4.1406,3.3555,7.5,7.5,7.5h9.0625v164.1289h-9.0625c-4.1445,0-7.5,3.3555-7.5,7.5v25.6328h-59.5508v-25.6328c0-4.1445-3.3594-7.5-7.5-7.5ZM31.5664,442.6299h448.8672v18.1328H31.5664v-18.1328ZM497,493.8955H15v-18.1328h482v18.1328Z"/></svg>`,
            importance: {
                active: true,
                default: 6
            }
        },
        religion: {
            token: 'religion',
            endpoint: '/filters/religion',
            name: 'Religion',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 442.446 512.0022"><path d="M433.4083,352.6975c-12.6727-13.5867-34.0359-14.3288-47.6216-1.6581l-4.0142,3.7442-38.2011-24.9574,2.6532-57.7492c1.9611-42.6983-.126-56.3271-14.8928-97.2203-11.4286-31.6487-27.0185-71.1939-39.5442-102.9696-8.9655-22.7422-16.7079-42.3833-19.1921-49.7597-.011-.032-.021-.063-.033-.096-6.5324-18.77-23.6923-24.7454-37.265-20.9441-5.1623,1.4451-10.1495,4.4442-14.0728,8.8545-3.9232-4.4102-8.9095-7.4094-14.0728-8.8545-13.5747-3.7992-30.7327,2.1731-37.266,20.9431-.011.032-.022.063-.033.096-1.9891,5.9063-7.4224,19.8481-12.9977,34.0319-2.0201,5.1413.509,10.9456,5.6493,12.9657,5.1443,2.0241,10.9456-.51,12.9657-5.6483,6.5334-16.6239,11.3006-28.9276,13.3207-34.9149,2.6141-7.4494,8.3905-9.4935,12.9687-8.2124,4.7713,1.3361,9.0615,6.5394,6.8174,17.1389l-23.3573,100.4435c-5.0023,3.6432-9.8705,9.6745-13.8928,19.3201-11.5816,27.7755-21.3202,57.3991-26.7185,81.2705-1.2181,5.3883,2.1621,10.7416,7.5484,11.9607,5.3863,1.2181,10.7416-2.1611,11.9597-7.5484,5.1553-22.8002,14.5118-51.2238,25.6704-77.9843,5.2293-12.5397,9.7405-12.1307,11.4386-11.9797,5.4283.488,9.4485,5.3363,8.9615,10.8066-.458,5.1493-2.4601,23.9143-4.3972,42.0623-2.0351,19.065-3.9572,37.073-4.4302,42.3963-1.1651,13.0887,1.1351,28.9706,3.5702,45.7845,7.0584,48.7407,15.7859,109.046-49.2847,149.3422l-79.9074-74.5261,38.8581-25.3884c2.9632-1.9371,4.6823-5.2953,4.5203-8.8315l-2.9152-63.4555c-1.8441-40.1382-.176-51.0128,13.7258-89.5089,3.6082-9.9935,7.8054-21.2562,12.8307-34.4319,1.9681-5.1603-.62-10.9396-5.7803-12.9077s-10.9386.621-12.9077,5.7803c-5.0673,13.2877-9.3045,24.6594-12.9547,34.7659-14.7668,40.8932-16.8539,54.522-14.8928,97.2203l2.6521,57.7492-38.2011,24.9584-4.0132-3.7432c-13.5867-12.6737-34.9489-11.9296-47.6226,1.6581-12.6707,13.5867-11.9267,34.9499,1.6601,47.6216l110.052,102.6416c6.4834,6.0473,14.7348,9.0385,22.9703,9.0385,9.0235,0,18.026-3.5932,24.6513-10.6966,6.1383-6.5814,9.3465-15.1598,9.0335-24.1543-.25-7.1634-2.7151-13.9038-7.0314-19.4531,24.8324-16.2959,41.6203-36.427,50.8488-61.0123,9.2285,24.5863,26.0154,44.7164,50.8478,61.0123-4.3152,5.5493-6.7814,12.2897-7.0304,19.4531-.313,8.9945,2.8951,17.573,9.0335,24.1553,6.6264,7.1044,15.6269,10.6956,24.6513,10.6956,8.2345,0,16.4879-2.9922,22.9703-9.0385l110.052-102.6416v-.001c13.5897-12.6737,14.3338-34.0359,1.6621-47.6236h0ZM153.747,487.6608c-5.1503,5.5233-13.8328,5.8233-19.3531.674l-110.052-102.6426c-5.5213-5.1483-5.8233-13.8307-.674-19.3521,2.6921-2.8882,6.3503-4.3472,10.0185-4.3472,3.3462,0,6.7004,1.2161,9.3345,3.6732l110.052,102.6426c2.6751,2.4941,4.2182,5.8813,4.3452,9.5355.127,3.6562-1.1761,7.1424-3.6712,9.8165h0ZM206.7569,133.6225l14.4678-62.2144,14.4678,62.2144c-5.6003,1.2291-10.5616,4.0222-14.4678,7.8584-3.9052-3.8362-8.8675-6.6294-14.4678-7.8584h0ZM221.2247,250.8359c.247,3.3382.224,6.9804,0,10.9006-.223-3.9202-.247-7.5624,0-10.9006ZM237.5186,294.0182c2.4351-16.8139,4.7352-32.6958,3.5702-45.7845-.474-5.3233-2.3961-23.3313-4.4302-42.3973-1.9371-18.147-3.9392-36.912-4.3972-42.0623-.487-5.4703,3.5332-10.3176,8.9615-10.8066,1.7011-.15,6.2103-.56,11.4386,11.9797,11.1586,26.7615,20.5151,55.185,25.6704,77.9843,1.2181,5.3873,6.5724,8.7655,11.9597,7.5484,5.3873-1.2191,8.7665-6.5724,7.5484-11.9607-5.3983-23.8713-15.1368-53.4939-26.7194-81.2705-4.0222-9.6475-8.8895-15.6779-13.8928-19.3211l-23.3563-100.4405c-2.2431-10.5996,2.0461-15.8029,6.8174-17.1389,4.5783-1.2811,10.3566.765,12.9697,8.2154,2.6612,7.8894,10.1046,26.7695,19.5221,50.6578,12.4787,31.6547,28.0085,71.0499,39.3392,102.4276,13.9018,38.4961,15.5688,49.3707,13.7247,89.5089l-2.9152,63.4555c-.162,3.5362,1.5571,6.8954,4.5202,8.8315l38.8581,25.3884-79.9064,74.5261c-65.0686-40.2952-56.3411-100.6015-49.2827-149.3412h0ZM418.1074,385.6922l-110.052,102.6436c-5.5213,5.1483-14.2028,4.8463-19.353-.674-2.4951-2.6751-3.7982-6.1613-3.6712-9.8165s1.6701-7.0414,4.3452-9.5355l110.052-102.6436c2.6341-2.4571,5.9883-3.6732,9.3345-3.6732,3.6672,0,7.3254,1.4611,10.0175,4.3472,5.1503,5.5213,4.8483,14.2038-.673,19.3521h0Z"/><path d="M145.7376,110.8872c1.2841.551,2.6201.812,3.9342.812,3.8802,0,7.5714-2.2721,9.1965-6.0633l.003-.007c2.1751-5.0763-.177-10.9526-5.2543-13.1277-5.0763-2.1791-10.9576.179-13.1327,5.2553s.176,10.9546,5.2533,13.1307h0Z"/></svg>`,
            importance: {
                active: true,
                default: 5
            }
        },
        drinking: {
            token: 'drinking',
            endpoint: '/filters/drinking',
            name: 'Drinking',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 405.3412 481.28"><g id="Layer_50"><path d="M366.9181,7.8375c-1.1103-4.5979-5.225-7.8373-9.955-7.8375H48.3781c-4.7301.0002-8.8447,3.2396-9.955,7.8375L6.0181,142.0375c-15.1216,61.6174-1.4029,126.7677,37.2825,177.055,35.9032,45.7209,90.9998,72.1802,149.13,71.6175v70.09h-78.9325c-5.6554,0-10.24,4.5846-10.24,10.24s4.5846,10.24,10.24,10.24h178.345c5.6554,0,10.24-4.5846,10.24-10.24s-4.5846-10.24-10.24-10.24h-78.9325v-70.09c58.1302.5627,113.2268-25.8967,149.13-71.6175,38.6853-50.2872,52.404-115.4374,37.2825-177.0547L366.9181,7.8375ZM56.4406,20.48h292.46l25.4525,105.4072c-52.6856,62.0859-125.3759,36.4453-184.025,15.703-16.1529-6.25-32.752-11.2792-49.6575-15.045-43.6736-7.8538-89.48,8.1125-114.4832,19.2247L56.4406,20.48ZM345.9506,306.4225c-32.3912,41.1647-82.1855,64.792-134.5575,63.8475h-17.445c-52.372.9445-102.1663-22.6828-134.5575-63.8475-29.7752-38.6391-43.2619-87.389-37.5794-135.8375,15.3066-7.8762,67.9428-32.3942,115.2294-23.8848,15.8103,3.6002,31.3379,8.3452,46.46,14.1975,31.89,11.2775,69.79,24.6825,107.505,24.6825,33.3133.7256,65.4775-12.1876,89.0406-35.7478,12.57,54.6694.0661,112.096-34.0956,156.5901h0Z"/></g></svg>`,
            importance: {
                active: true,
                default: 7
            }
        },
        smoking: {
            token: 'smoking',
            endpoint: '/filters/smoking',
            name: 'Smoking',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 511.9995 512.0008"><path d="M431.1587,207.2378c24.542,24.542,29.457,62.551,11.952,92.432-2.207,3.768-1.714,8.532,1.217,11.768,1.94,2.142,4.652,3.287,7.415,3.287,1.41,0,2.834-.299,4.175-.916,10.358-4.764,19.734-11.304,27.869-19.437,37.541-37.542,37.541-98.626,0-136.167-23.823-23.822-29.274-59.803-13.565-89.533,2.103-3.981,1.287-8.876-1.994-11.959s-8.218-3.594-12.061-1.246l-13.867,8.471c-10.202,6.232-18.791,14.654-24.84,24.355-11.32,18.156-16.277,39.923-13.958,61.292,2.355,21.698,12.177,42.173,27.657,57.653ZM434.4307,98.8738c2.28-3.658,5.074-7.077,8.285-10.164-1.578,9.658-1.708,19.563-.314,29.277,2.972,20.711,12.392,39.509,27.243,54.36,28.89,28.89,29.72,75.377,2.488,105.276,5.208-30.166-4.193-61.89-26.831-84.528-25.249-25.247-29.719-63.992-10.871-94.221h0Z"/><path d="M509.0708,427.7397l-144.335-144.336c-3.905-3.905-10.237-3.905-14.143,0-3.905,3.905-3.905,10.237,0,14.143l100.018,100.018-53.048,53.047-229.393-229.394,53.047-53.047,65.737,65.737c3.905,3.905,10.238,3.905,14.142,0,3.905-3.905,3.905-10.237,0-14.142L84.2608,2.9287c-3.905-3.905-10.237-3.905-14.143,0L2.9287,70.1178c-3.905,3.905-3.905,10.237,0,14.143l424.811,424.811c1.953,1.953,4.512,2.929,7.071,2.929s5.119-.976,7.071-2.929l67.189-67.189c3.905-3.906,3.905-10.238,0-14.143h0ZM154.0278,207.0747l-19.452-19.452,53.047-53.047,19.452,19.452-53.047,53.047ZM77.1898,24.1417l96.291,96.291-53.047,53.047L24.1418,77.1897l53.048-53.048ZM434.8108,487.8578l-23.104-23.104,53.048-53.047,23.104,23.104-53.048,53.047Z"/><path d="M325.8448,268.6657c5.523,0,10-4.477,10-10v-.011c0-5.523-4.477-9.995-10-9.995s-10,4.482-10,10.005,4.477,10.001,10,10.001h0Z"/></svg>`,
            importance: {
                active: true,
                default: 8
            }
        },
    },
    init: function () {
        return new Promise(async (resolve, reject) => {
            console.log("[init] Filters");

            this.life_stages = this.createMultiSelectFilter('life_stages');
            this.relationship = this.createMultiSelectFilter('relationship');
            this.languages = this.createMultiSelectFilter('languages');
            this.politics = this.createMultiSelectFilter('politics');
            this.religion = this.createMultiSelectFilter('religion');
            this.drinking = this.createMultiSelectFilter('drinking');
            this.smoking = this.createMultiSelectFilter('smoking');

            try {
                if (befriend.user.local.data?.filters?.collapsed) {
                    this.data.collapsed = befriend.user.local.data.filters.collapsed;
                }

                await befriend.filters.getData();

                await befriend.filters.initSections();
                befriend.filters.initCollapsible();

                befriend.filters.availability.init();
                befriend.filters.modes.init();
                befriend.filters.reviews.init();
                befriend.filters.age.init();
                befriend.filters.genders.init();
                befriend.filters.distance.init();
                befriend.filters.activity_types.init();
                befriend.filters.verifications.init();

                befriend.filters.life_stages.init();
                befriend.filters.relationship.init();
                befriend.filters.languages.init();
                befriend.filters.politics.init();
                befriend.filters.religion.init();
                befriend.filters.drinking.init();
                befriend.filters.smoking.init();

                befriend.filters.music.init();
                befriend.filters.work.init();
                befriend.filters.instruments.init();

                befriend.filters.active.init();
                befriend.filters.sendReceive.init();
                befriend.filters.importance.init();
            } catch (e) {
                console.error(e);
            }
            resolve();
        });
    },
    getData: function () {
        return new Promise(async (resolve, reject) => {
            try {
                 let response = await befriend.auth.get('/filters');

                 befriend.filters.data.options = response.data;
            } catch(e) {
                console.error(e);
            }

            return resolve();
        });
    },
    active: {
        init: function () {
            this.events();
            this.set();
        },
        set: function () {
            for (let key in befriend.filters.sections) {
                const section = befriend.filters.sections[key];
                const sectionEl = befriend.els.filters.querySelector(`.section.${section.token}`);

                if (!sectionEl) continue;

                const sectionToggle = sectionEl.querySelector('.section-top .toggle');
                if (!sectionToggle) continue;

                // Check if we have filter data for this section
                const filterData = befriend.filters.data?.filters?.[section.token];

                if (filterData && !filterData.is_active) {
                    removeClassEl('active', sectionToggle);
                } else {
                    addClassEl('active', sectionToggle);
                }
            }

            // Handle individual filter option toggles
            let filterOptionToggles = befriend.els.filters.querySelectorAll('.filter-option .toggle');

            for (let toggle of filterOptionToggles) {
                //skip availability days
                if(toggle.closest('.day-section')) {
                    continue;
                }

                let filterOptionEl = toggle.closest('.filter-option');
                if (!filterOptionEl) continue;

                let filterToken = befriend.filters.getFilterToken(filterOptionEl);
                if (!filterToken) continue;

                const filterData = befriend.filters.data?.filters?.[filterToken];

                //skip reviews/verifications if not set
                let skipReview = false;
                let skipVerification = false;

                for(let k in befriend.filters.reviews.ratings) {
                    let data = befriend.filters.reviews.ratings[k];

                    if(data.token === filterToken) {
                        if(typeof filterData?.is_active === 'undefined') {
                            skipReview = true;
                            break;
                        }
                    }
                }

                for(let k in befriend.filters.verifications.options) {
                    let data = befriend.filters.verifications.options[k];

                    if(data.token === filterToken) {
                        if(typeof filterData?.is_active === 'undefined') {
                            skipVerification = true;
                        }
                    }
                }

                if(skipReview || skipVerification) {
                    continue;
                }

                // Skip send/receive toggles
                if (toggle.closest('.send-receive')) continue;

                if (filterData && !filterData.is_active) {
                    removeClassEl('active', toggle);
                } else {
                    addClassEl('active', toggle);
                }
            }
        },
        events: function () {
    const toggles = befriend.els.filters.querySelectorAll('.section-top .toggle, .filter-option .toggle');

    for (let toggle of toggles) {
        if (toggle._listener) continue;
        toggle._listener = true;

        toggle.addEventListener('click', async function (e) {
            e.preventDefault();
            e.stopPropagation();

            let filter_token;
            let section = this.closest('.section');
            let filter_option = this.closest('.filter-option');

            if (filter_option) {
                filter_token = befriend.filters.getFilterToken(filter_option);
            } else if (section) {
                filter_token = befriend.filters.sections[section.getAttribute('data-key')]?.token;
            }

            if (!filter_token) {
                console.error('Could not find filter token');
                return;
            }

            let active = !elHasClass(this, 'active');

            //toggle on/off label
            let toggle_label = filter_option?.querySelector('.toggle-label');

            if(toggle_label?.innerText) {
                toggle_label.innerHTML = active ? 'On' : 'Off';
            }

            try {
                if (active) {
                    addClassEl('active', this);
                } else {
                    removeClassEl('active', this);
                }

                await befriend.auth.put('/filters/active', {
                    filter_token,
                    active,
                });
            } catch (e) {
                console.error('Error updating filter active state:', e);

                // Revert UI state on error
                if (active) {
                    removeClassEl('active', this);
                } else {
                    addClassEl('active', this);
                }
            }
        });
    }
},
    },
    sendReceive: {
        data: {},
        init: function () {
            this.events();
            this.set();
        },
        set: function () {
            let filter_options = befriend.els.filters.getElementsByClassName('filter-option');

            for (let filter_option of filter_options) {
                let filter_token = befriend.filters.getFilterToken(filter_option);

                let filter_data = befriend.filters.data.filters?.[filter_token];

                if (!filter_data) {
                    continue;
                }

                // Set send/receive states
                let send_receive = filter_option.querySelector('.send-receive');

                //try to find send/receive on parent
                if(!send_receive) {
                    send_receive = filter_option.closest('.section').querySelector('.send-receive');
                }

                if (send_receive) {
                    let send_option = send_receive.querySelector('.option.send');
                    let receive_option = send_receive.querySelector('.option.receive');

                    // Set send state
                    if (send_option) {
                        if (!filter_data.is_send) {
                            removeClassEl('enabled', send_option);
                        }
                    }

                    // Set receive state
                    if (receive_option) {
                        if (!filter_data.is_receive) {
                            removeClassEl('enabled', receive_option);
                        }
                    }
                }
            }
        },
        events: function () {
            const sendReceiveElements = befriend.els.filters.querySelectorAll('.send-receive');

            for (let element of sendReceiveElements) {
                if (element._listener) continue;
                element._listener = true;

                const options = element.querySelectorAll('.option');

                for (let option of options) {
                    option.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();

                        // Toggle enabled class
                        this.classList.toggle('enabled');

                        // Get the filter type and option type
                        let filterToken;
                        let section = this.closest('.section');
                        let filter_option = this.closest('.filter-option');

                        if (filter_option) {
                            filterToken = befriend.filters.getFilterToken(filter_option);
                        } else if (section) {
                            filterToken = befriend.filters.sections[section.getAttribute('data-key')]?.token;
                        }

                        const optionType = this.classList.contains('send') ? 'send' : 'receive';

                        // Save the state
                        befriend.filters.sendReceive.save(
                            filterToken,
                            optionType,
                            elHasClass(this, 'enabled')
                        );
                    });
                }
            }
        },
        save: async function (filterToken, optionType, isEnabled) {
            if (!this.data.sendReceive) {
                this.data.sendReceive = {};
            }
            if (!this.data.sendReceive[filterToken]) {
                this.data.sendReceive[filterToken] = {};
            }

            // Save state
            this.data.sendReceive[filterToken][optionType] = isEnabled;

            try {
                await befriend.auth.put('/filters/send-receive', {
                    filter_token: filterToken,
                    type: optionType,
                    enabled: isEnabled,
                });
            } catch (e) {
                console.error('Error updating filter send/receive state:', e);
            }
        },
    },
    importance: {
        min: 0,
        max: 10,
        default: 7,
        values: {}, //per section
        init: function () {
            this.set();
        },
        getValue: function (section_key, token) {
            let section = befriend.filters.sections[section_key];
            let storedData = befriend.filters.data.filters?.[section.token];

            if(this.values[section_key] && token in this.values[section_key]) {
                return this.values[section_key][token];
            }

            if(!(section_key in this.values)) {
                this.values[section_key] = {};
            }

            let storedItem = Object.values(storedData?.items || {})
                .find(stored => stored.token === token);

            if(isNumeric(storedItem?.importance)) {
                this.values[section_key][token] = storedItem.importance;
                return storedItem.importance;
            }

            return section.importance?.default || this.default;
        },
        set: function () {
            //set existing data
            for(let k in befriend.filters.data.filters) {
                let filterData = befriend.filters.data.filters[k];

                if(!(k in this.values)) {
                    this.values[k] = {};
                }

                if(filterData.items) {
                    for(let id in filterData.items) {
                        let itemData = filterData.items[id];

                        if(typeof itemData.importance !== 'undefined') {
                            this.values[k][id] = itemData.importance;
                        }
                    }
                }
            }

            for(let key in befriend.filters.sections) {
                let section = befriend.filters.sections[key];

                if(!section?.importance?.active) {
                    continue;
                }

                let section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let items_container = section_el.querySelector('.items-container');

                if(!items_container) {
                    console.error("Need correct HTML structure", section.token);
                    continue;
                }

                let items_els = items_container.getElementsByClassName('item');

                for(let item of items_els) {
                    let item_token = item.getAttribute('data-token');

                    //skip any
                    if(item_token === 'any') {
                        continue;
                    }

                    let importance_el = item.querySelector('.importance');

                    if(!importance_el) {
                        let value = this.getValue(section.token, item_token);

                        let importance_html = this.getImportanceHtml(section.token, item_token, value);

                        item.insertAdjacentHTML('afterbegin', importance_html);
                    }
                }

                this.initForSection(section);
            }
        },
        initForSection: function(section) {
            if (!section.importance?.active) return;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const importance_els = section_el.querySelectorAll('.importance');

            for (let importance of importance_els) {
                if (importance._listener) continue;
                importance._listener = true;

                importance.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const item = importance.closest('.item');
                    const id = item.getAttribute('data-id');
                    const token = item.getAttribute('data-token');
                    const name = item.querySelector('.name')?.textContent;
                    const currentValue = befriend.filters.importance.getValue(section.token, token);

                    befriend.filters.importance.showImportancePopup(section.token, {
                        id, token
                    }, name, currentValue);
                });
            }
        },
        showImportancePopup: function(sectionToken, item, name, currentValue = 7) {
            const popupHtml = `
            <div class="importance-popup-overlay">
                <div class="importance-popup">
                    <div class="popup-header">
                        <div class="title">${name}</div>
                        <div class="sub">Filter Importance</div>
                    </div>
                    
                    <div class="importance-slider">
                        <div class="slider-container">
                            <div class="slider-track"></div>
                            <div class="slider-range"></div>
                            <div class="thumb">
                                <span class="thumb-value"></span>
                            </div>
                        </div>
                    </div>
                    <div class="popup-actions">
                        <button class="cancel-btn">Cancel</button>
                        <button class="save-btn">Save</button>
                    </div>
                </div>
            </div>`;

            const popupEl = document.createElement('div');
            popupEl.innerHTML = popupHtml;
            document.body.appendChild(popupEl);

            const overlay = popupEl.querySelector('.importance-popup-overlay');
            void overlay.offsetWidth;
            requestAnimationFrame(() => addClassEl('active', overlay));

            const container = popupEl.querySelector('.slider-container');
            const range = popupEl.querySelector('.slider-range');
            const thumb = popupEl.querySelector('.thumb');
            let isDragging = false;
            let startY, startTop;

            const setPosition = (value) => {
                const percent = (value - this.min) / (this.max - this.min);
                const height = container.offsetHeight;
                const position = height - (percent * height);
                thumb.style.top = `${position}px`;
                range.style.height = `${height - position}px`;
                thumb.querySelector('.thumb-value').textContent = Math.round(value);
            };

            const getValueFromPosition = (position) => {
                const height = container.offsetHeight;
                const percent = 1 - (position / height);
                return Math.min(Math.max(percent * (this.max - this.min) + this.min, this.min), this.max);
            };

            function handleStart(e) {
                isDragging = true;
                startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                startTop = parseFloat(thumb.style.top) || 0;
                e.preventDefault();
            }

            function handleMove(e) {
                if (!isDragging) return;
                const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                const dy = clientY - startY;
                const newTop = Math.min(Math.max(0, startTop + dy), container.offsetHeight);
                const value = getValueFromPosition(newTop);
                setPosition(value);
            }

            function handleEnd(e) {
                isDragging = false;
                let importancePopup = document.querySelector('.importance-popup-overlay');

                if(importancePopup && !e.target.closest('.importance-popup')) {
                    fireClick(importancePopup.querySelector('.cancel-btn'));
                }
            }

            // Mouse events
            thumb.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);

            // Touch events
            thumb.addEventListener('touchstart', handleStart);
            document.addEventListener('touchmove', handleMove);
            document.addEventListener('touchend', handleEnd);

            // Click track to set value
            container.addEventListener('click', (e) => {
                if (e.target === thumb) return;
                const rect = container.getBoundingClientRect();
                const clickPosition = e.clientY - rect.top;
                const value = getValueFromPosition(clickPosition);
                setPosition(value);
            });

            // Set initial position
            setPosition(currentValue);

            const closePopup = () => {
                removeClassEl('active', overlay);
                setTimeout(() => popupEl.remove(), 300);
            };

            const cancelBtn = popupEl.querySelector('.cancel-btn');
            const saveBtn = popupEl.querySelector('.save-btn');

            cancelBtn.addEventListener('click', closePopup);

            saveBtn.addEventListener('click', () => {
                const value = parseInt(thumb.querySelector('.thumb-value').textContent);

                if(!(sectionToken in this.values)) {
                    this.values[sectionToken] = {};
                }

                this.values[sectionToken][item.token] = value;
                befriend.filters.importance.updateIndicator(sectionToken, item.token, value);
                befriend.filters.importance.saveValue(sectionToken, item.id, value);
                closePopup();
            });

            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closePopup();
            });

            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') closePopup();
            });
        },
        updateIndicator: function(sectionToken, itemToken, value) {
            const item = befriend.els.filters
                .querySelector(`.section.${sectionToken}`)
                .querySelector(`[data-token="${itemToken}"]`);

            if (!item) return;

            const importance_el = item.querySelector('.importance');
            if (!importance_el) return;

            const indicator_el = importance_el.querySelector('.indicator');
            if (!indicator_el) return;

            const position = ((value - this.min) / (this.max - this.min)) * 100;

            importance_el.setAttribute('title', `Filter Importance: ${value}/${this.max}`);
            indicator_el.innerHTML = `
            <style>
                .section.${sectionToken} [data-token="${itemToken}"] .importance .indicator::after {
                    left: ${position}%;
                }
            </style>`;
        },
        saveValue: async function(sectionToken, itemId, value) {
            try {
                await befriend.auth.put('/filters/importance', {
                    section: sectionToken,
                    filter_item_id: parseInt(itemId),
                    importance: parseInt(value)
                });
            } catch (e) {
                console.error('Error saving importance:', e);
            }
        },
        getImportanceHtml: function(sectionToken, token, currentValue) {
            const position = ((currentValue - this.min) / (this.max - this.min)) * 100;
            return `
            <div class="importance" title="Filter Importance: ${currentValue}/${this.max}">
                <div class="indicator">
                    <style>
                        .section.${sectionToken} [data-token="${token}"] .importance .indicator::after {
                            left: ${position}%;
                        }
                    </style>
                </div>
            </div>`;
        }
    },
    availability: {
        data: {},
        days: [
            { index: 0, name: 'Sunday' },
            { index: 1, name: 'Monday' },
            { index: 2, name: 'Tuesday' },
            { index: 3, name: 'Wednesday' },
            { index: 4, name: 'Thursday' },
            { index: 5, name: 'Friday' },
            { index: 6, name: 'Saturday' }
        ],
        times: {
            default: {
                start: '09:00',
                end: '21:00'
            }
        },
        selectedDay: null,
        init: function() {
            const section = befriend.filters.sections.availability;
            const filter_data = befriend.filters.data.filters?.['availability'];

            if (filter_data?.items) {
                const availability = {};

                for (let [id, record] of Object.entries(filter_data.items)) {
                    const dayIndex = record.day_of_week;

                    if (!availability[dayIndex]) {
                        availability[dayIndex] = {
                            isDisabled: !record.is_active,
                            isAny: false,
                            times: {}
                        };
                    }

                    // Handle day-level record
                    if (record.is_day) {
                        availability[dayIndex].isDisabled = !record.is_active;
                        availability[dayIndex].isAny = record.is_any_time;
                    }
                    // Handle time-level records
                    else if (record.is_time) {
                        availability[dayIndex].times[id] = {
                            id: id,
                            start: record.start_time?.slice(0, 5), // Convert HH:mm:ss to HH:mm
                            end: record.end_time?.slice(0, 5)
                        };
                    }
                }

                this.data = availability;
            }

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            let daysHtml = this.days.map(day => `
            <div class="day-section" data-day-index="${day.index}">
                <div class="day-tab">
                    <div class="day-info">
                        <div class="day-name">
                            <div class="name">
                                ${day.name}
                            </div>
                        </div>
                        <div class="selected-container">
                            
                            <div class="selected-times"></div>
                        </div>
                    </div>
                    <div class="day-actions">
                        ${toggleHtml(true, null, 'toggle-24')}
                    </div>
                    <div class="chevron">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001"><path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/></svg>
                    </div>
                </div>
                <div class="time-slots-container">
                    <div class="wrapper">
                        <div class="time-slots"></div>
                        <div class="time-actions">
                            <button class="add-time-btn">
                                <div class="icon-name">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><g id="Ebene_1"><path d="M46.5,4h-4.5V1c0-.552-.447-1-1-1s-1,.448-1,1v3H10V1c0-.552-.448-1-1-1s-1,.448-1,1v3H3.5c-1.93,0-3.5,1.57-3.5,3.5v39c0,1.93,1.57,3.5,3.5,3.5h43c1.93,0,3.5-1.57,3.5-3.5V7.5c0-1.93-1.57-3.5-3.5-3.5ZM3.5,6h4.5v3c0,.552.448,1,1,1s1-.448,1-1v-3h30v3c0,.552.447,1,1,1s1-.448,1-1v-3h4.5c.827,0,1.5.673,1.5,1.5v6.5H2v-6.5c0-.827.673-1.5,1.5-1.5ZM46.5,48H3.5c-.827,0-1.5-.673-1.5-1.5v-30.5h46v30.5c0,.827-.673,1.5-1.5,1.5Z"/><path d="M33,30h-7v-7c0-.552-.448-1-1-1s-1,.448-1,1v7h-7c-.552,0-1,.447-1,1s.448,1,1,1h7v7c0,.553.448,1,1,1s1-.447,1-1v-7h7c.553,0,1-.447,1-1s-.447-1-1-1Z"/></g></svg>
                                    Add Time
                                </div>      
                            </button>
                            <button class="any-time-btn">
                                <div class="icon-name">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 450.536 463.816"><g id="Layer_25"><path d="M348.504,31.304v-10.288c0-11.592-9.432-21.016-21.016-21.016s-21.016,9.432-21.016,21.016v8.832h-64.688v-8.832c0-11.592-9.432-21.016-21.016-21.016s-21.016,9.432-21.016,21.016v8.832h-64.688v-8.832c0-11.592-9.432-21.016-21.016-21.016s-21.016,9.432-21.016,21.016v10.296C39.528,39.752,0,84.712,0,138.824v216.016c0,60.088,49.688,108.976,110.768,108.976h220c61.08,0,110.768-48.888,110.768-108.976v-216.016c0-54.112-39.528-99.072-93.032-107.52h0ZM322.472,21.016c0-2.768,2.248-5.016,5.016-5.016s5.016,2.248,5.016,5.016v33.04c0,2.768-2.248,5.016-5.016,5.016s-5.016-2.248-5.016-5.016V21.016ZM215.752,21.016c0-2.768,2.248-5.016,5.016-5.016s5.016,2.248,5.016,5.016v33.04c0,2.768-2.248,5.016-5.016,5.016s-5.016-2.248-5.016-5.016V21.016ZM109.032,21.016c0-2.768,2.248-5.016,5.016-5.016s5.016,2.248,5.016,5.016v33.04c0,2.768-2.248,5.016-5.016,5.016s-5.016-2.248-5.016-5.016V21.016ZM93.032,47.44v6.608c0,11.592,9.432,21.016,21.016,21.016s21.016-9.432,21.016-21.016v-8.2h64.688v8.208c0,11.592,9.432,21.016,21.016,21.016s21.016-9.432,21.016-21.016v-8.208h64.688v8.208c0,11.592,9.432,21.016,21.016,21.016s21.016-9.432,21.016-21.016v-6.616c43.832,8.08,76,44.976,76.936,89.4H16.096c.936-44.424,33.112-81.312,76.936-89.4ZM425.536,354.84c0,51.264-42.504,92.976-94.768,92.976H110.768c-52.256,0-94.768-41.712-94.768-92.976v-201.992h409.528v201.992h.008Z"/></g><path d="M111.3384,371.1272c-19.4207,0-32.2954-13.0932-32.2954-30.9862,0-15.9286,10.4741-29.2402,27.7126-32.2954l58.4811-12.2195c14.8385-2.8368,23.566-13.0918,23.566-26.8389,0-19.422-13.3102-32.9507-33.1677-32.9507h-67.8631v-17.4562h67.8631c30.1139,0,50.8437,20.7285,50.8437,50.8424,0,22.039-15.2747,38.6229-37.3144,42.7689l-57.608,11.3471c-8.9465,1.3092-14.8378,7.638-14.8378,16.3655,0,8.5104,6.1097,14.1839,15.7109,13.9655h93.3941v17.4575h-94.4849Z"/><path d="M345.0368,240.2009h17.4562v130.9263h-17.4562v-42.3334h-67.4276c-17.4562,0-29.2402-12.2195-29.2402-27.7126,0-3.2736.4368-6.7643,1.746-10.4735l25.9666-77.6833,16.8023,5.4558-26.6218,78.7734c-.4368,1.3092-.6539,2.8368-.6539,4.3644,0,6.1091,3.9275,9.8195,10.9103,9.8195h68.5183v-71.1367Z"/></svg>
                                    Any Time
                                </div>
                            </button>
                            <button class="copy-all-btn">
                                <div class="icon-name">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 420 419.0138"><path d="M366.0771,35.7422h-15.4895v-13.1703c0-12.4661-8.4905-22.5719-18.9641-22.5719s-18.9641,10.1058-18.9641,22.5719v13.1703H97.3406v-13.1703C97.3391,10.1058,88.8474.0014,78.3738.0031c-10.4715.0017-18.96,10.1051-18.9615,22.5688v13.1703h-15.4895C19.6763,35.7748.0274,59.1618,0,88.0211v278.7138c.0274,28.8593,19.6763,52.2463,43.9229,52.2789h322.1543c24.2466-.0325,43.8955-23.4196,43.9229-52.2789V88.0211c-.0274-28.8593-19.6763-52.2463-43.9229-52.2789ZM323.8704,22.5719c0-5.0966,3.4712-9.2282,7.7532-9.2282s7.7532,4.1316,7.7532,9.2282v39.6862c0,5.0966-3.4712,9.2282-7.7532,9.2282s-7.7532-4.1316-7.7532-9.2282h0V22.5719ZM70.6233,22.5719c.0019-5.0966,3.4746-9.2263,7.7566-9.2241,4.2793.0023,7.7478,4.1307,7.7497,9.2241v39.6862c-.0019,5.0966-3.4746,9.2263-7.7566,9.2241-4.2793-.0023-7.7478-4.1307-7.7497-9.2241V22.5719ZM366.0771,405.67H43.9229c-18.0571-.0263-32.6899-17.4428-32.7119-38.9352v-222.6319h387.5781v222.6319c-.0221,21.4924-14.6548,38.9089-32.7119,38.9352ZM398.7891,130.7592H11.2109v-42.7381c.0221-21.4924,14.6548-38.9089,32.7119-38.9352h15.4895v13.1722c.0014,12.4661,8.4931,22.5705,18.9667,22.5688,10.4715-.0017,18.96-10.1051,18.9615-22.5688v-13.1722h215.3189v13.1722c0,12.4661,8.4905,22.5719,18.9641,22.5719s18.9641-10.1058,18.9641-22.5719v-13.1722h15.4895c18.0571.0263,32.6899,17.4428,32.7119,38.9352v42.7381Z"/><path d="M233.802,209.6609h-93.2674c-8.7515,0-15.8596,7.108-15.8596,15.8596v133.8203c0,8.7515,7.108,15.8596,15.8596,15.8596h93.2674c8.7515,0,15.8596-7.108,15.8596-15.8596v-133.8203c-.0411-8.7515-7.1491-15.8596-15.8596-15.8596ZM238.527,359.2997c0,2.6296-2.1365,4.7661-4.7661,4.7661h-93.2674c-2.6296,0-4.7661-2.1365-4.7661-4.7661v-133.7792c0-2.6296,2.1365-4.7661,4.7661-4.7661h93.2674c2.6296,0,4.7661,2.1365,4.7661,4.7661v133.7792Z"/><path d="M269.4655,174.5726h-93.2674c-8.7515,0-15.8596,7.108-15.8596,15.8596,0,3.0815,2.4652,5.5467,5.5467,5.5467s5.5467-2.4652,5.5467-5.5467c0-2.6296,2.1365-4.7661,4.7661-4.7661h93.2674c2.6296,0,4.7661,2.1365,4.7661,4.7661v133.8203c0,2.6296-2.1365,4.7661-4.7661,4.7661-3.0815,0-5.5467,2.4652-5.5467,5.5467s2.4652,5.5467,5.5467,5.5467c8.7515,0,15.8596-7.108,15.8596-15.8596v-133.8203c0-8.7515-7.108-15.8596-15.8596-15.8596Z"/></svg>
                                    Copy
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `).join('');

            filter_options.innerHTML = `
            <div class="filter-option" data-filter-token="${section.token}">
                <div class="days-container">
                    ${daysHtml}
                </div>
            </div>
        `;

            this.initEvents(section_el);
            this.setData();
        },
        initEvents: function(section_el) {
            // Day tab click handler
            const dayTabs = section_el.querySelectorAll('.day-tab');
            for (const tab of dayTabs) {
                if (tab._listener) continue;
                tab._listener = true;

                tab.addEventListener('click', (e) => {
                    // Don't handle click if clicking toggle or if day is disabled
                    if (e.target.closest('.toggle')) return;

                    const daySection = tab.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');

                    if (this.selectedDay === dayIndex) {
                        this.closeTimeSlots(daySection);
                        this.selectedDay = null;
                    } else {
                        if (this.selectedDay !== null) {
                            const prevSection = section_el.querySelector(`.day-section[data-day-index="${this.selectedDay}"]`);
                            this.closeTimeSlots(prevSection);
                        }
                        this.openTimeSlots(daySection, 0, true);
                        this.selectedDay = dayIndex;
                    }
                });
            }

            // Initialize toggle handlers
            const toggles = section_el.querySelectorAll('.day-tab .toggle');
            for (const toggle of toggles) {
                if (toggle._listener) continue;
                toggle._listener = true;

                toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const daySection = toggle.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');
                    const isActive = toggle.classList.contains('active');

                    this.toggleDayAvailability(dayIndex, !isActive);
                });
            }

            this.initTimeButtons(section_el);
        },
        initTimeButtons: function(section_el) {
            // Add time button handler
            const addTimeBtns = section_el.querySelectorAll('.add-time-btn');
            for (const btn of addTimeBtns) {
                if (btn._listener) continue;
                btn._listener = true;

                btn.addEventListener('click', () => {
                    const daySection = btn.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');
                    this.showTimePickerPopup(dayIndex);
                });
            }

            // Any time button handler
            const anyTimeBtns = section_el.querySelectorAll('.any-time-btn');
            for (const btn of anyTimeBtns) {
                if (btn._listener) continue;
                btn._listener = true;

                btn.addEventListener('click', () => {
                    const daySection = btn.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');
                    this.setAnyTime(dayIndex);
                });
            }

            // Copy to all days button handler
            const copyBtns = section_el.querySelectorAll('.copy-all-btn');
            for (const btn of copyBtns) {
                if (btn._listener) continue;
                btn._listener = true;

                btn.addEventListener('click', () => {
                    const daySection = btn.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');
                    this.copyToAllDays(dayIndex);
                });
            }
        },
        getDaySection: function(dayIndex) {
            return befriend.els.filters.querySelector(`.day-section[data-day-index="${dayIndex}"]`);
        },
        toggleDayAvailability: function(dayIndex, isAvailable) {
            const daySection = this.getDaySection(dayIndex);
            if (!daySection) return;

            const toggle = daySection.querySelector('.toggle');
            const selectedTimesEl = daySection.querySelector('.selected-times');

            const currentData = this.data[dayIndex] || {
                isDisabled: true,
                isAny: false,
                times: {}
            };

            if (isAvailable) {
                addClassEl('active', toggle);

                // Initialize or update data for this day
                this.data[dayIndex] = {
                    isDisabled: false,
                    isAny: currentData.isAny,
                    times: currentData.times || {} // Preserve existing times
                };

                // Check if we have stored filter data
                const filter_data = befriend.filters.data.filters?.['availability'];
                if (filter_data?.items) {
                    const dayRecord = Object.values(filter_data.items).find(
                        record => record.day_of_week === parseInt(dayIndex) && record.is_day
                    );

                    // If we have a day record and it was set to any time, restore that state
                    if (dayRecord?.is_any_time) {
                        this.data[dayIndex].isAny = true;
                        this.data[dayIndex].times = {}; // Clear times when setting to any time
                    }
                }
            } else {
                removeClassEl('active', toggle);

                // Update the data but preserve the times and isAny state
                this.data[dayIndex] = {
                    ...currentData,
                    isDisabled: true
                };

                selectedTimesEl.innerHTML = '<span class="not-available">Not Available</span>';
            }

            // Update the UI without affecting the time slots container state
            this.updateDayTimesDisplay(dayIndex);
            this.updateDayUI(dayIndex);
            this.saveData();
        },
        setAnyTime: function(dayIndex) {
            const daySection = this.getDaySection(dayIndex);
            if (!daySection) return;

            // Clear existing times and set isAny
            this.data[dayIndex] = {
                isAny: true,
                times: {},
                isDisabled: false  // Ensure day is enabled when setting any time
            };

            // Update UI state
            const toggle = daySection.querySelector('.toggle');
            addClassEl('active', toggle);

            // Remove has-slots class since we're clearing times
            const timeSlotsContainer = daySection.querySelector('.time-slots-container');
            removeClassEl('has-slots', timeSlotsContainer);

            // Keep time slots container open if it was open
            if (this.selectedDay === dayIndex) {
                const timeSlots = daySection.querySelector('.time-slots');
                let timeSlotEls = timeSlots.getElementsByClassName('time-slot');
                let timeSlotCount = timeSlotEls?.length || 0;
                let timeSlotHeight = timeSlotEls?.[0]?.offsetHeight || 0;

                timeSlots.innerHTML = ''; // Clear existing time slots

                requestAnimationFrame(() => {
                    this.openTimeSlots(daySection, timeSlotCount * (timeSlotHeight + befriend.variables.filters_time_slot_gap));
                });
            }

            this.updateDayTimesDisplay(dayIndex);
            this.updateDayUI(dayIndex);
            this.saveData();
        },
        async copyToAllDays(sourceDayIndex) {
            const sourceData = this.data[sourceDayIndex];
            if (!sourceData) return;

            // Calculate the height of time slots for UI updates
            const sourceSection = this.getDaySection(sourceDayIndex);
            const timeSlots = sourceSection.querySelectorAll('.time-slot');
            const totalGap = (timeSlots.length - 1) * befriend.variables.filters_time_slot_gap;
            const totalHeight = Array.from(timeSlots).reduce((sum, slot) => sum + slot.offsetHeight, 0) + totalGap;

            for (const day of this.days) {
                if (day.index.toString() !== sourceDayIndex) {
                    // Deep copy the source data and explicitly set isAny to false
                    const copiedData = {
                        ...sourceData,
                        times: {},
                        isAny: sourceData.isAny
                    };

                    // Generate new IDs for each time slot
                    if (sourceData.times) {
                        for(let k in sourceData.times) {
                            let timeSlot = sourceData.times[k];
                            const newTimeId = 'time_' + Math.random().toString(36).substr(2, 9);
                            copiedData.times[newTimeId] = {
                                ...timeSlot
                            };
                            delete copiedData.times[newTimeId].id;
                        }
                    }

                    this.data[day.index] = copiedData;

                    const daySection = this.getDaySection(day.index);
                    if (!daySection) continue;

                    // Update toggle state
                    const toggle = daySection.querySelector('.toggle');
                    if (sourceData.isDisabled) {
                        removeClassEl('active', toggle);
                    } else {
                        addClassEl('active', toggle);
                    }

                    // Update UI
                    this.updateDayUI(day.index);
                    this.updateDayTimesDisplay(day.index);

                    // Update container classes based on new state
                    const timeSlotsContainer = daySection.querySelector('.time-slots-container');
                    if (Object.keys(copiedData.times).length > 0) {
                        addClassEl('has-slots', timeSlotsContainer);
                    } else {
                        removeClassEl('has-slots', timeSlotsContainer);
                    }

                    // If this day is currently selected, update its height
                    if (this.selectedDay === day.index.toString()) {
                        timeSlotsContainer.style.height = `${totalHeight + 40}px`; // Add padding
                    }
                }
            }

            // Save data immediately after copying
            await this.saveData();
        },
        showTimePickerPopup: function(dayIndex, existingTimeId = null) {
            const existingTime = existingTimeId ? this.data[dayIndex]?.times?.[existingTimeId] : null;
            const dayData = this.data[dayIndex];

            // Set default times without using lastTimes
            let defaultStart = this.times.default.start;
            let defaultEnd = this.times.default.end;

            let popupHtml = `
    <div class="availability-time-picker-popup">
        <div class="popup-header">${existingTime ? 'Edit Time' : 'Add Time'}</div>
        <div class="time-inputs">
            <div class="time-input">
                <label>Start Time</label>
                <input type="time" class="start-time" value="${existingTime?.start || defaultStart}">
            </div>
            <div class="time-input">
                <label>End Time</label>
                <input type="time" class="end-time" value="${existingTime?.end || defaultEnd}">
            </div>
        </div>
        <div class="popup-actions">
            <button class="cancel-btn">Cancel</button>
            <button class="save-btn">Save</button>
        </div>
    </div>
    `;

            const popupEl = document.createElement('div');
            addClassEl('availability-popup-overlay', popupEl);
            popupEl.innerHTML = popupHtml;
            document.body.appendChild(popupEl);

            const cancelBtn = popupEl.querySelector('.cancel-btn');
            const saveBtn = popupEl.querySelector('.save-btn');

            cancelBtn.addEventListener('click', () => {
                popupEl.remove();
            });

            saveBtn.addEventListener('click', () => {
                const startTime = popupEl.querySelector('.start-time').value;
                const endTime = popupEl.querySelector('.end-time').value;

                // Normalize and compare times
                const { normalizedStart, normalizedEnd } = this.normalizeTimeRange(startTime, endTime);

                if (!this.data[dayIndex]) {
                    this.data[dayIndex] = { times: {} };
                }

                // Handle overlapping times
                const newTime = { start: normalizedStart, end: normalizedEnd };
                const existingTimes = Object.values(this.data[dayIndex].times || {});
                const allTimes = [...existingTimes, newTime];
                const mergedTimes = this.mergeOverlappingTimes(allTimes);

                // Clear existing times and add merged times
                this.data[dayIndex].times = {};
                this.data[dayIndex].isAny = false;

                mergedTimes.forEach(time => {
                    const timeId = existingTimeId || this.generateTimeId();
                    this.data[dayIndex].times[timeId] = time;
                });

                this.updateDayUI(dayIndex);
                this.updateDayTimesDisplay(dayIndex);

                this.saveData();
                popupEl.remove();

                let daySection = this.getDaySection(dayIndex);

                addClassEl('has-slots', daySection.querySelector('.time-slots-container'));

                void daySection;

                this.openTimeSlots(daySection);
            });
        },
        normalizeTimeRange: function(startTime, endTime) {
            // Convert times to minutes since midnight for comparison
            const startMinutes = this.timeToMinutes(startTime);
            const endMinutes = this.timeToMinutes(endTime);

            // If end time is earlier than start time, swap them
            if (endMinutes < startMinutes) {
                return {
                    normalizedStart: endTime,
                    normalizedEnd: startTime
                };
            }

            return {
                normalizedStart: startTime,
                normalizedEnd: endTime
            };
        },
        timeToMinutes: function(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        },
        updateDayTimesDisplay: function(dayIndex) {
            const daySection = this.getDaySection(dayIndex);
            if (!daySection) return;

            const selectedTimesEl = daySection.querySelector('.selected-times');
            const dayData = this.data[dayIndex];
            const toggle = daySection.querySelector('.toggle');
            const isActive = toggle && elHasClass(toggle, 'active');

            // If toggle is off, always show "Not Available" regardless of other states
            if (!isActive) {
                selectedTimesEl.innerHTML = '<span class="not-available">Not Available</span>';
                return;
            }

            if (!dayData || (!dayData.times && !dayData.isAny)) {
                selectedTimesEl.innerHTML = '<span class="no-times">No times set</span>';
                return;
            }

            if (dayData.isAny) {
                selectedTimesEl.innerHTML = '<span class="any-time">Any Time</span>';
                return;
            }

            const timeSlots = Object.values(dayData.times || {});
            if (timeSlots.length === 0) {
                selectedTimesEl.innerHTML = '<span class="no-times">No times set</span>';
                return;
            }

            const timeStrings = timeSlots
                .sort((a, b) => a.start.localeCompare(b.start))
                .map(time => `<div class="selected-time">${this.formatTimeDisplay(time.start)} - ${this.formatTimeDisplay(time.end)}</div>`);

            selectedTimesEl.innerHTML = timeStrings.join('');
        },
        updateDayUI: function(dayIndex) {
            const daySection = this.getDaySection(dayIndex);
            const timeSlotsEl = daySection.querySelector('.time-slots');
            const timeSlotsContainer = daySection.querySelector('.time-slots-container');
            const dayData = this.data[dayIndex];

            // Clear existing time slots
            timeSlotsEl.innerHTML = '';

            // Handle "Any Time" case
            if (dayData?.isAny) {
                removeClassEl('has-slots', timeSlotsContainer);
                return;
            }

            // Handle regular time slots
            if (dayData?.times && Object.keys(dayData.times).length > 0) {
                addClassEl('has-slots', timeSlotsContainer);

                const sortedTimes = Object.entries(dayData.times)
                    .sort(([,a], [,b]) => a.start.localeCompare(b.start));

                const timeSlotsHtml = sortedTimes.map(([timeId, time]) => `
                <div class="time-slot" data-time-id="${timeId}">
                    <div class="time-range">${this.formatTimeDisplay(time.start)} - ${this.formatTimeDisplay(time.end)}</div>
                    <button class="delete-btn" title="Delete">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 355.8033 427.0013"><path d="M232.4016,154.7044c-5.5234,0-10,4.4766-10,10v189c0,5.5195,4.4766,10,10,10s10-4.4805,10-10v-189c0-5.5234-4.4766-10-10-10Z"/><path d="M114.4016,154.7044c-5.5234,0-10,4.4766-10,10v189c0,5.5195,4.4766,10,10,10s10-4.4805,10-10v-189c0-5.5234-4.4766-10-10-10Z"/><path d="M28.4016,127.1224v246.3789c0,14.5625,5.3398,28.2383,14.668,38.0508,9.2852,9.8398,22.207,15.4258,35.7305,15.4492h189.2031c13.5273-.0234,26.4492-5.6094,35.7305-15.4492,9.3281-9.8125,14.668-23.4883,14.668-38.0508V127.1224c18.543-4.9219,30.5586-22.8359,28.0781-41.8633-2.4844-19.0234-18.6914-33.2539-37.8789-33.2578h-51.1992v-12.5c.0586-10.5117-4.0977-20.6055-11.5391-28.0312C238.4212,4.0482,228.3118-.0846,217.8001.0013h-88.7969c-10.5117-.0859-20.6211,4.0469-28.0625,11.4688-7.4414,7.4258-11.5977,17.5195-11.5391,28.0312v12.5h-51.1992c-19.1875.0039-35.3945,14.2344-37.8789,33.2578-2.4805,19.0273,9.5352,36.9414,28.0781,41.8633ZM268.0032,407.0013H78.8001c-17.0977,0-30.3984-14.6875-30.3984-33.5v-245.5h250v245.5c0,18.8125-13.3008,33.5-30.3984,33.5ZM109.4016,39.5013c-.0664-5.207,1.9805-10.2188,5.6758-13.8945,3.6914-3.6758,8.7148-5.6953,13.9258-5.6055h88.7969c5.2109-.0898,10.2344,1.9297,13.9258,5.6055,3.6953,3.6719,5.7422,8.6875,5.6758,13.8945v12.5H109.4016v-12.5ZM38.2024,72.0013h270.3984c9.9414,0,18,8.0586,18,18s-8.0586,18-18,18H38.2024c-9.9414,0-18-8.0586-18-18s8.0586-18,18-18Z"/><path d="M173.4016,154.7044c-5.5234,0-10,4.4766-10,10v189c0,5.5195,4.4766,10,10,10s10-4.4805,10-10v-189c0-5.5234-4.4766-10-10-10Z"/></svg>
                    </button>
                </div>
            `).join('');

                timeSlotsEl.innerHTML = timeSlotsHtml;

                // Add delete handlers
                const deleteButtons = timeSlotsEl.querySelectorAll('.delete-btn');
                for (const btn of deleteButtons) {
                    if (btn._listener) continue;
                    btn._listener = true;

                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const timeSlot = btn.closest('.time-slot');
                        const timeId = timeSlot.getAttribute('data-time-id');
                        const timeSlotHeight = timeSlot.offsetHeight;

                        this.deleteTimeSlot(dayIndex, timeId);
                        timeSlot.remove();

                        requestAnimationFrame(() => {
                            this.openTimeSlots(daySection, timeSlotHeight + befriend.variables.filters_time_slot_gap);
                        });
                    });
                }
            } else {
                removeClassEl('has-slots', timeSlotsContainer);
            }
        },
        formatTimeDisplay: function(time) {
            const [hours, minutes] = time.split(':');
            const hr = parseInt(hours);
            const ampm = hr >= 12 ? 'pm' : 'am';
            const hr12 = hr % 12 || 12;
            return `${hr12}:${minutes} ${ampm}`;
        },
        deleteTimeSlot: function(dayIndex, timeId) {
            if (this.data[dayIndex]?.times?.[timeId]) {
                let daySection = this.getDaySection(dayIndex);
                let timeSlotsContainer = daySection.querySelector('.time-slots-container');

                delete this.data[dayIndex].times[timeId];

                if (Object.keys(this.data[dayIndex].times).length === 0) {
                    delete this.data[dayIndex];
                    removeClassEl('has-slots', timeSlotsContainer);
                }
                this.updateDayUI(dayIndex);
                this.updateDayTimesDisplay(dayIndex);
                this.saveData();
            }
        },
        generateTimeId: function() {
            return 'time_' + Math.random().toString(36).substr(2, 9);
        },
        doTimesOverlap: function(time1Start, time1End, time2Start, time2End) {
            const t1s = new Date(`2000/01/01 ${time1Start}`);
            const t1e = new Date(`2000/01/01 ${time1End}`);
            const t2s = new Date(`2000/01/01 ${time2Start}`);
            const t2e = new Date(`2000/01/01 ${time2End}`);

            return t1s < t2e && t2s < t1e;
        },
        mergeOverlappingTimes: function(times) {
            if (!times || times.length === 0) return [];

            // Sort times by start time
            const sortedTimes = times.sort((a, b) => a.start.localeCompare(b.start));
            const merged = [sortedTimes[0]];

            for (let i = 1; i < sortedTimes.length; i++) {
                const current = sortedTimes[i];
                const last = merged[merged.length - 1];

                if (this.doTimesOverlap(last.start, last.end, current.start, current.end)) {
                    // Merge the times
                    last.end = current.end > last.end ? current.end : last.end;
                } else {
                    merged.push(current);
                }
            }

            return merged;
        },
        openTimeSlots: async function(daySection, minusPixels = 0, autoScrollIfNotVisible) {
            const container = daySection.querySelector('.time-slots-container');
            addClassEl('selected', daySection);

            let setHeight = container.scrollHeight - minusPixels;
            container.style.height = `${setHeight}px`;

            if(autoScrollIfNotVisible) {
                await timeoutAwait(300)

                const filterSection = befriend.els.filters
                    .querySelector('.section.availability')
                    .querySelector('.filter-option');

                const dayRect = daySection.getBoundingClientRect();
                const filterRect = filterSection.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();

                // Calculate vertical positions relative to the viewport
                const dayBottom = dayRect.bottom;
                const filterBottom = filterRect.bottom;

                // Check if the day section is below the filter section
                if (dayBottom > filterBottom) {
                    // Calculate the scroll amount needed
                    const scrollAmount = dayBottom - filterBottom + 10;

                    // Scroll the container, not the filter section
                    filterSection.scrollBy({
                        top: scrollAmount,
                        behavior: 'smooth'
                    });
                }
            }
        },
        closeTimeSlots: function(daySection) {
            if (!daySection) return;
            const container = daySection.querySelector('.time-slots-container');
            removeClassEl('selected', daySection);
            container.style.height = '0';
        },
        setData() {
            try {
                const filter_data = befriend.filters.data.filters?.['availability'];

                // Initialize toggles and displays for each day
                for (const day of this.days) {
                    const daySection = this.getDaySection(day.index);
                    if (!daySection) continue;

                    const toggle = daySection.querySelector('.toggle');
                    const timeSlotsContainer = daySection.querySelector('.time-slots-container');

                    // Set initial toggle state and container display
                    const dayRecords = Object.values(filter_data?.items || {}).filter(
                        record => record.day_of_week === day.index
                    );

                    // Find the day-level record
                    const dayLevelRecord = dayRecords.find(record => record.is_day);

                    if (dayLevelRecord) {
                        // Initialize day data structure
                        this.data[day.index] = {
                            isDisabled: !dayLevelRecord.is_active,
                            isAny: dayLevelRecord.is_any_time,
                            times: {}
                        };

                        // Process time slots only if not "Any Time"
                        if (!dayLevelRecord.is_any_time) {
                            const timeRecords = dayRecords.filter(record => !record.is_day);
                            for(let record of timeRecords) {
                                const timeId = record.id;
                                this.data[day.index].times[timeId] = {
                                    start: record.start_time?.slice(0, 5),
                                    end: record.end_time?.slice(0, 5)
                                };
                            }
                        }

                        if (dayLevelRecord.is_active) {
                            addClassEl('active', toggle);
                        } else {
                            removeClassEl('active', toggle);
                        }
                    } else {
                        // Default to active if no day record exists
                        addClassEl('active', toggle);
                        timeSlotsContainer.style.display = '';
                        this.data[day.index] = {
                            isDisabled: false,
                            isAny: false,
                            times: {}
                        };
                    }

                    this.updateDayUI(day.index);
                    this.updateDayTimesDisplay(day.index);
                }
            } catch (e) {
                console.error('Error loading availability data:', e);
            }
        },
        updateIds: function(idMapping) {
            for (let dayIndex in this.data) {
                const dayData = this.data[dayIndex];

                if (dayData.times) {
                    const updatedTimes = {};
                    for (let [oldId, timeSlot] of Object.entries(dayData.times)) {
                        const newId = idMapping[oldId] || oldId;
                        updatedTimes[newId] = {
                            ...timeSlot,
                            id: newId
                        };

                        const timeSlotEl = befriend.els.filters.querySelector(`[data-time-id="${oldId}"]`);
                        if (timeSlotEl) {
                            timeSlotEl.setAttribute('data-time-id', newId);
                        }
                    }

                    dayData.times = updatedTimes;
                }
            }
        },
        async saveData() {
            try {
                const availabilityData = {};
                for (const [dayIndex, dayData] of Object.entries(this.data)) {
                    availabilityData[dayIndex] = {
                        isDisabled: dayData.isDisabled || false,
                        isAny: dayData.isAny || false,
                        times: dayData.times || {}
                    };
                }

                let response = await befriend.auth.put('/filters/availability', {
                    availability: availabilityData
                });

                if (response?.data?.idMapping) {
                    this.updateIds(response.data.idMapping);
                }
            } catch (e) {
                console.error('Error saving availability data:', e);
            }
        }
    },
    modes: {
        items: [
            {
                id: 'solo',
                label: 'Solo',
                icon: `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 432.1641 512">
                  <path d="M210.3516,246.6328c33.8828,0,63.2188-12.1523,87.1953-36.1289,23.9688-23.9727,36.125-53.3047,36.125-87.1914s-12.1523-63.2109-36.1289-87.1914C273.5664,12.1523,244.2305,0,210.3516,0s-63.2188,12.1523-87.1914,36.125-36.1289,53.3086-36.1289,87.1875,12.1562,63.2227,36.1289,87.1953c23.9805,23.9688,53.3164,36.125,87.1914,36.125ZM144.3789,57.3398c18.3945-18.3945,39.9727-27.3359,65.9727-27.3359s47.5781,8.9414,65.9766,27.3359c18.3945,18.3984,27.3398,39.9805,27.3398,65.9727s-8.9453,47.5781-27.3398,65.9766c-18.3984,18.3984-39.9805,27.3398-65.9766,27.3398s-47.5703-8.9453-65.9727-27.3398c-18.3984-18.3945-27.3438-39.9766-27.3438-65.9766s8.9453-47.5742,27.3438-65.9727Z" fill="black"/>
                  <circle cx="210.3516" cy="123.3125" r="66" fill="white"/>
                  
                  <path d="M426.1289,393.7031c-.6914-9.9766-2.0898-20.8594-4.1484-32.3516-2.0781-11.5781-4.7539-22.5234-7.957-32.5273-3.3125-10.3398-7.8086-20.5508-13.375-30.3359-5.7695-10.1562-12.5508-19-20.1602-26.2773-7.957-7.6133-17.6992-13.7344-28.9648-18.1992-11.2266-4.4414-23.668-6.6914-36.9766-6.6914-5.2266,0-10.2812,2.1445-20.043,8.5-6.0078,3.918-13.0352,8.4492-20.8789,13.4609-6.707,4.2734-15.793,8.2773-27.0156,11.9023-10.9492,3.543-22.0664,5.3398-33.043,5.3398-10.9688,0-22.0859-1.7969-33.043-5.3398-11.2109-3.6211-20.3008-7.625-26.9961-11.8984-7.7695-4.9648-14.8008-9.4961-20.8984-13.4688-9.7539-6.3555-14.8086-8.5-20.0352-8.5-13.3125,0-25.75,2.2539-36.9727,6.6992-11.2578,4.457-21.0039,10.5781-28.9688,18.1992-7.6094,7.2812-14.3906,16.1211-20.1562,26.2734-5.5586,9.7852-10.0586,19.9922-13.3711,30.3398-3.1992,10.0039-5.875,20.9453-7.9531,32.5234-2.0625,11.4766-3.457,22.3633-4.1484,32.3633-.6797,9.7773-1.0234,19.9531-1.0234,30.2344,0,26.7266,8.4961,48.3633,25.25,64.3203,16.5469,15.7461,38.4375,23.7305,65.0664,23.7305h246.5312c26.6211,0,48.5117-7.9844,65.0625-23.7305,16.7578-15.9453,25.2539-37.5898,25.2539-64.3242-.0039-10.3164-.3516-20.4922-1.0352-30.2422Z" fill="black"/>
                  <path d="M381.2227,466.5312c-10.9336,10.4062-25.4492,15.4648-44.3789,15.4648H90.3164c-18.9336,0-33.4492-5.0586-44.3789-15.4609-10.7227-10.207-15.9336-24.1406-15.9336-42.5859,0-9.5938.3164-19.0664.9492-28.1602.6172-8.9219,1.8789-18.7227,3.75-29.1367,1.8477-10.2852,4.1992-19.9375,6.9961-28.6758,2.6836-8.3789,6.3438-16.6758,10.8828-24.668,4.332-7.6172,9.3164-14.1523,14.8164-19.418,5.1445-4.9258,11.6289-8.957,19.2695-11.9805,7.0664-2.7969,15.0078-4.3281,23.6289-4.5586,1.0508.5586,2.9219,1.625,5.9531,3.6016,6.168,4.0195,13.2773,8.6055,21.1367,13.625,8.8594,5.6484,20.2734,10.75,33.9102,15.1523,13.9414,4.5078,28.1602,6.7969,42.2734,6.7969s28.3359-2.2891,42.2695-6.793c13.6484-4.4102,25.0586-9.5078,33.9297-15.1641,8.043-5.1406,14.9531-9.5938,21.1211-13.6172,3.0312-1.9727,4.9023-3.043,5.9531-3.6016,8.625.2305,16.5664,1.7617,23.6367,4.5586,7.6367,3.0234,14.1211,7.0586,19.2656,11.9805,5.5,5.2617,10.4844,11.7969,14.8164,19.4219,4.543,7.9883,8.207,16.2891,10.8867,24.6602,2.8008,8.75,5.1562,18.3984,7,28.6758,1.8672,10.4336,3.1328,20.2383,3.75,29.1445v.0078c.6367,9.0586.957,18.5273.9609,28.1484-.0039,18.4492-5.2148,32.3789-15.9375,42.582Z" fill="white"/>
                </svg>`
            },
            {
                id: 'partner',
                label: 'Partner',
                icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 520 356.198">
                          <path d="M133,184c-50.8102,0-92-41.1898-92-92S82.1898,0,133,0s92,41.1898,92,92c-.0584,50.786-41.214,91.9416-92,92ZM133,20c-39.7645,0-72,32.2355-72,72s32.2355,72,72,72,72-32.2355,72-72c-.0441-39.7462-32.2538-71.9559-72-72Z" fill="black"/>
                          <circle cx="133" cy="92" r="72" fill="white"/>
                          
                          <path d="M256,356.198H10C4.4772,356.198,0,351.7209,0,346.198v-49.2c0-73.4539,59.5461-133,133-133s133,59.5461,133,133v49.2c0,5.5229-4.4771,10-10,10ZM20,336.198h226v-39.2c0-62.4082-50.5918-113-113-113s-113,50.5918-113,113v39.2Z" fill="black"/>
                          <path d="M20,336.198h226v-39.2c0-62.4082-50.5918-113-113-113s-113,50.5918-113,113v39.2Z" fill="white"/>
                          
                          <path d="M379,184c-50.8102,0-92-41.1898-92-92S328.1898,0,379,0s92,41.1898,92,92c-.0584,50.786-41.214,91.9416-92,92ZM379,20c-39.7645,0-72,32.2355-72,72s32.2355,72,72,72,72-32.2355,72-72c-.0441-39.7462-32.2538-71.9559-72-72Z" fill="black"/>
                          <circle cx="379" cy="92" r="72" fill="white"/>
                          
                          <path d="M502,356.198h-246c-5.5228,0-10-4.4771-10-10v-49.2c0-73.4539,59.5461-133,133-133s133,59.5461,133,133v49.2c0,5.5229-4.4771,10-10,10ZM266,336.198h226v-39.2c0-62.4082-50.5918-113-113-113s-113,50.5918-113,113v39.2Z" fill="black"/>
                          <path d="M266,336.198h226v-39.2c0-62.4082-50.5918-113-113-113s-113,50.5918-113,113v39.2Z" fill="white"/>
                        </svg>`
            },
            {
                id: 'kids',
                label: 'Kids',
                icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1730.5023 1807.73">
                          <circle cx="663.44" cy="391.73" r="177.07" fill="white" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          <path d="M786.63,691.99h-330.04c-80.47,0-145.71,65.24-145.71,145.71v314.7499c0,60.34,48.92,109.26,109.26,109.26h50.16v445.97c0,42.83,34.72,77.55,77.55,77.55h888.31c42.83,0,77.55-34.72,77.55-77.55v-245.8" fill="white" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          
                          <path d="M663.44,1785.22v-392.64" fill="none" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          <path d="M470.29,1261.7v-369.54" fill="none" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          
                          <circle cx="1340.9399" cy="453.32" r="153.98" fill="white" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          <path d="M1248.5601,738.18h247.64c71.17,0,132.72,49.57,147.89,119.1l42.24,193.61c13.41,61.4399-24.9399,122.28-86.16,136.6801l-20.5699,4.84" fill="white" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          <path d="M1510.3199,922.95l107.09,535.43c.36,1.8101-1.02,3.49-2.86,3.49h-436.41" fill="white" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          
                          <circle cx="1009.89" cy="684.29" r="115.48" fill="white" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          <path d="M863.61,1107.72l4.76,677.5" fill="none" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          <path d="M1178.13,1785.22v-677.5" fill="none" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          <path d="M863.61,1336.65h-32.61c-52.15,0-94.42-42.28-94.42-94.42v-165.53c0-84.91,68.84-153.75,153.75-153.75h258.3699c84.91,0,153.75,68.84,153.75,153.75v165.53c0,52.15-42.28,94.42-94.42,94.42h-32.61" fill="white" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          
                          <path d="M1349.77,1785.22v-323.35" fill="none" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                          <path d="M1019.52,1785.22v-308.63" fill="none" stroke="#000" stroke-width="45" stroke-miterlimit="10"/>
                        </svg>`
            }
        ],
        data: {
            selectedModes: ['solo']  // Default selection
        },
        init: function() {
            let section = befriend.filters.sections.modes;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            // Get stored filter values if they exist
            const filter_data = befriend.filters.data.filters?.['modes'];

            if (filter_data?.items) {
                this.data.selectedModes = Object.values(filter_data.items)
                    .filter(item => !item.is_negative)
                    .map(item => item.mode_token);
            }

            const modesHtml = this.items.map(mode => {
                const isSelected = this.data.selectedModes.includes(mode.id);
                return `
                <button class="mode-button ${mode.id} ${isSelected ? 'selected' : ''}" data-mode="${mode.id}">
                    ${mode.icon}
                    <span class="name">${mode.label}</span>
                </button>
            `;
            }).join('');

            filter_options.innerHTML = `
            <div class="filter-option" data-filter-token="${section.token}">
                ${befriend.filters.sendReceiveHtml(true, true, true)}
                <div class="modes-buttons">
                    ${modesHtml}
                </div>
            </div>
        `;

            this.initEvents(section_el);
        },
        initEvents: function(section_el) {
            const modeButtons = section_el.querySelectorAll('.mode-button');

            for (let button of modeButtons) {
                if (button._listener) continue;
                button._listener = true;

                button.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const modeId = button.getAttribute('data-mode');
                    const wasSelected = elHasClass(button, 'selected');

                    // Don't allow deselecting if it's the only selected mode
                    if (wasSelected && this.data.selectedModes.length <= 1) {
                        return;
                    }

                    try {
                        // Optimistically update UI
                        if (wasSelected) {
                            removeClassEl('selected', button);
                            this.data.selectedModes = this.data.selectedModes.filter(id => id !== modeId);
                        } else {
                            addClassEl('selected', button);
                            this.data.selectedModes.push(modeId);
                        }

                        // Save to server
                        await befriend.auth.put('/filters/modes', {
                            mode_token: modeId,
                            active: !wasSelected
                        });
                    } catch (e) {
                        console.error('Error updating modes filter:', e);

                        // Revert UI state on error
                        if (wasSelected) {
                            addClassEl('selected', button);
                            this.data.selectedModes.push(modeId);
                        } else {
                            removeClassEl('selected', button);
                            this.data.selectedModes = this.data.selectedModes.filter(id => id !== modeId);
                        }
                    }
                });
            }
        }
    },
    reviews: {
        min: 0,
        max: 5,
        precision: 10,
        ratings: {
            safety: {
                token: 'reviews_safety',
                name: 'Safety',
                current_rating: 4.5,
            },
            trust: {
                token: 'reviews_trust',
                name: 'Trust',
                current_rating: 4.5,
            },
            timeliness: {
                token: 'reviews_timeliness',
                name: 'Timeliness',
                current_rating: 4.5,
            },
            friendliness: {
                token: 'reviews_friendliness',
                name: 'Friendliness',
                current_rating: 4.5,
            },
            fun: {
                token: 'reviews_fun',
                name: 'Fun',
                current_rating: 4.5,
            },
        },
        init: function () {
            let section = befriend.filters.sections.reviews;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            let reviewsHtml = '';

            reviewsHtml += `
            <div class="filter-option include-new" data-filter-token="reviews_unrated">
                ${befriend.filters.sendReceiveHtml(true, true)}

                <div class="filter-option-name">
                    ${toggleHtml(true, null, 'toggle-24')}
                    <div class="name">Include unrated matches</div>
                </div>
            </div>`;

            //star ratings
            for (let [key, rating] of Object.entries(this.ratings)) {
                const filter_data = befriend.filters.data.filters?.[rating.token];
                if (filter_data?.filter_value) {
                    rating.current_rating = parseFloat(filter_data.filter_value);
                }

                const isActive = typeof filter_data?.is_active !== 'undefined' ? filter_data.is_active : false;

                reviewsHtml += `
                    <div class="filter-option review review-${key}" data-filter-token="${rating.token}">
                        ${befriend.filters.sendReceiveHtml(true, true)}
                        
                        <div class="toggle-wrapper">
                                ${toggleHtml(false, isActive ? 'On' : 'Off', 'toggle-24')}
                        </div>
                            
                        <div class="filter-option-name">
                            <div class="name">
                                ${rating.name}
                            </div>
                            
                            <div class="rating-display">
                                <div class="value">${rating.current_rating}</div>
                            </div>
                        </div>
                        
                        <div class="stars">
                            <div class="stars-container">
                                ${Array(5)
                                    .fill()
                                    .map(
                                        () => `
                                    <div class="star-container">
                                        <svg class="outline" viewBox="0 0 24 24">
                                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                                        </svg>
                                        <svg class="fill" viewBox="0 0 24 24">
                                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                                        </svg>
                                    </div>
                                `,
                                    )
                                    .join('')}
                            </div>
                            
                            
                            <div class="range-container">
                                <div class="sliders-control">
                                    <div class="slider-track"></div>
                                    <div class="slider-range"></div>
                                    <div class="thumb">
                                        <span class="thumb-inner"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            filter_options.innerHTML = reviewsHtml;

            this.initEvents(section_el);
        },
        initEvents: function(section_el) {
            const self = this;
            const precision = this.precision;
            const reviewFilters = section_el.querySelectorAll('.filter-option.review');

            for (let section of reviewFilters) {
                const type = Array.from(section.classList)
                    .find((cls) => cls.startsWith('review-'))
                    ?.replace('review-', '');

                if (!type || !this.ratings[type]) continue;

                const stars = section.querySelectorAll('.star-container');
                const display = section.querySelector('.rating-display');

                // Slider elements
                const container = section.querySelector('.sliders-control');
                const range = section.querySelector('.slider-range');
                const thumb = section.querySelector('.thumb');
                let isDragging = false;
                let startX, startLeft;

                function setPosition(value) {
                    if (typeof value !== 'number' || isNaN(value)) {
                        value = 0;
                    }
                    const percent = value / self.max;
                    // Use getBoundingClientRect() for more accurate width
                    const width = container.getBoundingClientRect().width;
                    const position = percent * width;
                    thumb.style.left = `${position}px`;
                    range.style.width = `${position}px`;
                    // thumb.querySelector('.thumb-value').textContent = value.toFixed(1);
                }

                function getValueFromPosition(position) {
                    // Use getBoundingClientRect() for more accurate width
                    const width = container.getBoundingClientRect().width;
                    const percent = position / width;
                    const value = percent * self.max;
                    return Math.min(Math.max(value, self.min), self.max);
                }

                const updateRating = (rating, skip_save) => {
                    rating = Math.max(0, Math.min(5, rating));

                    // Update stars
                    for (let i = 0; i < stars.length; i++) {
                        const fill = stars[i].querySelector('.fill');
                        const fillPercentage = Math.max(0, Math.min(100, (rating - i) * 100));

                        fill.style.removeProperty('fill');
                        fill.style.removeProperty('color');

                        if (fillPercentage === 0) {
                            fill.style.fill = 'transparent';
                        } else if (fillPercentage === 100) {
                            fill.style.fill = befriend.variables.brand_color_a;
                            fill.style.removeProperty('clip-path');
                        } else {
                            fill.style.fill = befriend.variables.brand_color_a;
                            fill.style.clipPath = `polygon(0 0, ${fillPercentage}% 0, ${fillPercentage}% 100%, 0 100%)`;
                        }
                    }

                    // Update slider position and display
                    setPosition(rating);
                    display.querySelector('.value').innerHTML = rating.toFixed(1);
                    self.ratings[type].current_rating = rating;

                    if (!skip_save) {
                        self.saveRating(type, rating);
                    }
                };

                function handleStart(e) {
                    isDragging = true;
                    startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                    // Use getBoundingClientRect() for accurate position
                    const thumbRect = thumb.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    startLeft = thumbRect.left - containerRect.left;
                    e.preventDefault();
                }

                function handleMove(e) {
                    if (!isDragging) return;

                    const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                    const containerRect = container.getBoundingClientRect();
                    const position = clientX - containerRect.left;
                    const value = getValueFromPosition(position);
                    const roundedValue = Math.round(value * precision) / precision; // Round to nearest 0.1
                    updateRating(roundedValue);
                }

                function handleEnd() {
                    isDragging = false;
                }

                function handleTrackClick(e) {
                    if (isDragging) return; // Prevent click while dragging

                    const rect = container.getBoundingClientRect();
                    const clickPosition = e.clientX - rect.left;
                    const value = getValueFromPosition(clickPosition);
                    const roundedValue = Math.round(value * precision) / precision;
                    updateRating(roundedValue);
                }

                // Star events
                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];

                    star.addEventListener('touchstart', (e) => {
                        e.preventDefault();

                        const updateStarRating = (event) => {
                            const touch = event.touches[0];
                            const rect = star.getBoundingClientRect();
                            const x = touch.clientX - rect.left;
                            const width = rect.width;
                            const percentage = Math.max(0, Math.min(1, x / width));
                            const rating = i + percentage;
                            updateRating(rating);
                        };

                        updateStarRating(e);

                        const onTouchMove = (event) => {
                            event.preventDefault();
                            updateStarRating(event);
                        };

                        const onTouchEnd = () => {
                            document.removeEventListener('touchmove', onTouchMove);
                            document.removeEventListener('touchend', onTouchEnd);
                        };

                        document.addEventListener('touchmove', onTouchMove);
                        document.addEventListener('touchend', onTouchEnd);
                    });
                }

                thumb.addEventListener('mousedown', handleStart);
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleEnd);

                // Touch events
                thumb.addEventListener('touchstart', handleStart);
                document.addEventListener('touchmove', handleMove);
                document.addEventListener('touchend', handleEnd);

                // Track click event
                container.addEventListener('click', handleTrackClick);

                // Initialize with current rating
                requestAnimationFrame(() => {
                    const currentRating = self.ratings[type].current_rating;
                    updateRating(currentRating, true);
                });
            }
        },
        saveRating: function(type, rating) {
            if (!this._debounceTimers) {
                this._debounceTimers = {};
            }

            if (this._debounceTimers[type]) {
                clearTimeout(this._debounceTimers[type]);
            }

            this._debounceTimers[type] = setTimeout(async () => {
                try {
                    const filter_token = this.ratings[type].token;

                    await befriend.auth.put('/filters/reviews', {
                        filter_token,
                        rating: parseFloat(rating)
                    });
                } catch (e) {
                    console.error(`Error saving ${type} rating:`, e);
                }
            }, 500);
        }
    },
    age: {
        min: 18,
        max: 130,
        current: {
            min: 18,
            max: 100
        },
        minGap: 2,
        _updateTimer: null,
        init: function() {
            let self = this;

            let section = befriend.filters.sections.ages;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            // Get stored filter values if they exist
            const filter_data = befriend.filters.data.filters?.['ages'];
            if (filter_data?.filter_value_min && filter_data?.filter_value_max) {
                this.current.min = parseInt(filter_data.filter_value_min);
                this.current.max = parseInt(filter_data.filter_value_max);

                // Ensure loaded values respect the minimum gap
                if (this.current.max - this.current.min < this.minGap) {
                    this.current.max = this.current.min + this.minGap;

                    if(this.current.max > this.max) {
                        this.current.max = this.max;
                        this.current.min = this.max - this.minGap;
                    }
                }
            }

            const ageHtml = `
                 <div class="filter-option age-range" data-filter-token="${section.token}">
                    ${befriend.filters.sendReceiveHtml(true, true, true)}
                    
                    <div class="range-container">
                        <div class="sliders-control">
                            <div class="slider-track"></div>
                            <div class="slider-range"></div>
                            <div class="thumb min-thumb">
                                <span class="thumb-value"></span>
                            </div>
                            <div class="thumb max-thumb">
                                <span class="thumb-value"></span>
                            </div>
                        </div>
                    </div>
                </div>`;

            filter_options.innerHTML = ageHtml;

            // Get elements after they're added to DOM
            const container = section_el.querySelector('.sliders-control');
            const range = section_el.querySelector('.slider-range');
            const minThumb = section_el.querySelector('.min-thumb');
            const maxThumb = section_el.querySelector('.max-thumb');

            let isDragging = null;
            let startX, startLeft;

            function setPosition(thumb, value) {
                const percent = (value - self.min) / (self.max - self.min);
                const position = percent * container.offsetWidth;
                thumb.style.left = `${position}px`;
                thumb.querySelector('.thumb-value').textContent = Math.round(value);
            }

            function updateRange() {
                const minLeft = parseFloat(minThumb.style.left);
                const maxLeft = parseFloat(maxThumb.style.left);
                range.style.left = `${Math.min(minLeft, maxLeft)}px`;
                range.style.width = `${Math.abs(maxLeft - minLeft)}px`;
            }

            function getValueFromPosition(position) {
                const percent = position / container.offsetWidth;
                return Math.min(Math.max(percent * (self.max - self.min) + self.min, self.min), self.max);
            }

            function handleStart(e) {
                isDragging = this;
                startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                startLeft = parseFloat(this.style.left);
                e.preventDefault();
            }

            function handleMove(e) {
                if (!isDragging) return;

                const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const dx = clientX - startX;
                const newLeft = Math.min(Math.max(0, startLeft + dx), container.offsetWidth);
                const value = getValueFromPosition(newLeft);

                if (isDragging === minThumb) {
                    // Ensure minimum thumb doesn't get closer than minGap to maximum thumb
                    const maxValue = self.current.max;
                    if (value <= maxValue - self.minGap) {
                        self.current.min = Math.round(value);
                        setPosition(minThumb, self.current.min);
                    }
                } else if (isDragging === maxThumb) {
                    // Ensure maximum thumb doesn't get closer than minGap to minimum thumb
                    const minValue = self.current.min;
                    if (value >= minValue + self.minGap) {
                        self.current.max = Math.round(value);
                        setPosition(maxThumb, self.current.max);
                    }
                }

                updateRange();
                self.debounceUpdateServer();
            }

            function handleEnd() {
                isDragging = null;
            }

            // Mouse events
            [minThumb, maxThumb].forEach(thumb => {
                thumb.addEventListener('mousedown', handleStart);
            });
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);

            // Touch events
            [minThumb, maxThumb].forEach(thumb => {
                thumb.addEventListener('touchstart', handleStart);
            });
            document.addEventListener('touchmove', handleMove);
            document.addEventListener('touchend', handleEnd);

            // Initialize positions
            requestAnimationFrame(function () {
                setPosition(minThumb, befriend.filters.age.current.min);
                setPosition(maxThumb, befriend.filters.age.current.max);
                updateRange();
            });
        },
        debounceUpdateServer: function() {
            clearTimeout(this._updateTimer);
            this._updateTimer = setTimeout(() => {
                this.saveAgeRange();
            }, 500);
        },

        saveAgeRange: async function() {
            try {
                await befriend.auth.put('/filters/age', {
                    min_age: this.current.min,
                    max_age: this.current.max
                });
            } catch(e) {
                console.error('Error saving age range:', e);
            }
        }
    },
    genders: {
        init: function() {
            let section = befriend.filters.sections.genders;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            const filter_data = befriend.filters.data.filters?.['genders'];

            let gender_buttons_html = '';

            if (befriend.me.data.genders) {
                for (let gender of befriend.me.data.genders) {
                    let selected = '';

                    const matchingItem = filter_data?.items ?
                        Object.values(filter_data.items)
                            .find(item => item.gender_id === gender.id) : null;

                    // Item is selected if it exists and is not negative
                    if (matchingItem && !matchingItem.is_negative) {
                        selected = 'selected';
                    } else if (!filter_data?.items && gender.token === 'any') {
                        // Default to 'any' selected if no filter data exists yet
                        selected = 'selected';
                    }

                    gender_buttons_html += `
                        <div class="item gender-button ${gender.token} ${selected}" data-token="${gender.token}">
                            <div class="name">${gender.name}</div>
                        </div>`;
                }
            }

            let html = `
                <div class="filter-option" data-filter-token="${section.token}">
                    ${befriend.filters.sendReceiveHtml(true, true, true)}
                    
                    <div class="items-container gender-buttons">
                        ${gender_buttons_html}
                    </div>
                </div>
            `;

            filter_options.innerHTML = html;

            this.initEvents(section_el);
        },
        initEvents: function(section_el) {
            const genderButtons = section_el.querySelectorAll('.gender-button');

            for (let button of genderButtons) {
                if (!button._listener) {
                    button._listener = true;

                    button.addEventListener('click', async function(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        let genderToken = this.getAttribute('data-token');
                        let isAny = genderToken === 'any';
                        const anyButton = section_el.querySelector('.gender-button[data-token="any"]');
                        const wasSelected = elHasClass(this, 'selected');

                        // If selecting "Any", deselect all others
                        if (isAny && !wasSelected) {
                            for(let btn of genderButtons) {
                                if (btn !== this) {
                                    removeClassEl('selected', btn);
                                }
                            }
                        }
                        // If selecting a specific gender, deselect "Any"
                        else if (!isAny && !wasSelected) {
                            if (anyButton) {
                                removeClassEl('selected', anyButton);
                            }
                        }

                        toggleElClass(this, 'selected');

                        //switch to any if all three selected
                        let allSelected = true;

                        for(let btn of genderButtons) {
                            if(btn.getAttribute('data-token') === 'any' && !wasSelected) {
                                continue;
                            }

                            if(!elHasClass(btn, 'selected')) {
                                allSelected = false;
                            }
                        }

                        if(allSelected) {
                            removeElsClass(genderButtons, 'selected');
                            genderToken = 'any';
                            isAny = true;
                            addClassEl('selected', anyButton);
                        }

                        try {
                            await befriend.auth.put('/filters/gender', {
                                gender_token: genderToken,
                                active: !wasSelected
                            });
                        } catch (e) {
                            console.error('Error updating gender filter:', e);

                            // Revert UI state on error
                            toggleElClass(this, 'selected');

                            if (isAny && !wasSelected) {
                                for(let btn of genderButtons) {
                                    if (btn !== this) {
                                        toggleElClass(btn, 'selected');
                                    }
                                }
                            }
                        }
                    });
                }
            }
        }
    },
    distance: {
        min: 1,
        max: 60,
        current: 20,
        unit: 'miles',
        _updateTimer: null,
        init: function() {
            let self = this;

            let section = befriend.filters.sections.distance;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            // Get stored filter values if they exist
            const filter_data = befriend.filters.data.filters?.[section.token];

            if (filter_data?.filter_value) {
                this.current = parseInt(filter_data.filter_value);
            }

            const distanceHtml = `
                <div class="filter-option distance-range" data-filter-token="${section.token}">
                    ${befriend.filters.sendReceiveHtml(true, true, true)}
                    
                    <div class="filter-option-name">
                        <span class="name">Max distance <span class="miles-km">(miles)</span></span>
                    </div>
                    <div class="range-container">
                        <div class="sliders-control">
                            <div class="slider-track"></div>
                            <div class="slider-range"></div>
                            <div class="thumb">
                                <span class="thumb-value"></span>
                            </div>
                        </div>
                    </div>
                </div>`;

            filter_options.innerHTML = distanceHtml;

            const container = section_el.querySelector('.sliders-control');
            const range = section_el.querySelector('.slider-range');
            const thumb = section_el.querySelector('.thumb');

            let isDragging = false;
            let startX, startLeft;

            function setPosition(value) {
                const percent = (value - self.min) / (self.max - self.min);
                const position = percent * container.offsetWidth;
                thumb.style.left = `${position}px`;
                range.style.width = `${position}px`;
                thumb.querySelector('.thumb-value').textContent = Math.round(value);
            }

            function getValueFromPosition(position) {
                const percent = position / container.offsetWidth;
                return Math.min(Math.max(percent * (self.max - self.min) + self.min, self.min), self.max);
            }

            function handleStart(e) {
                isDragging = true;
                startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                startLeft = parseFloat(thumb.style.left);
                e.preventDefault();
            }

            function handleMove(e) {
                if (!isDragging) return;

                const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const dx = clientX - startX;
                const newLeft = Math.min(Math.max(0, startLeft + dx), container.offsetWidth);
                const value = getValueFromPosition(newLeft);

                self.current = Math.round(value);
                setPosition(self.current);
                self.debounceUpdateServer();
            }

            function handleEnd() {
                isDragging = false;
            }

            function handleTrackClick(e) {
                const rect = container.getBoundingClientRect();
                const clickPosition = e.clientX - rect.left;
                const value = getValueFromPosition(clickPosition);

                self.current = Math.round(value);
                setPosition(self.current);
                self.debounceUpdateServer();
            }

            // Mouse events
            thumb.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);

            // Touch events
            thumb.addEventListener('touchstart', handleStart);
            document.addEventListener('touchmove', handleMove);
            document.addEventListener('touchend', handleEnd);

            // Track click event
            container.addEventListener('click', handleTrackClick);

            // Initialize position
            requestAnimationFrame(function () {
                setPosition(self.current);
            });
        },
        debounceUpdateServer: function() {
            clearTimeout(this._updateTimer);
            this._updateTimer = setTimeout(() => {
                this.saveDistance();
            }, 500);
        },
        saveDistance: async function() {
            try {
                await befriend.auth.put('/filters/distance', {
                    distance: this.current
                });
            } catch(e) {
                console.error('Error saving distance:', e);
            }
        }
    },
    activity_types: {
        selected: {
            level_1: null,
            level_2: null,
            level_3: null,
        },
        init: function () {
            this.render();
            this.initEvents();
        },
        getNegativeState(activity_type_id) {
            activity_type_id = parseInt(activity_type_id);
            let section = befriend.filters.sections.activityTypes;
            const filter_data = befriend.filters.data.filters?.[section.token];

            if(filter_data?.items) {
                for(let k in filter_data?.items) {
                    let data = filter_data?.items[k];

                    if(data.activity_type_id === activity_type_id) {
                        return data.is_negative;
                    }
                }
            }

            return null;
        },
        hasAnyNegatives: function () {
            const section = befriend.filters.sections.activityTypes;
            const filterData = befriend.filters.data.filters?.[section.token];

            if(!filterData || !filterData.items) {
                return false;
            }

            for(let k in filterData.items) {
                let item = filterData.items[k];

                if(item.is_negative) {
                    return true;
                }
            }

            return false;
        },
        updateFilterData: function(activityIds, isActive, isAll) {
            const section = befriend.filters.sections.activityTypes;
            const filterData = befriend.filters.data.filters?.[section.token];

            if (!filterData) {
                return;
            }

            if(isAll) {
                if(filterData?.items) {
                    for (let k in filterData.items) {
                        let item = filterData.items[k];
                        item.is_negative = false;
                    }
                }
            } else if(activityIds.length) {
                if (filterData?.items) {
                    for (let k in filterData.items) {
                        let item = filterData.items[k];
                        if(activityIds.includes(item.activity_type_id)) {
                            item.is_negative = !isActive;
                        }
                    }
                }
            }
        },
        render: function () {
            let section = befriend.filters.sections.activityTypes;
            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            let activities = befriend.activities.types.data;

            let html = ``;
            let level_1_html = ``;

            //create rows and add hidden placeholder row below each row for multi-level select
            let activities_row = [];

            //all activities
            activities_row.push(`
            <div class="activity all ${this.hasAnyNegatives() ? '' : 'active'} level_1_activity" data-token="all">
                    <div class="activity_wrapper">
                        All
                    </div>
            </div>`);

            let level_1_ids = Object.keys(activities);

            for (let i = 0; i < level_1_ids.length; i++) {
                let level_1_id = level_1_ids[i];

                if (activities_row.length === befriend.variables.filter_activity_row_items) {
                    let row_html = activities_row.join('');

                    level_1_html += `<div class="level_1_row">
                                            ${row_html}
                                        </div>`;
                    level_1_html += `<div class="level_2"></div>`;

                    activities_row.length = [];
                }

                let activity = activities[level_1_id];

                let image_html = ``;

                if (activity.image) {
                    image_html += `<div class="image">
                                        ${activity.image}
                                    </div>`;
                } else if (activity.emoji) {
                }

                let icon_html = ``;

                if (image_html) {
                    icon_html = `<div class="icon">${image_html}</div>`;
                }

                let center_class = icon_html ? '' : 'center';

                let negative_state = this.getNegativeState(level_1_id);

                let is_checked = negative_state === null ? true : !negative_state;

                let chevron_html = '';

                if(activity.sub && Object.keys(activity.sub).length) {
                    chevron_html = `<div class="chevron">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001"><path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/></svg>
                                    </div>`;
                }

                activities_row.push(`
                        <div class="activity level_1_activity" data-id="${level_1_id}" data-token="${activity.token}">
                            ${chevron_html}
                            ${checkboxHtml(is_checked)}
                            <div class="activity_wrapper ${center_class}">
                                ${icon_html}
                                <div class="name">${activity.name}</div>
                            </div>
                        </div>
                    `);
            }

            if (activities_row.length) {
                let row_html = activities_row.join('');
                level_1_html += `<div class="level_1_row">
                                            ${row_html}
                                        </div>`;
                level_1_html += `<div class="level_2"></div>`;
            }

            html = `
                    <div class="level_1">${level_1_html}</div>
                `;

            filter_options.innerHTML = `<div class="filter-option" data-filter-token="${section.token}">
                                            <div class="activities-wrapper">
                                                ${html}
                                            </div>
                                        </div>`;

            let last_row = lastArrItem(
                section_el.getElementsByClassName('level_1_row'),
            );

            last_row.style.marginBottom = '0px';
        },
        initEvents: function () {
            this.checkboxEvents();
            this.level1();
        },
        updateLevelHeight: async function (level_num, skip_set_prev) {
            let level_el = befriend.els.filters.querySelector(`.level_${level_num}.show`);

            if (!level_el) {
                return;
            }

            let last_row = lastArrItem(level_el.getElementsByClassName(`level_${level_num}_row`));

            last_row.style.marginBottom = '0px';

            let level_height = await setElHeightDynamic(level_el, true);

            if (!skip_set_prev) {
                level_el.setAttribute('data-prev-height', `${level_height}px`);
            }

            level_el.style.height = `${level_height}px`;
        },
        initCheckboxState: function(parentEl, childEl) {
            const parentCheckbox = parentEl.querySelector('.checkbox');
            const childCheckbox = childEl.querySelector('.checkbox');
            const childId = childEl.getAttribute('data-id');

            // Check if this item has a negative state
            const isNegative = this.getNegativeState(childId);

            if (parentCheckbox && childCheckbox) {
                // If there's a negative state
                if (isNegative !== null) {
                    if (isNegative) {
                        removeClassEl('checked', childCheckbox);
                    } else {
                        addClassEl('checked', childCheckbox);
                    }
                }
                // Otherwise inherit from parent
                else if (elHasClass(parentCheckbox, 'checked')) {
                    addClassEl('checked', childCheckbox);
                } else {
                    removeClassEl('checked', childCheckbox);
                }
            }
        },
        checkboxEvents: function () {
            let section = befriend.filters.sections.activityTypes;
            let section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            let checkboxes = section_el.getElementsByClassName('checkbox');
            let allActivityEl = section_el.querySelector('.activity.all');

            for(let checkbox of checkboxes) {
                if(checkbox._listener) {
                    continue;
                }

                checkbox._listener = true;

                checkbox.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    let updateIds = [];
                    let updateTokens = {};

                    let activity_el = checkbox.closest('.activity');
                    let token = activity_el.getAttribute('data-token');
                    let activityId = activity_el.getAttribute('data-id');

                    let next_level_el = null;
                    let parent_activity = null;
                    let level_checkboxes = null;

                    // Determine level and get related elements
                    if(elHasClass(activity_el, 'level_3_activity')) {
                        let level_3_el = activity_el.closest('.level_3');
                        let level_2_id = level_3_el.getAttribute('data-level-2-id');
                        parent_activity = section_el.querySelector(`.level_2_activity[data-id="${level_2_id}"]`);
                        level_checkboxes = level_3_el.querySelector('.level_3_container').getElementsByClassName('checkbox');
                    } else if(elHasClass(activity_el, 'level_2_activity')) {
                        let level_2_el = activity_el.closest('.level_2');
                        let parent_id = level_2_el.getAttribute('data-parent-id');
                        parent_activity = section_el.querySelector(`.level_1_activity[data-id="${parent_id}"]`);
                        next_level_el = section_el.querySelector(`.level_3[data-level-2-id="${activityId}"]`);
                        level_checkboxes = level_2_el.querySelector('.level_2_container').getElementsByClassName('checkbox');
                    } else if(elHasClass(activity_el, 'level_1_activity')) {
                        next_level_el = section_el.querySelector(`.level_2[data-parent-id="${activityId}"]`);
                        level_checkboxes = activity_el.closest('.level_1').getElementsByClassName('checkbox');
                    }

                    let wasSelected = elHasClass(checkbox, 'checked');

                    toggleElClass(checkbox, 'checked');

                    //set update state for server for main token
                    updateIds.push(parseInt(activityId));
                    updateTokens[token] = !wasSelected;

                    if(wasSelected) {
                        // Uncheck all child elements
                        if(next_level_el) {
                            befriend.filters.activity_types.toggleCheckboxes(false, false, next_level_el, updateTokens, updateIds);
                        }

                        if(activityId in befriend.activities.types.data) {
                            let activity = befriend.activities.types.data[activityId];

                            if(activity.sub) {
                                for(let sub_id in activity.sub) {
                                    updateTokens[sub_id] = true;

                                    if(!(updateIds.includes(parseInt(sub_id)))) {
                                        updateIds.push(parseInt(sub_id));
                                    }
                                }
                            }
                        }

                        removeClassEl('active', allActivityEl);

                        // Check if all siblings are unchecked
                        if(level_checkboxes && parent_activity) {
                            let all_unchecked = Array.from(level_checkboxes).every(el => !elHasClass(el, 'checked'));

                            if(all_unchecked) {
                                // Also uncheck parent if this was the last checked item

                                let parent_id = parent_activity.getAttribute('data-id');
                                let parent_token = parent_activity.getAttribute('data-token');
                                updateIds.push(parseInt(parent_id));
                                updateTokens[parent_token] = false;

                                removeClassEl('checked', parent_activity.querySelector('.checkbox'));

                                // For level 3, also check level 1 parent
                                if(elHasClass(activity_el, 'level_3_activity')) {
                                    let level_2_el = parent_activity.closest('.level_2');
                                    let level_1_id = level_2_el.getAttribute('data-parent-id');
                                    let level_1_activity = section_el.querySelector(`.level_1_activity[data-id="${level_1_id}"]`);

                                    // Check if all level 2 siblings are also unchecked
                                    let level_2_checkboxes = level_2_el.getElementsByClassName('checkbox');
                                    let all_level_2_unchecked = Array.from(level_2_checkboxes).every(el => !elHasClass(el, 'checked'));

                                    if(all_level_2_unchecked && level_1_activity) {
                                        let level_1_token = level_1_activity.getAttribute('data-token');

                                        updateIds.push(parseInt(level_1_id));
                                        updateTokens[level_1_token] = false;
                                        removeClassEl('checked', level_1_activity.querySelector('.checkbox'));
                                    }
                                }
                            }
                        }
                    } else {
                        // Check all child elements
                        if(next_level_el) {
                            befriend.filters.activity_types.toggleCheckboxes(true, false, next_level_el, updateTokens, updateIds);
                        }

                        // Check parent activities
                        if(parent_activity) {
                            let parent_id = parent_activity.getAttribute('data-id');
                            let parent_token = parent_activity.getAttribute('data-token');

                            updateIds.push(parseInt(parent_id));
                            updateTokens[parent_token] = true;
                            addClassEl('checked', parent_activity.querySelector('.checkbox'));

                            // For level 3, also check level 1 parent
                            if(elHasClass(activity_el, 'level_3_activity')) {
                                let level_2_el = parent_activity.closest('.level_2');
                                let level_1_id = level_2_el.getAttribute('data-parent-id');
                                let level_1_activity = section_el.querySelector(`.level_1_activity[data-id="${level_1_id}"]`);

                                if(level_1_activity) {
                                    let level_1_token = level_1_activity.getAttribute('data-token');

                                    updateIds.push(parseInt(level_1_id));
                                    updateTokens[level_1_token] = true;
                                    addClassEl('checked', level_1_activity.querySelector('.checkbox'));
                                }
                            }
                        }
                    }

                    befriend.filters.activity_types.updateFilterData(updateIds, !wasSelected);

                    try {
                        await befriend.filters.activity_types.updateServer(updateTokens, !wasSelected);
                    } catch(e) {
                        console.error(e);
                    }

                    //set all to selected if no negatives
                    if(!wasSelected) {
                        if(!befriend.filters.activity_types.hasAnyNegatives()) {
                            addClassEl('active', allActivityEl);
                        }
                    }
                });
            }
        },
        toggleCheckboxes: function (is_active, is_all, parent_el, updateTokens = {}, updateIds = []) {
            let section = befriend.filters.sections.activityTypes;
            let section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

            let checkboxes = null;

            if(is_all) {
                checkboxes = section_el.getElementsByClassName('checkbox');
            } else if(parent_el) {
                checkboxes = parent_el.getElementsByClassName('checkbox');
            }

            if(checkboxes) {
                for(let checkbox of checkboxes) {
                    let id = checkbox.closest('.activity').getAttribute('data-id');
                    let token = checkbox.closest('.activity').getAttribute('data-token');

                    updateIds.push(parseInt(id));

                    //for server update
                    updateTokens[token] = is_active;

                    if(is_active) {
                        addClassEl('checked', checkbox);
                    } else {
                        removeClassEl('checked', checkbox);
                    }
                }
            }
        },
        level1: function () {
            let els = befriend.els.filters.getElementsByClassName('level_1_activity');

            for (let i = 0; i < els.length; i++) {
                let el = els[i];

                el.addEventListener('click', async function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    let token = this.getAttribute('data-token');

                    if(token === 'all') {
                        if(!elHasClass(el, 'active')) {
                            addClassEl('active', el);
                            befriend.filters.activity_types.toggleCheckboxes(true, true);

                            befriend.filters.activity_types.updateFilterData(null, true, true);

                            await befriend.filters.activity_types.updateServer({
                                [token]: true
                            }, true);
                        }

                        return false;
                    }

                    let parent_id = this.getAttribute('data-id');
                    let activity = befriend.activities.types.data[parent_id];

                    // If no sub-categories, trigger checkbox click
                    if (!activity?.sub || !Object.keys(activity.sub).length) {
                        const checkbox = this.querySelector('.checkbox');
                        if (checkbox) {
                            fireClick(checkbox);
                        }

                        return;
                    }

                    let level_2_el = this.closest('.level_1_row').nextSibling;

                    //remove activity selection and hide level 2 if same activity clicked
                    if (elHasClass(this, 'active')) {
                        removeClassEl('active', this);
                        hideLevel(level_2_el);

                        befriend.filters.activity_types.selected.level_1 = null;
                        befriend.filters.activity_types.selected.level_2 = null;
                        befriend.filters.activity_types.selected.level_3 = null;
                        return;
                    } else {
                        //remove active from any previously selected activity except any
                        let other_els = Array.from(els).filter(item_el => item_el.getAttribute('data-token') !== 'all');
                        removeElsClass(other_els, 'active');
                        addClassEl('active', this);
                        befriend.filters.activity_types.selected.level_1 = activity;
                        befriend.filters.activity_types.selected.level_2 = null;
                        befriend.filters.activity_types.selected.level_3 = null;
                    }

                    let prev_level_2 = befriend.els.filters.querySelector('.level_2.show');

                    //do not proceed if no sub categories
                    if (!activity?.sub || !Object.keys(activity.sub).length) {
                        if (prev_level_2) {
                            hideLevel(prev_level_2);
                        }

                        return;
                    }

                    //hide other level 2s if different from this one
                    if (prev_level_2) {
                        if (prev_level_2 !== level_2_el) {
                            hideLevel(prev_level_2);
                            addClassEl('show', level_2_el);
                        }
                    } else {
                        addClassEl('show', level_2_el);
                    }

                    level_2_el.setAttribute('data-parent-id', parent_id);

                    let level_2_html = ``;

                    let activities_level_2 = [];

                    for (let level_2_id in activity.sub) {
                        let activity = befriend.activities.types.data[parent_id].sub[level_2_id];

                        if(activity.name.toLowerCase() === 'any') {
                            continue;
                        }

                        if (
                            activities_level_2.length ===
                            befriend.variables.filter_activity_level_2_row_items
                        ) {
                            let row_html = activities_level_2.join('');

                            level_2_html += `<div class="level_2_row">
                                            ${row_html}
                                        </div>`;

                            level_2_html += `<div class="level_3"></div>`;

                            activities_level_2.length = [];
                        }

                        let image_html = '';

                        if (activity.image) {
                            image_html += `<div class="image">
                                        ${activity.image}
                                    </div>`;
                        } else if (activity.emoji) {
                        }

                        let icon_html = ``;

                        if (image_html) {
                            icon_html = `<div class="icon">${image_html}</div>`;
                        }

                        let no_icon_class = icon_html ? '' : 'no_icon';

                        let negative_state = befriend.filters.activity_types.getNegativeState(level_2_id);

                        let is_checked = negative_state === null ? true : !negative_state;

                        let chevron_html = '';

                        if(activity.sub && Object.keys(activity.sub).length) {
                            chevron_html = `<div class="chevron">
                                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001"><path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/></svg>
                                            </div>`;
                        }

                        activities_level_2.push(`
                            <div class="activity level_2_activity" data-id="${level_2_id}" data-token="${activity.token}">
                                ${chevron_html}
                                ${checkboxHtml(is_checked)}
                                <div class="activity_wrapper ${no_icon_class}">
                                    ${icon_html}
                                    <div class="name">${activity.name}</div>
                                </div>
                            </div>`);
                    }

                    if (activities_level_2.length) {
                        let row_html = activities_level_2.join('');
                        level_2_html += `<div class="level_2_row">
                                            ${row_html}
                                        </div>`;
                        level_2_html += `<div class="level_3"></div>`;
                    }

                    level_2_el.innerHTML = `<div class="level_2_container">
                                                ${level_2_html}
                                            </div>`;

                    const level2Activities = level_2_el.querySelectorAll('.level_2_activity');

                    for(let activity_el of level2Activities) {
                        befriend.filters.activity_types.initCheckboxState(this, activity_el);
                    }

                    befriend.filters.activity_types.updateLevelHeight(2);

                    befriend.filters.activity_types.level2();

                    befriend.filters.activity_types.checkboxEvents();
                });
            }
        },
        level2: function () {
            let level_2_activity_els =
                befriend.els.filters.getElementsByClassName('level_2_activity');

            for (let i = 0; i < level_2_activity_els.length; i++) {
                let el = level_2_activity_els[i];

                el.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    let parent_id = this.closest('.level_2').getAttribute('data-parent-id');
                    let level_2_id = this.getAttribute('data-id');
                    let level_2_activity = befriend.activities.types.data[parent_id].sub[level_2_id];

                    // If no sub-activities, trigger checkbox click
                    const hasSubActivities = level_2_activity.sub && Object.keys(level_2_activity.sub).length > 0;
                    if (!hasSubActivities) {
                        const checkbox = this.querySelector('.checkbox');
                        if (checkbox) {
                            checkbox.click();
                        }
                        return;
                    }

                    let level_3_el = this.closest('.level_2_row').nextSibling;
                    let closest_level_2_el = this.closest('.level_2');
                    let prev_height_level_2 = closest_level_2_el.getAttribute('data-prev-height');

                    if (elHasClass(this, 'active')) {
                        removeClassEl('active', this);
                        hideLevel(level_3_el);
                        closest_level_2_el.style.height = prev_height_level_2;
                        befriend.filters.activity_types.selected.level_2 = null;
                        befriend.filters.activity_types.selected.level_3 = null;
                        return;
                    }

                    removeElsClass(level_2_activity_els, 'active');
                    addClassEl('active', this);

                    let prev_level_3 = befriend.els.filters.querySelector('.level_3.show');

                    if (prev_level_3) {
                        if (prev_level_3 !== level_3_el) {
                            hideLevel(prev_level_3);
                            addClassEl('show', level_3_el);
                        }
                    } else {
                        addClassEl('show', level_3_el);
                    }

                    level_3_el.setAttribute('data-parent-id', parent_id);
                    level_3_el.setAttribute('data-level-2-id', level_2_id);

                    let level_3_html = ``;
                    let activities_level_3 = [];

                    for (let level_3_id in level_2_activity.sub) {
                        let activity = befriend.activities.types.data[parent_id].sub[level_2_id].sub[level_3_id];

                        if(activity.name.toLowerCase() === 'any') {
                            continue;
                        }

                        if (activities_level_3.length === befriend.variables.filter_activity_level_3_row_items) {
                            let row_html = activities_level_3.join('');
                            level_3_html += `<div class="level_3_row">${row_html}</div>`;
                            activities_level_3.length = [];
                        }

                        let image_html = '';
                        if (activity.image) {
                            image_html += `<div class="image">${activity.image}</div>`;
                        }

                        let icon_html = image_html ? `<div class="icon">${image_html}</div>` : '';
                        let no_icon_class = icon_html ? '' : 'no_icon';

                        let negative_state = befriend.filters.activity_types.getNegativeState(level_3_id);

                        let is_checked = negative_state === null ? true : !negative_state;

                        activities_level_3.push(`
                <div class="activity level_3_activity" data-id="${level_3_id}" data-token="${activity.token}">
                    ${checkboxHtml(is_checked)}
                    <div class="activity_wrapper ${no_icon_class}">
                        ${icon_html}
                        <div class="name">${activity.name}</div>
                    </div>
                </div>`);
                    }

                    if (activities_level_3.length) {
                        let row_html = activities_level_3.join('');
                        level_3_html += `<div class="level_3_row">${row_html}</div>`;
                    }

                    level_3_el.innerHTML = `<div class="level_3_container">${level_3_html}</div>`;

                    const level3Activities = level_3_el.querySelectorAll('.level_3_activity');

                    for(let activity_el of level3Activities) {
                        befriend.filters.activity_types.initCheckboxState(this, activity_el);
                    }

                    befriend.filters.activity_types.updateLevelHeight(3);
                    requestAnimationFrame(function () {
                        befriend.filters.activity_types.updateLevelHeight(2, true);
                    });

                    befriend.filters.activity_types.checkboxEvents();

                    // Always update the selected level 2 activity
                    befriend.filters.activity_types.selected.level_2 = hasSubActivities ? level_2_activity : null;
                    befriend.filters.activity_types.selected.level_3 = null;

                    // Remove active from level 2 and hide any visible level 3 content
                    if (!hasSubActivities) {
                        removeElsClass(closest_level_2_el.getElementsByClassName('level_2_activity'), 'active');
                        let visible_level_3 = befriend.els.filters.querySelector('.level_3.show');
                        if (visible_level_3) {
                            hideLevel(visible_level_3);
                            closest_level_2_el.style.height = prev_height_level_2;
                        }
                    }

                    befriend.filters.activity_types.level3();
                });
            }
        },
        level3: function() {
            let level_3_activity_els = befriend.els.filters.getElementsByClassName('level_3_activity');

            for (let i = 0; i < level_3_activity_els.length; i++) {
                let el = level_3_activity_els[i];

                el.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const checkbox = this.querySelector('.checkbox');

                    fireClick(checkbox);
                });
            }
        },
        updateServer: function (updateTokens, is_active) {
            return new Promise(async (resolve, reject) => {
                 try {
                      await befriend.auth.put(`/filters/activity-types`, {
                          activities: updateTokens,
                          active: is_active
                      });
                 } catch(e) {
                     console.error(e);
                 }

                 resolve();
            });
        }
    },
    verifications: {
        options: {
            in_person: {
                token: 'verification_in_person'
            },
            linkedin: {
                token: 'verification_linkedin'
            }
        },
        init: function() {
            let section = befriend.filters.sections.verifications;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            // Get stored filter values if they exist
            const inPersonFilter = befriend.filters.data.filters?.[this.options.in_person.token];
            const linkedinFilter = befriend.filters.data.filters?.[this.options.linkedin.token];

            let inPersonActive = typeof inPersonFilter?.is_active !== 'undefined' ? inPersonFilter.is_active : false;
            let linkedInActive = typeof linkedinFilter?.is_active !== 'undefined' ? linkedinFilter.is_active : false;

            const html = `
                <div class="filter-options-container">
                    <div class="filter-option verification-button" data-filter-token="${this.options.in_person.token}">
                        ${befriend.filters.sendReceiveHtml(true, true)}

                        <div class="content">
                            <div class="verification-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                                    <path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M256,128c39.8,0,72,32.2,72,72 s-32.2,72-72,72s-72-32.2-72-72S216.2,128,256,128z M256,448c-52.9,0-100.3-23.1-133.2-59.6c26.1-42.4,72.5-70.4,125.2-70.4 c2.7,0,5.3,0.1,7.9,0.3c2.6-0.2,5.2-0.3,7.9-0.3c52.7,0,99.1,28,125.2,70.4C356.3,424.9,308.9,448,256,448z"/>
                                </svg>
                            </div>
                            <div class="text">
                                <div class="name">In-Person</div>
                            </div>

                            ${toggleHtml(inPersonActive, inPersonActive ? 'On': 'Off', 'toggle-24')}
                        </div>
                    </div>
                    <div class="filter-option verification-button" data-filter-token="${this.options.linkedin.token}">
                        ${befriend.filters.sendReceiveHtml(true, true)}

                        <div class="content">
                            <div class="verification-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                                    <path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/>
                                </svg>
                            </div>
                            <div class="text">
                                <div class="name">LinkedIn</div>
                            </div>
                            
                            ${toggleHtml(linkedInActive, linkedInActive ? 'On': 'Off', 'toggle-24')}
                        </div>
                    </div>
                </div>
            `;

            filter_options.innerHTML = html;

            // Set initial states based on stored values
            if (inPersonFilter && !inPersonFilter.is_active) {
                const toggle = filter_options.querySelector(`[data-filter-token="${this.options.in_person.token}"] .toggle`);
                removeClassEl('active', toggle);
            }

            if (linkedinFilter && !linkedinFilter.is_active) {
                const toggle = filter_options.querySelector(`[data-filter-token="${this.options.linkedin.token}"] .toggle`);
                removeClassEl('active', toggle);
            }

            this.initEvents(section_el);
        },

        initEvents: function(section_el) {
            const options = section_el.querySelectorAll('.filter-option');

            for(let option of options) {
                option.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    let toggle = option.querySelector('.toggle');

                    fireClick(toggle);
                });
            }
        }
    },
    instruments: {
        init: function () {
            let section = befriend.filters.sections.instruments;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');
            const sectionData = befriend.filters.data.options?.['instruments'];
            const storedFilters = befriend.filters.data.filters?.instruments || {};

            let categories_html = '';
            if (sectionData?.options.length > 0) {
                categories_html = `
            <div class="category-btn mine active" data-category="mine">My Filters</div>`;

                for (let category of sectionData.categories.options) {
                    categories_html += `
                <div class="category-btn" data-category="${category.name?.toLowerCase()}" 
                     ${category.token ? `data-category-token="${category.token}"` : ''}>
                    <div class="heading-name">
                        <div class="name">${category.name}</div>
                    </div>
                </div>`;
                }
            }

            const html = `
        <div class="filter-options-container">
            <div class="filter-option" data-filter-token="${section.token}">
                <div class="search-container">
                    <div class="autocomplete-container">
                        <div class="input-container">
                            <input type="text" class="search-input" 
                                   placeholder="${sectionData?.autoComplete?.placeholders?.main || 'Search instruments'}">
                            <div class="search-icon-container">
                                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 611.9975 612.0095">
                                    <path d="M606.203,578.714l-158.011-155.486c41.378-44.956,66.802-104.411,66.802-169.835-.02-139.954-115.296-253.393-257.507-253.393S0,113.439,0,253.393s115.276,253.393,257.487,253.393c61.445,0,117.801-21.253,162.068-56.586l158.624,156.099c7.729,7.614,20.277,7.614,28.006,0,7.747-7.613,7.747-19.971.018-27.585ZM257.487,467.8c-120.326,0-217.869-95.993-217.869-214.407S137.161,38.986,257.487,38.986s217.869,95.993,217.869,214.407-97.542,214.407-217.869,214.407Z"/>
                                </svg>
                            </div>
                        </div>
                        <div class="autocomplete-list"></div>
                    </div>
                </div>
    
                ${categories_html ? `
                    <div class="categories-container">
                        <div class="category-filters">${categories_html}</div>
                    </div>
                ` : ''}
    
                <div class="items-container">
                    <div class="items cols-2"></div>
                </div>
                
                <div class="secondary-container"></div>
            </div>
        </div>
    `;

            section_el.querySelector('.section-container')
                .insertAdjacentHTML(
                    'afterbegin',
                    befriend.filters.sendReceiveHtml(true, true, true)
                );

            filter_options.innerHTML = html;

            let items = [];
            let secondaryItems = '';
            const secondary_options = sectionData?.secondary?.instruments?.options;

            // Initialize items for "mine" category
            if (storedFilters?.items) {
                items = Object.values(storedFilters.items)
                    .filter(item => !item.deleted)
                    .filter(Boolean);
            }

            // Prepare secondary items HTML first
            if (secondary_options) {
                for (let item of items) {
                    const storedItem = Object.values(storedFilters?.items || {})
                        .find(stored => stored.token === item.token);

                    const selectedSecondary = storedItem?.secondary || [];
                    let isAnyLevel = selectedSecondary.includes('any');
                    let unselected = selectedSecondary.length === 0 ? 'unselected' : '';

                    // Determine the display text
                    let currentText;
                    if (isAnyLevel) {
                        currentText = 'Any Level';
                    } else if (selectedSecondary.length) {
                        currentText = selectedSecondary.join(', ');
                    } else {
                        currentText = sectionData.secondary.instruments.unselectedStr;
                    }

                    let secondary_options_html = '';

                    // Add "Any Level" option first
                    secondary_options_html += `<div class="option any-level ${isAnyLevel ? 'selected' : ''}" data-option="any">Any Level</div>`;

                    // Add other options
                    for (let option of secondary_options) {
                        let selected = !isAnyLevel && selectedSecondary.includes(option) ? 'selected' : '';
                        secondary_options_html += `<div class="option ${selected}" data-option="${option}">${option}</div>`;
                    }

                    secondaryItems += `
                <div class="item ${item.token}" data-token="${item.token}">
                    <div class="options" data-item-token="${item.token}">${secondary_options_html}</div>
                </div>`;
                }
            }

            // Add secondary items to container
            const secondary_container = section_el.querySelector('.secondary-container');
            secondary_container.innerHTML = secondaryItems;

            requestAnimationFrame(() => {
                befriend.filters.instruments.renderItems(section_el, items, true);
                befriend.filters.updateSectionHeights();
            });
        },
        renderItems: function(section_el, items, is_mine) {
            const storedFilters = befriend.filters.data.filters?.instruments;
            const sectionData = befriend.filters.data.options?.['instruments'];
            const items_container = section_el.querySelector('.items');

            let items_html = '';

            if (is_mine) {
                const hasActiveNonDeletedItems = storedFilters?.items &&
                    Object.values(storedFilters.items)
                        .some(item => !item.deleted && item.is_active);

                items_html = `
            <div class="item any ${!hasActiveNonDeletedItems ? 'active' : ''}" data-token="any">
                <div class="name">Any Instrument</div>
            </div>`;
            }

            let added_item_tokens = {};

            if (storedFilters?.items) {
                for(let k in storedFilters.items) {
                    let item = storedFilters.items[k];
                    if(!item.deleted && item.is_active) {
                        let option = sectionData?.options.find(opt => opt.id === item.instrument_id);
                        if(option) {
                            added_item_tokens[option.token] = item;
                        }
                    }
                }
            }

            if (items?.length) {
                items_html += items.map(item => {
                    if (is_mine) {
                        const storedItem = Object.values(storedFilters?.items || {})
                            .find(stored => stored.token === item.token);
                        const isActive = storedItem && !storedItem.deleted && storedItem.is_active;

                        return `
                    <div class="item mine ${isActive ? 'active': ''}" data-id="${storedItem?.id}" data-token="${item.token}">
                        <div class="content">
                            <div class="name">${item.name}</div>
                            
                            <div class="secondary ${storedItem?.secondary?.length === 0 ? 'unselected' : ''}" 
                                 data-section="${befriend.filters.sections.instruments.token}"
                                 data-item-token="${item.token}">
                                <div class="current-selected">
                                    ${storedItem?.secondary?.includes('any') ? 'Any Level' :
                            storedItem?.secondary?.length ? `${storedItem.secondary.length} Selected` :
                                sectionData.secondary.instruments.unselectedStr}
                                </div>
                                <svg class="arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 82.1 43.2">
                                    <path d="M41.1,43.2L0,2.2,2.1,0l39,39L80,0l2.1,2.2-41,41Z"/>
                                </svg>
                            </div>
                            <div class="remove">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 56 56">
                                    <path d="M28,0C12.5605,0,0,12.5605,0,28s12.5605,28,28,28,28-12.5605,28-28S43.4395,0,28,0ZM28,53c-13.7852,0-25-11.2148-25-25S14.2148,3,28,3s25,11.2148,25,25-11.2148,25-25,25ZM39.2627,16.7373c-.5859-.5859-1.5352-.5859-2.1211,0l-9.1416,9.1416-9.1416-9.1416c-.5859-.5859-1.5352-.5859-2.1211,0-.5859.5854-.5859,1.5356,0,2.1211l9.1416,9.1416-9.1416,9.1416c-.5859.5854-.5859,1.5356,0,2.1211.293.293.6768.4395,1.0605.4395s.7676-.1465,1.0605-.4395l9.1417-9.1416,9.1416,9.1416c.293.293.6768.4395,1.0605.4395s.7676-.1465,1.0605-.4395c.5859-.5854.5859-1.5356,0-2.1211l-9.1415-9.1416,9.1416-9.1416c.5859-.5855.5859-1.5356,0-2.1211Z"/>
                                </svg>
                            </div>
                        </div>
                    </div>`;
                    }

                    if(item.token in added_item_tokens) {
                        return;
                    }

                    return `
                <div class="item" data-token="${item.token}">
                    <div class="name">${item.name}</div>
                </div>`;
                }).join('');
            }

            items_container.innerHTML = items_html;

            this.events.init();

            befriend.filters.importance.set();
        },
        addItem: async function(itemData = {}, section_el) {
            try {
                let {token} = itemData;
                befriend.toggleSpinner(true);

                const sectionData = befriend.filters.data.options?.['instruments'];
                const secondary_options = sectionData?.secondary?.instruments?.options;
                const category_mine = section_el.querySelector(`.category-btn.mine`);

                let response = await befriend.auth.put('/filters/instruments', {
                    token,
                    active: true
                });

                let id = response?.data?.id;

                // Get current mine items
                const storedFilters = befriend.filters.data.filters?.instruments;

                if (!storedFilters?.items) {
                    befriend.filters.data.filters.instruments = {
                        items: {}
                    }
                }

                let option = sectionData?.options.find(opt => opt.token === token);

                befriend.filters.data.filters.instruments.items[id] = {
                    id,
                    token,
                    instrument_id: option.id,
                    name: option.name,
                    is_active: true,
                }

                // Add secondary options for new item
                if (secondary_options) {
                    const secondary_container = section_el.querySelector('.secondary-container');

                    // Create secondary options HTML
                    let secondary_options_html = '';
                    secondary_options_html += `<div class="option any-level" data-option="any">Any Level</div>`;

                    // Add other options
                    for (let opt of secondary_options) {
                        secondary_options_html += `<div class="option" data-option="${opt}">${opt}</div>`;
                    }

                    // Create the secondary item container
                    const secondaryItemHtml = `
                <div class="item ${token}" data-token="${token}">
                    <div class="options" data-item-token="${token}">
                        ${secondary_options_html}
                    </div>
                </div>`;

                    // Add to secondary container
                    secondary_container.insertAdjacentHTML('beforeend', secondaryItemHtml);
                }

                // Switch to mine category and show updated items
                fireClick(category_mine);

                requestAnimationFrame(() => {
                    befriend.filters.updateSectionHeights();
                });

                befriend.toggleSpinner(false);
                return true;
            } catch (e) {
                console.error('Error adding instrument:', e);
                befriend.toggleSpinner(false);
                return false;
            }
        },
        toggleAutocomplete: function(show) {
            let section = befriend.filters.sections.instruments;
            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

            const autocomplete_container = section_el.querySelector('.autocomplete-container');
            const autocomplete_list = section_el.querySelector('.autocomplete-list');

            if (!autocomplete_list) return;

            if (show) {
                addClassEl('autocomplete-shown', autocomplete_container);

                // Reset scroll position
                autocomplete_list.scrollTop = 0;

                // Ensure input stays focused
                const search_input = section_el.querySelector('.search-input');
                if (search_input) search_input.focus();
            } else {
                removeClassEl('autocomplete-shown', autocomplete_container);
            }
        },
        events: {
            init: function () {
                this.search();
                this.categories();
                this.items();
                this.remove();
                this.secondary();
            },
            search: function () {
                let section = befriend.filters.sections.instruments;
                const sectionData = befriend.filters.data.options?.['instruments'];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                const search_input = section_el.querySelector('.search-input');
                const input_container = section_el.querySelector('.input-container');
                const autocomplete_list = section_el.querySelector('.autocomplete-list');

                let debounceTimer;

                if (search_input) {
                    if(search_input._listener) {
                        return;
                    }

                    search_input._listener = true;

                    search_input.addEventListener('input', () => {
                        clearTimeout(debounceTimer);

                        let timeout = this.value ? 200 : 0;

                        debounceTimer = setTimeout(async () => {
                            const value = search_input.value.trim();
                            if (value.length < sectionData.autoComplete.minChars) {
                                befriend.filters.instruments.toggleAutocomplete(false);
                                return;
                            }

                            try {
                                const response = await befriend.auth.get(sectionData.autoComplete.endpoint, {
                                    search: value
                                });

                                if (response.data.items?.length) {
                                    //merge results with options
                                    for(let item of response.data.items) {
                                        let existing_option = sectionData?.options.find(existing => existing.token === item.token);

                                        if(!existing_option) {
                                            item._is_internal = true;
                                            sectionData.options.push(item);
                                        }
                                    }

                                    // Filter out items that already exist in filters data
                                    const storedFilters = befriend.filters.data.filters?.instruments;
                                    const existingTokens = new Set();

                                    if (storedFilters?.items) {
                                        for (let k in storedFilters.items) {
                                            const item = storedFilters.items[k];
                                            if (!item.deleted) {
                                                let instrument = sectionData?.options.find(opt => opt.id === item.instrument_id);
                                                if (instrument) {
                                                    existingTokens.add(instrument.token);
                                                }
                                            }
                                        }
                                    }

                                    const filteredItems = response.data.items.filter(item => !existingTokens.has(item.token));

                                    if (filteredItems.length) {
                                        const items_html = filteredItems.map(item => `
                            <div class="item" data-id="${item.id}" data-token="${item.token}">
                                <div class="name-meta">
                                    <div class="name">${item.name}</div>
                                </div>
                            </div>
                        `).join('');

                                        autocomplete_list.innerHTML = items_html;
                                        befriend.filters.instruments.toggleAutocomplete(true);
                                    } else {
                                        autocomplete_list.innerHTML = '<div class="no-results">No results found</div>';
                                        befriend.filters.instruments.toggleAutocomplete(true);
                                    }
                                } else {
                                    autocomplete_list.innerHTML = '<div class="no-results">No results found</div>';
                                    befriend.filters.instruments.toggleAutocomplete(true);
                                }
                            } catch (e) {
                                console.error('Error searching instruments:', e);
                            }
                        }, timeout);
                    });

                    autocomplete_list.addEventListener('click', async (e) => {
                        const item = e.target.closest('.item');
                        if (!item) return;

                        const id = item.getAttribute('data-id');
                        const token = item.getAttribute('data-token');

                        if (await befriend.filters.instruments.addItem({
                            id,
                            token
                        }, section_el)) {
                            // Close autocomplete and clear input
                            befriend.filters.instruments.toggleAutocomplete(false);
                            search_input.value = '';
                        }
                    });

                    // Focus/blur handling
                    search_input.addEventListener('focus', () => {
                        addClassEl('input-focus', input_container);

                        const value = search_input.value.trim();
                        if (value.length >= sectionData.autoComplete.minChars) {
                            befriend.filters.instruments.toggleAutocomplete(true);
                        }
                    });

                    search_input.addEventListener('blur', () => {
                        removeClassEl('input-focus', input_container);

                        setTimeout(function () {
                            befriend.filters.instruments.toggleAutocomplete(false);
                        }, 100);
                    });
                }
            },
            categories: function () {
                let section = befriend.filters.sections.instruments;
                const sectionData = befriend.filters.data.options?.['instruments'];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                const category_btns = section_el.querySelectorAll('.category-btn');

                for (let btn of category_btns) {
                    if(btn._listener) {
                        continue;
                    }

                    btn._listener = true;

                    btn.addEventListener('click', async () => {
                        removeElsClass(category_btns, 'active');
                        addClassEl('active', btn);

                        let category = btn.getAttribute('data-category').toLowerCase();

                        try {
                            const storedFilters = befriend.filters.data.filters?.instruments;

                            let items;

                            let added_item_tokens = Object.values(storedFilters?.items || {})
                                .reduce(function (acc, item) {
                                    if(!item.deleted) {
                                        acc[item.token] = item;
                                    }

                                    return acc;
                                }, {});

                            if (category === 'mine') {
                                items = Object.values(storedFilters?.items || {})
                                    .filter(item => !item.deleted)
                                    .filter(Boolean);
                            } else {
                                items = sectionData?.options.filter(
                                    item => item?.category?.toLowerCase() === category
                                        && !added_item_tokens[item.token]
                                        && !item._is_internal
                                );
                            }

                            befriend.filters.instruments.renderItems(section_el, items || [], category === 'mine');

                            requestAnimationFrame(() => {
                                befriend.filters.updateSectionHeights();
                            });
                        } catch (e) {
                            console.error('Error loading instruments:', e);
                        }
                    });
                }
            },
            items: function () {
                let section = befriend.filters.sections.instruments;
                const sectionData = befriend.filters.data.options?.['instruments'];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let items_els = section_el.getElementsByClassName('item');

                const category_mine = section_el.querySelector(`.category-btn.mine`);

                for(let item of items_els) {
                    if(item._listener) {
                        continue;
                    }

                    item._listener = true;

                    item.addEventListener('click', async (e) => {
                        if(e.target.closest('.secondary-container')) {
                            return false;
                        }

                        e.preventDefault();
                        e.stopPropagation();

                        //hide if any section secondary is open
                        let token = item.getAttribute('data-token');

                        let open_secondary = item.closest('.section')
                            .querySelector(`.item-secondary-open`);

                        if(open_secondary) {
                            return befriend.filters.hideActiveSecondaryIf(e.target);
                        }

                        let wasSelected = elHasClass(item, 'active');

                        if (elHasClass(item, 'any')) {
                            if(wasSelected) {
                                return;
                            }

                            try {
                                befriend.toggleSpinner(true);

                                await befriend.auth.put('/filters/instruments', {
                                    token: 'any',
                                    active: true
                                });

                                const anyButton = item;
                                const otherItems = section_el.querySelectorAll('.item:not(.any)');

                                addClassEl('active', anyButton);
                                removeElsClass(otherItems, 'active');

                                //update state data
                                if(befriend.filters.data.filters?.instruments?.items) {
                                    for(let k in befriend.filters.data.filters.instruments.items) {
                                        befriend.filters.data.filters.instruments.items[k].is_active = false;
                                    }
                                }
                            } catch (e) {
                                console.error('Error setting any instrument:', e);
                            }

                            befriend.toggleSpinner(false);

                            return;
                        }

                        if (elHasClass(item, 'mine')) {
                            toggleElClass(item, 'active');

                            try {
                                befriend.toggleSpinner(true);

                                await befriend.auth.put('/filters/instruments', {
                                    token,
                                    active: !wasSelected,
                                });

                                const activeItems = section_el.querySelectorAll('.item.mine.active');

                                const anyButton = section_el.querySelector('.item.any');

                                if(anyButton) {
                                    if (activeItems.length === 0) {
                                        addClassEl('active', anyButton);
                                    } else {
                                        removeClassEl('active', anyButton);
                                    }
                                }

                                //update state data
                                if(befriend.filters.data.filters?.instruments?.items) {
                                    for(let k in befriend.filters.data.filters.instruments.items) {
                                        if(befriend.filters.data.filters.instruments.items[k].token === token) {
                                            befriend.filters.data.filters.instruments.items[k].is_active = !wasSelected;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Error removing instrument:', e);
                            }

                            befriend.toggleSpinner(false);

                            return;
                        }

                        //select category item option
                        try {
                            // Remove item from current view
                            item.remove();

                            //add item to server/my filters
                            await befriend.filters.instruments.addItem({ token }, section_el);
                        } catch (e) {
                            console.error('Error adding instrument:', e);
                        }
                    });
                }
            },
            remove: function () {
                let section = befriend.filters.sections.instruments;
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let remove_els = section_el.querySelectorAll('.item .remove');

                for(let remove_el of remove_els) {
                    if(remove_el._listener) {
                        continue;
                    }

                    remove_el._listener = true;

                    remove_el.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        befriend.filters.hideActiveSecondaryIf();

                        let item = remove_el.closest('.item');

                        let token = item.getAttribute('data-token');

                        try {
                            befriend.toggleSpinner(true);

                            await befriend.auth.put('/filters/instruments', {
                                token,
                                is_delete: true
                            });

                            // Remove item and update Any button if needed
                            item.remove();

                            const activeItems = section_el.querySelectorAll('.item.mine.active');

                            if (activeItems.length === 0) {
                                const anyButton = section_el.querySelector('.item.any');
                                if (anyButton) addClassEl('active', anyButton);
                            }

                            //update state data
                            if(befriend.filters.data.filters?.instruments?.items) {
                                for(let k in befriend.filters.data.filters.instruments.items) {
                                    if(befriend.filters.data.filters.instruments.items[k].token === token) {
                                        befriend.filters.data.filters.instruments.items[k].deleted = true;
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error removing instrument:', e);
                        }

                        befriend.toggleSpinner(false);

                        requestAnimationFrame(function () {
                            befriend.filters.updateSectionHeights();
                        });
                    });
                }
            },
            secondary: function() {
                const sectionData = befriend.filters.data.options?.['instruments'];
                const secondary_options = sectionData?.secondary?.instruments?.options;

                let section = befriend.filters.sections.instruments;
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
                let secondary_els = section_el.getElementsByClassName('secondary');

                // Handle clicks on secondary elements (opening/closing)
                for(let secondary_el of secondary_els) {
                    if(secondary_el._listener) continue;
                    secondary_el._listener = true;

                    secondary_el.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        // Only handle direct clicks on the secondary element
                        if (e.target.closest('.option')) return;

                        // Toggle the secondary dropdown
                        befriend.filters.transitionSecondary(
                            secondary_el,
                            !befriend.filters.secondaries.activeEl ||
                            befriend.filters.secondaries.activeEl !== secondary_el
                        );
                    });
                }

                // Handle clicks in the secondary container
                const secondary_container = section_el.querySelector('.secondary-container');

                if (!secondary_container._listener) {
                    secondary_container._listener = true;

                    secondary_container.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        const secondary_option = e.target.closest('.option');
                        if (!secondary_option) return;

                        const options_el = secondary_option.closest('.options');
                        if (!options_el) return;

                        const itemToken = options_el.getAttribute('data-item-token');
                        const option_value = secondary_option.getAttribute('data-option');
                        const isAnyLevel = option_value === 'any';
                        const anyOption = options_el.querySelector('.option.any-level');
                        const otherOptions = options_el.querySelectorAll('.option:not(.any-level)');
                        const wasSelected = elHasClass(secondary_option, 'selected');

                        let itemData;

                        try {
                            befriend.toggleSpinner(true);

                            if(befriend.filters.data.filters?.instruments?.items) {
                                for(let k in befriend.filters.data.filters.instruments.items) {
                                    if(befriend.filters.data.filters.instruments.items[k].token === itemToken) {
                                        itemData = befriend.filters.data.filters.instruments.items[k];

                                        // Initialize array if needed
                                        if(!itemData.secondary || !Array.isArray(itemData.secondary)) {
                                            itemData.secondary = [];
                                        }

                                        if (isAnyLevel) {
                                            // If selecting "Any Level"
                                            if (!wasSelected) {
                                                itemData.secondary = ['any'];
                                                addClassEl('selected', anyOption);
                                                removeElsClass(otherOptions, 'selected');
                                            } else {
                                                return;
                                            }
                                        } else {
                                            // If selecting a specific level
                                            if (!wasSelected) {
                                                // Remove 'any' if it was selected
                                                removeArrItem(itemData.secondary, 'any');
                                                removeClassEl('selected', anyOption);

                                                // Add the new selection
                                                itemData.secondary.push(option_value);
                                                addClassEl('selected', secondary_option);
                                            } else {
                                                // Remove the selection
                                                removeArrItem(itemData.secondary, option_value);
                                                removeClassEl('selected', secondary_option);

                                                //set any if no options selected
                                                if(!itemData.secondary.length) {
                                                    itemData.secondary.push('any');
                                                }
                                            }
                                        }

                                        break;
                                    }
                                }
                            }

                            itemData.secondary = befriend.filters.sortSecondary(secondary_options, itemData.secondary)

                            await befriend.auth.put('/filters/instruments', {
                                token: itemToken,
                                secondary: itemData.secondary
                            });

                            // Find the original secondary element
                            const item = section_el.querySelector(`.item.mine[data-token="${itemToken}"]`);
                            const original_secondary = item?.querySelector('.secondary');

                            if (original_secondary) {
                                // Update unselected class state
                                if (itemData.secondary.length === 0) {
                                    addClassEl('unselected', original_secondary);
                                } else {
                                    removeClassEl('unselected', original_secondary);
                                }

                                // Update displayed text
                                let textContent;
                                if (itemData.secondary.includes('any')) {
                                    textContent = 'Any Level';
                                } else if (itemData.secondary.length) {
                                    textContent = `${itemData.secondary.length} Selected`;
                                } else {
                                    textContent = 'Skill Level';
                                }
                                original_secondary.querySelector('.current-selected').textContent = textContent;
                            }

                            requestAnimationFrame(() => {
                                befriend.filters.updateSecondaryPosition(section_el, options_el);
                                befriend.filters.updateSectionHeights();
                            });

                        } catch (e) {
                            console.error('Error updating secondary:', e);
                        } finally {
                            befriend.toggleSpinner(false);
                        }
                    });
                }
            }
        }
    },
    music: {
        key: 'music',
        data: {
            tableKey: null,
            tabs: [
                { key: 'genres', col: 'music_genre_id', name: 'Genres', singular: 'Genre' },
                { key: 'artists', col: 'music_artist_id', name: 'Artists', singular: 'Artist' },
            ],
            categories: {}
        },
        init: function () {
            if(this?.data.tabs?.length) {
                if(!this.data.tableKey) {
                    this.data.tableKey = this.data.tabs[0].key;
                }
            }

            let section = befriend.filters.sections[this.key];

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');
            const sectionData = befriend.filters.data.options?.[this.key];

            let categories_html = '';
            if (sectionData?.options.length > 0) {
                categories_html = `
                    <div class="category-btn mine active" data-category="mine">
                        My Filters
                    </div>`;

                for (let category of sectionData.categories.options) {
                    let heading_html = '';

                    if(category.heading) {
                        heading_html = `<div class="heading">${category.heading}</div>`;
                    }

                    categories_html += `
                        <div class="category-btn ${heading_html ? 'w-heading' : ''}" 
                             ${category.table_key ? `data-table-key="${category.table_key}"` : ''} 
                             data-category="${category.name?.toLowerCase()}"
                             ${category.token ? `data-category-token="${category.token}"` : ''}>
                            <div class="heading-name">
                                ${heading_html}
                                <div class="name">${category.name}</div>
                            </div>
                        </div>`;
                }
            }

            const html = `
                <div class="filter-options-container">
                    <div class="filter-option" data-filter-token="${section.token}">
                        <div class="search-container">
                            <div class="autocomplete-container">
                                <div class="input-container">
                                    <input type="text" class="search-input" 
                                           placeholder="${sectionData?.autoComplete?.placeholders?.main || 'Search music'}">
                                    <div class="search-icon-container">
                                        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 611.9975 612.0095">
                                            <path d="M606.203,578.714l-158.011-155.486c41.378-44.956,66.802-104.411,66.802-169.835-.02-139.954-115.296-253.393-257.507-253.393S0,113.439,0,253.393s115.276,253.393,257.487,253.393c61.445,0,117.801-21.253,162.068-56.586l158.624,156.099c7.729,7.614,20.277,7.614,28.006,0,7.747-7.613,7.747-19.971.018-27.585ZM257.487,467.8c-120.326,0-217.869-95.993-217.869-214.407S137.161,38.986,257.487,38.986s217.869,95.993,217.869,214.407-97.542,214.407-217.869,214.407Z"/>
                                        </svg>
                                    </div>
                                </div>
                                <div class="autocomplete-list"></div>
                            </div>
                        </div>
            
                        ${categories_html ? `
                            <div class="categories-container">
                                <div class="category-filters">${categories_html}</div>
                            </div>
                        ` : ''}
            
                        <div class="items-container">
                            <div class="items cols-2"></div>
                        </div>
                        
                        <div class="secondary-container"></div>
                    </div>
                </div>
            `;

            section_el.querySelector('.section-container')
                .insertAdjacentHTML(
                    'afterbegin',
                    befriend.filters.sendReceiveHtml(true, true, true)
                );

            filter_options.innerHTML = html;

            let items = this.getStoredItems();

            this.addTabs();

            requestAnimationFrame(() => {
                befriend.filters[this.key].renderItems(section_el, items, true);
                befriend.filters.updateSectionHeights();
            });
        },
        addTabs: function () {
            if(!this.data?.tabs?.length) {
                return;
            }

            let section = befriend.filters.sections[this.key];
            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

            let html = ``;

            for(let i = 0; i < this.data.tabs.length; i++) {
                let tab = this.data.tabs[i];

                html += `<div class="tab ${i === 0 ? 'active' : ''}" data-key="${tab.key}">
                            <div class="name-count">
                                <div class="name">${tab.name}</div>
                            </div>
                        </div>`
            }

            let tabs_html = `<div class="tabs-container">${html}</div>`;

            let categories_container = section_el.querySelector('.categories-container');

            categories_container.insertAdjacentHTML('afterend', tabs_html);

            this.events.tabs();
        },
        getStoredFilter: function () {
            return befriend.filters.data.filters?.[this.key];
        },
        getStoredItems: function () {
            let items = [];

            const storedFilters = this.getStoredFilter();

            if (storedFilters?.items) {
                items = Object.values(storedFilters.items)
                    .filter(item => item.table_key === this.data.tableKey)
                    .filter(item => !item.deleted)
                    .filter(Boolean);
            }

            return items;
        },
        getKeyCol: function (key) {
            return befriend.filters[this.key].data?.tabs?.[key]?.col;
        },
        renderItems: function(section_el, items, is_mine, tableKey) {
            if(!tableKey) {
                tableKey = this.getTableKey();
            }

            let tab = this.data.tabs.find(tab => tab.key === tableKey);

            const storedFilters = this.getStoredFilter();

            const sectionData = befriend.filters.data.options?.[this.key];
            const items_container = section_el.querySelector('.items');

            let items_html = '';

            if (is_mine) {
                const hasActiveNonDeletedItems = storedFilters?.items &&
                    Object.values(storedFilters.items)
                        .filter(item => item.table_key === tableKey)
                        .some(item => !item.deleted && item.is_active);

                items_html = `
            <div class="item any ${!hasActiveNonDeletedItems ? 'active' : ''}" data-token="any">
                <div class="name">Any ${tab.singular}</div>
            </div>`;
            }

            let added_item_tokens = {};

            let tableCol = this.getKeyCol(this.data.tableKey);

            if (storedFilters?.items) {
                for(let k in storedFilters.items) {
                    let item = storedFilters.items[k];

                    if(!item.deleted && item.is_active) {
                        let option = sectionData?.options.find(opt => opt.id === item[tableCol]);

                        if(option) {
                            added_item_tokens[option.token] = item;
                        }
                    }
                }
            }

            if (items?.length) {
                items_html += items.map(item => {
                    if (is_mine) {
                        const storedItem = Object.values(storedFilters?.items || {})
                            .find(stored => stored.token === item.token);
                        const isActive = storedItem && !storedItem.deleted && storedItem.is_active;

                        return `
                    <div class="item mine ${isActive ? 'active': ''}" data-id="${storedItem?.id}" data-token="${item.token}" data-table-key="${tableKey}">
                        <div class="content">
                            <div class="name">${item.name}</div>
                            
                            <div class="remove">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 56 56">
                                    <path d="M28,0C12.5605,0,0,12.5605,0,28s12.5605,28,28,28,28-12.5605,28-28S43.4395,0,28,0ZM28,53c-13.7852,0-25-11.2148-25-25S14.2148,3,28,3s25,11.2148,25,25-11.2148,25-25,25ZM39.2627,16.7373c-.5859-.5859-1.5352-.5859-2.1211,0l-9.1416,9.1416-9.1416-9.1416c-.5859-.5859-1.5352-.5859-2.1211,0-.5859.5854-.5859,1.5356,0,2.1211l9.1416,9.1416-9.1416,9.1416c-.5859.5854-.5859,1.5356,0,2.1211.293.293.6768.4395,1.0605.4395s.7676-.1465,1.0605-.4395l9.1417-9.1416,9.1416,9.1416c.293.293.6768.4395,1.0605.4395s.7676-.1465,1.0605-.4395c.5859-.5854.5859-1.5356,0-2.1211l-9.1415-9.1416,9.1416-9.1416c.5859-.5855.5859-1.5356,0-2.1211Z"/>
                                </svg>
                            </div>
                        </div>
                    </div>`;
                    }

                    if(item.token in added_item_tokens) {
                        return;
                    }

                    return `
                <div class="item" data-token="${item.token}" data-table-key="${tableKey}">
                    <div class="name">${item.name}</div>
                </div>`;
                }).join('');
            }

            items_container.innerHTML = items_html;

            if(is_mine) {
                addClassEl('show-tabs', section_el);
                this.updateTabCount(section_el);
            } else {
                removeClassEl('show-tabs', section_el);
            }

            this.events.init();

            befriend.filters.importance.set();
        },
        updateTabCount: function(section_el) {
            const storedFilters = this.getStoredFilter();
            const tabs = section_el.querySelectorAll('.tab');

            for(let tab of tabs) {
                const key = tab.getAttribute('data-key');

                const count = Object.values(storedFilters?.items || {})
                    .filter(item => item.table_key === key && !item.deleted && item.is_active)
                    .length;

                const countEl = tab.querySelector('.count');

                if (count > 0) {
                    if (countEl) {
                        countEl.textContent = count;
                    } else {
                        const countHtml = `<div class="count">${count}</div>`;
                        tab.insertAdjacentHTML('beforeend', countHtml);
                    }
                } else if (countEl) {
                    countEl.remove();
                }
            }
        },
        addItem: async function(itemData = {}, section_el) {
            try {
                let {token, tableKey} = itemData;
                befriend.toggleSpinner(true);

                const section = befriend.filters.sections[this.key];
                const sectionData = befriend.filters.data.options?.[this.key];
                const category_mine = section_el.querySelector(`.category-btn.mine`);

                if(!tableKey) {
                    tableKey = this.getTableKey(token);
                }

                this.data.tableKey = tableKey;

                let response = await befriend.auth.put(section.endpoint, {
                    table_key: tableKey,
                    token,
                    active: true
                });

                let id = response?.data?.id;

                // Get current mine items
                const storedFilters = this.getStoredFilter();

                if (!storedFilters?.items) {
                    befriend.filters.data.filters[this.key] = {
                        items: {}
                    }
                }

                let option = sectionData?.options.find(opt => opt.token === token);

                let tableCol = this.getKeyCol(tableKey);

                befriend.filters.data.filters[this.key].items[id] = {
                    id,
                    token,
                    table_key: tableKey,
                    [tableCol]: option.id,
                    name: option.name,
                    is_active: true,
                }

                // Switch to mine category and show updated items
                fireClick(category_mine);

                //Select correct tab
                let tabs_els = section_el.getElementsByClassName('tab');

                for(let tab of tabs_els) {
                    if(tab.getAttribute('data-key') === tableKey && !elHasClass(tab, 'active')) {
                        fireClick(tab);
                    }
                }

                requestAnimationFrame(() => {
                    befriend.filters.updateSectionHeights();
                });

                befriend.toggleSpinner(false);
                return true;
            } catch (e) {
                console.error('Error adding instrument:', e);
                befriend.toggleSpinner(false);
                return false;
            }
        },
        toggleAutocomplete: function(show) {
            let section = befriend.filters.sections[this.key];
            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

            const autocomplete_container = section_el.querySelector('.autocomplete-container');
            const autocomplete_list = section_el.querySelector('.autocomplete-list');

            if (!autocomplete_list) return;

            if (show) {
                addClassEl('autocomplete-shown', autocomplete_container);

                // Reset scroll position
                autocomplete_list.scrollTop = 0;

                // Ensure input stays focused
                const search_input = section_el.querySelector('.search-input');
                if (search_input) search_input.focus();
            } else {
                removeClassEl('autocomplete-shown', autocomplete_container);
            }
        },
        getTableKey: function (token) {
            const sectionData = befriend.filters.data.options?.[this.key];
            return sectionData?.options.find(item => item.token === token)?.table_key || this.data.tableKey;
        },
        getActiveCategory: function () {
            let section_el = befriend.els.filters.querySelector(`.section.${this.key}`);

            return section_el.querySelector(`.category-btn.active`);
        },
        getCategoryByName: function (name) {
            name = name?.trim().toLowerCase();

            const sectionData = befriend.filters.data.options?.[this.key];

            if(sectionData?.categories?.options) {
                for(let category of sectionData.categories.options) {
                    if(category.name.toLowerCase() === name) {
                        return category;
                    }
                }
            }
        },
        events: {
            key: 'music',
            init: function () {
                this.search();
                this.categories();
                this.items();
                this.remove();
            },
            tabs: function () {
                let section_key = this.key;
                let section = befriend.filters.sections[section_key];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let tabs_els = section_el.querySelector('.tabs-container').getElementsByClassName('tab');

                for(let tab of tabs_els) {
                    if(tab._listener) {
                        continue;
                    }

                    tab._listener = true;

                    tab.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();

                        if(elHasClass(tab, 'active')) {
                            return;
                        }

                        let key = tab.getAttribute('data-key');

                        befriend.filters[section_key].data.tableKey = key;

                        removeElsClass(tabs_els, 'active');

                        addClassEl('active', tab);

                        befriend.filters[section_key].renderItems(section_el, befriend.filters[section_key].getStoredItems(), true);

                        requestAnimationFrame(function () {
                            befriend.filters.updateSectionHeights();
                        })
                    });
                }
            },
            search: function () {
                let section_key = this.key;
                let section = befriend.filters.sections[section_key];
                const sectionData = befriend.filters.data.options?.[section_key];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                const search_input = section_el.querySelector('.search-input');
                const input_container = section_el.querySelector('.input-container');
                const autocomplete_list = section_el.querySelector('.autocomplete-list');

                let debounceTimer;

                if (search_input) {
                    if(search_input._listener) {
                        return;
                    }

                    search_input._listener = true;

                    search_input.addEventListener('input', () => {
                        clearTimeout(debounceTimer);

                        let timeout = this.value ? 200 : 0;

                        debounceTimer = setTimeout(async () => {
                            const value = search_input.value.trim();
                            if (value.length < sectionData.autoComplete.minChars) {
                                befriend.filters[section_key].toggleAutocomplete(false);
                                return;
                            }

                            let name = befriend.filters[section_key].getActiveCategory()?.getAttribute('data-category');

                            let category = befriend.filters[section_key].getCategoryByName(name);

                            console.log(category)

                            try {
                                const response = await befriend.auth.get(sectionData.autoComplete.endpoint, {
                                    search: value,
                                    category: category
                                });

                                if (response.data.items?.length) {
                                    //merge results with options
                                    for(let item of response.data.items) {
                                        let existing_option = sectionData?.options.find(existing => existing.token === item.token);

                                        if(!existing_option) {
                                            item._is_internal = true;
                                            sectionData.options.push(item);
                                        }
                                    }

                                    // Filter out items that already exist in filters data
                                    const existingTokens = new Set();

                                    const storedFilters = befriend.filters[section_key].getStoredFilter();

                                    if (storedFilters?.items) {
                                        for (let k in storedFilters.items) {
                                            const item = storedFilters.items[k];
                                            if (!item.deleted) {
                                                let option = sectionData?.options.find(opt => opt.token === item.token);

                                                if (option) {
                                                    existingTokens.add(option.token);
                                                }
                                            }
                                        }
                                    }

                                    const filteredItems = response.data.items.filter(item => !existingTokens.has(item.token));

                                    if (filteredItems.length) {
                                        const items_html = filteredItems.map(item => `
                                        <div class="item" data-id="${item.id}" data-token="${item.token}">
                                            <div class="name-meta">
                                                <div class="name">${item.name}</div>
                                            </div>
                                        </div>
                                        `).join('');

                                        autocomplete_list.innerHTML = items_html;
                                        befriend.filters[section_key].toggleAutocomplete(true);
                                    } else {
                                        autocomplete_list.innerHTML = '<div class="no-results">No results found</div>';
                                        befriend.filters[section_key].toggleAutocomplete(true);
                                    }
                                } else {
                                    autocomplete_list.innerHTML = '<div class="no-results">No results found</div>';
                                    befriend.filters[section_key].toggleAutocomplete(true);
                                }
                            } catch (e) {
                                console.error(`Error searching ${section_key}:`, e);
                            }
                        }, timeout);
                    });

                    autocomplete_list.addEventListener('click', async (e) => {
                        const item = e.target.closest('.item');
                        if (!item) return;

                        const id = item.getAttribute('data-id');
                        const token = item.getAttribute('data-token');

                        if (await befriend.filters[section_key].addItem({
                            id,
                            token,
                        }, section_el)) {
                            // Close autocomplete and clear input
                            befriend.filters[section_key].toggleAutocomplete(false);
                            search_input.value = '';
                        }
                    });

                    // Focus/blur handling
                    search_input.addEventListener('focus', () => {
                        addClassEl('input-focus', input_container);

                        const value = search_input.value.trim();
                        if (value.length >= sectionData.autoComplete.minChars) {
                            befriend.filters[section_key].toggleAutocomplete(true);
                        }
                    });

                    search_input.addEventListener('blur', () => {
                        removeClassEl('input-focus', input_container);

                        setTimeout(function () {
                            befriend.filters[section_key].toggleAutocomplete(false);
                        }, 100);
                    });
                }
            },
            categories: function () {
                let section_key = this.key;
                let section = befriend.filters.sections[section_key];
                const sectionData = befriend.filters.data.options?.[section_key];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                const category_btns = section_el.querySelectorAll('.category-btn');

                for (let btn of category_btns) {
                    if(btn._listener) {
                        continue;
                    }

                    btn._listener = true;

                    btn.addEventListener('click', async () => {
                        removeElsClass(category_btns, 'active');
                        addClassEl('active', btn);

                        let category = btn.getAttribute('data-category')?.toLowerCase().trim();
                        let category_token = btn.getAttribute('data-category-token')?.trim();

                        try {
                            let added_item_tokens = new Set();

                            const storedFilters = befriend.filters[section_key].getStoredFilter();

                            if(storedFilters?.items) {
                                for(let k in storedFilters.items) {
                                    let item = storedFilters.items[k];

                                    if(!item.deleted) {
                                        added_item_tokens.add(item.token);
                                    }
                                }
                            }

                            let items;

                            let categoryTableKey = null;

                            if (category === 'mine') {
                                let table_key = befriend.filters[section_key].getTableKey();

                                items = Object.values(storedFilters?.items || {})
                                    .filter(item => item.table_key === table_key)
                                    .filter(item => !item.deleted)
                                    .filter(Boolean);
                            } else {
                                categoryTableKey = btn.getAttribute('data-table-key');

                                // 1. find in category cache
                                items = befriend.filters[section_key]?.data?.categories[category_token];

                                //2. (or) find in section data
                                if(!items?.length) {
                                    items = sectionData?.options
                                        .filter(
                                            item => category_token ? item.category_token === category_token : item.category?.toLowerCase() === category
                                        )
                                        .filter(item => !added_item_tokens.has(item.token))
                                        .filter(item => !item._is_internal);
                                }

                                //3. (or) dynamic endpoint data
                                if(!items?.length) {
                                    befriend.toggleSpinner(true);

                                    let data = await befriend.me.getCategoryOptions(
                                        sectionData.categories.endpoint,
                                        category_token,
                                    );

                                    items = data.items;

                                    //add items to options for lookup
                                    for(let item of data.items) {
                                        let existing_option = sectionData?.options.find(existing => existing.token === item.token);

                                        if(!existing_option) {
                                            sectionData.options.push(item);
                                        }
                                    }

                                    befriend.toggleSpinner(false);

                                    befriend.filters[section_key].data.categories[category_token] = items;
                                }
                            }

                            befriend.filters[section_key].renderItems(section_el, items || [], category === 'mine', categoryTableKey);

                            requestAnimationFrame(() => {
                                befriend.filters.updateSectionHeights();
                            });
                        } catch (e) {
                            console.error(`Error loading ${section_key}:`, e);
                        }
                    });
                }
            },
            items: function () {
                let section_key = this.key;
                let section = befriend.filters.sections[section_key];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let items_els = section_el.getElementsByClassName('item');

                for(let item of items_els) {
                    if(item._listener) {
                        continue;
                    }

                    item._listener = true;

                    item.addEventListener('click', async (e) => {
                        if(e.target.closest('.secondary-container')) {
                            return false;
                        }

                        e.preventDefault();
                        e.stopPropagation();

                        let token = item.getAttribute('data-token');
                        let tableKey = item.getAttribute('data-table-key');

                        let wasSelected = elHasClass(item, 'active');

                        //any selection
                        if (elHasClass(item, 'any')) {
                            if(wasSelected) {
                                return;
                            }

                            try {
                                befriend.toggleSpinner(true);

                                if(!tableKey) {
                                    tableKey = befriend.filters[section_key].getTableKey();
                                }

                                await befriend.auth.put(section.endpoint, {
                                    table_key: tableKey,
                                    token: 'any',
                                    active: true
                                });

                                const anyButton = item;
                                const otherItems = section_el.querySelectorAll('.item:not(.any)');

                                addClassEl('active', anyButton);

                                for(let otherItem of otherItems) {
                                    const storedItem = Object.values(befriend.filters.data.filters?.[section_key]?.items || {})
                                        .find(item => item.id === parseInt(otherItem.getAttribute('data-id')));

                                    if (storedItem && storedItem.table_key === tableKey) {
                                        removeClassEl('active', otherItem);
                                    }
                                }

                                //update state data
                                if(befriend.filters.data.filters?.[section_key]?.items) {
                                    for(let k in befriend.filters.data.filters[section_key].items) {
                                        let item = befriend.filters.data.filters[section_key].items[k];
                                        if(item.table_key === tableKey) {
                                            item.is_active = false;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Error setting any instrument:', e);
                            }

                            befriend.toggleSpinner(false);

                            befriend.filters[section_key].updateTabCount(section_el);

                            return;
                        } //end any

                        //my filter item selection
                        if (elHasClass(item, 'mine')) {
                            toggleElClass(item, 'active');

                            try {
                                befriend.toggleSpinner(true);

                                console.log(tableKey);

                                if(!tableKey) {
                                    tableKey = befriend.filters[section_key].getTableKey(token);
                                }

                                await befriend.auth.put(section.endpoint, {
                                    table_key: tableKey,
                                    token,
                                    active: !wasSelected,
                                });

                                const activeItems = Array.from(section_el.querySelectorAll('.item.mine.active'))
                                    .filter(item => {
                                        const storedItem = Object.values(befriend.filters.data.filters?.[section_key]?.items || {})
                                            .find(stored => stored.id === parseInt(item.getAttribute('data-id')));
                                        return storedItem && storedItem.table_key === tableKey;
                                    });

                                const anyButton = section_el.querySelector('.item.any');

                                if(anyButton) {
                                    if (activeItems.length === 0) {
                                        addClassEl('active', anyButton);
                                    } else {
                                        removeClassEl('active', anyButton);
                                    }
                                }

                                //update state data
                                if(befriend.filters.data.filters?.[section_key].items) {
                                    for(let k in befriend.filters.data.filters[section_key].items) {
                                        if(befriend.filters.data.filters[section_key].items[k].token === token) {
                                            befriend.filters.data.filters[section_key].items[k].is_active = !wasSelected;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Error removing instrument:', e);
                            }

                            befriend.toggleSpinner(false);

                            befriend.filters[section_key].updateTabCount(section_el);

                            return;
                        }

                        //select category item option
                        try {
                            // Remove item from current view
                            item.remove();

                            //add item to server/my filters
                            await befriend.filters[section_key].addItem({ token, tableKey }, section_el);
                        } catch (e) {
                            console.error('Error adding instrument:', e);
                        }
                    });
                }
            },
            remove: function () {
                let section_key = this.key;
                let section = befriend.filters.sections[section_key];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let remove_els = section_el.querySelectorAll('.item .remove');

                for(let remove_el of remove_els) {
                    if(remove_el._listener) {
                        continue;
                    }

                    remove_el._listener = true;

                    remove_el.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        befriend.filters.hideActiveSecondaryIf();

                        let item = remove_el.closest('.item');

                        let token = item.getAttribute('data-token');

                        try {
                            befriend.toggleSpinner(true);

                            let tableKey = item.getAttribute('data-table-key');

                            if(!tableKey || true) {
                                tableKey = befriend.filters[section_key].getTableKey(token);
                            }

                            await befriend.auth.put(section.endpoint, {
                                table_key: tableKey,
                                token,
                                is_delete: true
                            });

                            // Remove item and update Any button if needed
                            item.remove();

                            const activeItems = section_el.querySelectorAll('.item.mine.active');

                            if (activeItems.length === 0) {
                                const anyButton = section_el.querySelector('.item.any');
                                if (anyButton) addClassEl('active', anyButton);
                            }

                            //update state data
                            if(befriend.filters.data.filters?.[section_key]?.items) {
                                for(let k in befriend.filters.data.filters[section_key].items) {
                                    if(befriend.filters.data.filters[section_key].items[k].token === token) {
                                        befriend.filters.data.filters[section_key].items[k].deleted = true;
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error removing instrument:', e);
                        }

                        befriend.toggleSpinner(false);

                        befriend.filters[section_key].updateTabCount(section_el);

                        requestAnimationFrame(function () {
                            befriend.filters.updateSectionHeights();
                        });
                    });
                }
            },
        }
    },
    work: {
        data: {
            tableKey: null,
            tabs: [
                { key: 'industries', col: 'work_industry_id', name: 'Industries', singular: 'Industry' },
                { key: 'roles', col: 'work_role_id', name: 'Roles', singular: 'Role' }
            ],
        },
        init: function () {
            if(this?.data.tabs?.length) {
                if(!this.data.tableKey) {
                    this.data.tableKey = this.data.tabs[0].key;
                }
            }

            let section = befriend.filters.sections.work;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');
            const sectionData = befriend.filters.data.options?.['work'];

            let categories_html = '';
            if (sectionData?.options.length > 0) {
                categories_html = `
            <div class="category-btn mine active" data-category="mine">My Filters</div>`;

                for (let category of sectionData.categories.options) {
                    let heading_html = '';

                    if(category.heading) {
                        heading_html = `<div class="heading">${category.heading}</div>`;
                    }

                    categories_html += `
                <div class="category-btn ${heading_html ? 'w-heading' : ''}" data-category="${category.name?.toLowerCase()} ${category.token ? `data-category-token="${category.token}"` : ''}" 
                     ${category.token ? `data-category-token="${category.token}"` : ''}>
                    <div class="heading-name">
                        ${heading_html}
                        <div class="name">${category.name}</div>
                    </div>
                </div>`;
                }
            }

            const html = `
                <div class="filter-options-container">
                    <div class="filter-option" data-filter-token="${section.token}">
                        <div class="search-container">
                            <div class="autocomplete-container">
                                <div class="input-container">
                                    <input type="text" class="search-input" 
                                           placeholder="${sectionData?.autoComplete?.placeholders?.main || 'Search work'}">
                                    <div class="search-icon-container">
                                        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 611.9975 612.0095">
                                            <path d="M606.203,578.714l-158.011-155.486c41.378-44.956,66.802-104.411,66.802-169.835-.02-139.954-115.296-253.393-257.507-253.393S0,113.439,0,253.393s115.276,253.393,257.487,253.393c61.445,0,117.801-21.253,162.068-56.586l158.624,156.099c7.729,7.614,20.277,7.614,28.006,0,7.747-7.613,7.747-19.971.018-27.585ZM257.487,467.8c-120.326,0-217.869-95.993-217.869-214.407S137.161,38.986,257.487,38.986s217.869,95.993,217.869,214.407-97.542,214.407-217.869,214.407Z"/>
                                        </svg>
                                    </div>
                                </div>
                                <div class="autocomplete-list"></div>
                            </div>
                        </div>
            
                        ${categories_html ? `
                            <div class="categories-container">
                                <div class="category-filters">${categories_html}</div>
                            </div>
                        ` : ''}
            
                        <div class="items-container">
                            <div class="items cols-2"></div>
                        </div>
                        
                        <div class="secondary-container"></div>
                    </div>
                </div>
            `;

            section_el.querySelector('.section-container')
                .insertAdjacentHTML(
                    'afterbegin',
                    befriend.filters.sendReceiveHtml(true, true, true)
                );

            filter_options.innerHTML = html;

            let items = this.getStoredItems();

            this.addTabs();

            requestAnimationFrame(() => {
                befriend.filters.work.renderItems(section_el, items, true);
                befriend.filters.updateSectionHeights();
            });
        },
        getStoredFilter: function () {
            return befriend.filters.data.filters?.work;
        },
        getStoredItems: function () {
            let items = [];

            const storedFilters = this.getStoredFilter();

            if (storedFilters?.items) {
                items = Object.values(storedFilters.items)
                    .filter(item => item.table_key === this.data.tableKey)
                    .filter(item => !item.deleted)
                    .filter(Boolean);
            }

            return items;
        },
        getKeyCol: function (key) {
            return befriend.filters.work.data?.tabs?.[key]?.col;
        },
        renderItems: function(section_el, items, is_mine) {
            let tableKey = this.getTableKey();
            let tab = this.data.tabs.find(tab => tab.key === tableKey);
            
            const storedFilters = this.getStoredFilter();

            const sectionData = befriend.filters.data.options?.['work'];
            const items_container = section_el.querySelector('.items');

            let items_html = '';

            if (is_mine) {
                const hasActiveNonDeletedItems = storedFilters?.items &&
                    Object.values(storedFilters.items)
                        .filter(item => item.table_key === tableKey)
                        .some(item => !item.deleted && item.is_active);

                items_html = `
            <div class="item any ${!hasActiveNonDeletedItems ? 'active' : ''}" data-token="any">
                <div class="name">Any ${tab.singular}</div>
            </div>`;
            }

            let added_item_tokens = {};

            let tableCol = this.getKeyCol(this.data.tableKey);

            if (storedFilters?.items) {
                for(let k in storedFilters.items) {
                    let item = storedFilters.items[k];
                    
                    if(!item.deleted && item.is_active) {
                        let option = sectionData?.options.find(opt => opt.id === item[tableCol]);
                        
                        if(option) {
                            added_item_tokens[option.token] = item;
                        }
                    }
                }
            }

            if (items?.length) {
                items_html += items.map(item => {
                    if (is_mine) {
                        const storedItem = Object.values(storedFilters?.items || {})
                            .find(stored => stored.token === item.token);
                        const isActive = storedItem && !storedItem.deleted && storedItem.is_active;

                        return `
                    <div class="item mine ${isActive ? 'active': ''}" data-id="${storedItem?.id}" data-token="${item.token}">
                        <div class="content">
                            <div class="name">${item.name}</div>
                            
                            <div class="remove">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 56 56">
                                    <path d="M28,0C12.5605,0,0,12.5605,0,28s12.5605,28,28,28,28-12.5605,28-28S43.4395,0,28,0ZM28,53c-13.7852,0-25-11.2148-25-25S14.2148,3,28,3s25,11.2148,25,25-11.2148,25-25,25ZM39.2627,16.7373c-.5859-.5859-1.5352-.5859-2.1211,0l-9.1416,9.1416-9.1416-9.1416c-.5859-.5859-1.5352-.5859-2.1211,0-.5859.5854-.5859,1.5356,0,2.1211l9.1416,9.1416-9.1416,9.1416c-.5859.5854-.5859,1.5356,0,2.1211.293.293.6768.4395,1.0605.4395s.7676-.1465,1.0605-.4395l9.1417-9.1416,9.1416,9.1416c.293.293.6768.4395,1.0605.4395s.7676-.1465,1.0605-.4395c.5859-.5854.5859-1.5356,0-2.1211l-9.1415-9.1416,9.1416-9.1416c.5859-.5855.5859-1.5356,0-2.1211Z"/>
                                </svg>
                            </div>
                        </div>
                    </div>`;
                    }

                    if(item.token in added_item_tokens) {
                        return;
                    }

                    return `
                <div class="item" data-token="${item.token}">
                    <div class="name">${item.name}</div>
                </div>`;
                }).join('');
            }

            items_container.innerHTML = items_html;

            if(is_mine) {
                addClassEl('show-tabs', section_el);
                this.updateTabCount(section_el);
            } else {
                removeClassEl('show-tabs', section_el);
            }

            this.events.init();

            befriend.filters.importance.set();
        },
        addTabs: function () {
            if(!this.data?.tabs?.length) {
                return;
            }

            let section = befriend.filters.sections.work;
            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

            let html = ``;

            for(let i = 0; i < this.data.tabs.length; i++) {
                let tab = this.data.tabs[i];

                html += `<div class="tab ${i === 0 ? 'active' : ''}" data-key="${tab.key}">
                            <div class="name-count">
                                <div class="name">${tab.name}</div>
                            </div>
                        </div>`
            }

            let tabs_html = `<div class="tabs-container">${html}</div>`;

            let categories_container = section_el.querySelector('.categories-container');

            categories_container.insertAdjacentHTML('afterend', tabs_html);

            this.events.tabs();
        },
        updateTabCount: function(section_el) {
            const storedFilters = this.getStoredFilter();
            const tabs = section_el.querySelectorAll('.tab');

            for(let tab of tabs) {
                const key = tab.getAttribute('data-key');

                const count = Object.values(storedFilters?.items || {})
                    .filter(item => item.table_key === key && !item.deleted && item.is_active)
                    .length;

                const countEl = tab.querySelector('.count');

                if (count > 0) {
                    if (countEl) {
                        countEl.textContent = count;
                    } else {
                        const countHtml = `<div class="count">${count}</div>`;
                        tab.insertAdjacentHTML('beforeend', countHtml);
                    }
                } else if (countEl) {
                    countEl.remove();
                }
            }
        },
        addItem: async function(itemData = {}, section_el) {
            try {
                let {token} = itemData;
                befriend.toggleSpinner(true);

                const sectionData = befriend.filters.data.options?.['work'];
                const category_mine = section_el.querySelector(`.category-btn.mine`);

                let table_key = this.getTableKey(token);

                this.data.tableKey = table_key;

                let response = await befriend.auth.put('/filters/work', {
                    table_key,
                    token,
                    active: true
                });

                let id = response?.data?.id;

                // Get current mine items
                const storedFilters = this.getStoredFilter();

                if (!storedFilters?.items) {
                    befriend.filters.data.filters.work = {
                        items: {}
                    }
                }

                let option = sectionData?.options.find(opt => opt.token === token);

                let tableCol = this.getKeyCol(table_key);

                befriend.filters.data.filters.work.items[id] = {
                    id,
                    token,
                    table_key: table_key,
                    [tableCol]: option.id,
                    name: option.name,
                    is_active: true,
                }

                // Switch to mine category and show updated items
                fireClick(category_mine);

                //Select correct tab
                let tabs_els = section_el.getElementsByClassName('tab');

                for(let tab of tabs_els) {
                    if(tab.getAttribute('data-key') === table_key && !elHasClass(tab, 'active')) {
                        fireClick(tab);
                    }
                }

                requestAnimationFrame(() => {
                    befriend.filters.updateSectionHeights();
                });

                befriend.toggleSpinner(false);
                return true;
            } catch (e) {
                console.error('Error adding instrument:', e);
                befriend.toggleSpinner(false);
                return false;
            }
        },
        toggleAutocomplete: function(show) {
            let section = befriend.filters.sections.work;
            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

            const autocomplete_container = section_el.querySelector('.autocomplete-container');
            const autocomplete_list = section_el.querySelector('.autocomplete-list');

            if (!autocomplete_list) return;

            if (show) {
                addClassEl('autocomplete-shown', autocomplete_container);

                // Reset scroll position
                autocomplete_list.scrollTop = 0;

                // Ensure input stays focused
                const search_input = section_el.querySelector('.search-input');
                if (search_input) search_input.focus();
            } else {
                removeClassEl('autocomplete-shown', autocomplete_container);
            }
        },
        getTableKey: function (token) {
            const sectionData = befriend.filters.data.options?.['work'];
            return sectionData?.options.find(item => item.token === token)?.table_key || this.data.tableKey;
        },
        events: {
            init: function () {
                this.search();
                this.categories();
                this.items();
                this.remove();
            },
            tabs: function () {
                let section = befriend.filters.sections.work;
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let tabs_els = section_el.querySelector('.tabs-container').getElementsByClassName('tab');

                for(let tab of tabs_els) {
                    if(tab._listener) {
                        continue;
                    }

                    tab._listener = true;

                    tab.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();

                        if(elHasClass(tab, 'active')) {
                            return;
                        }

                        let key = tab.getAttribute('data-key');

                        befriend.filters.work.data.tableKey = key;

                        removeElsClass(tabs_els, 'active');

                        addClassEl('active', tab);

                        befriend.filters.work.renderItems(section_el, befriend.filters.work.getStoredItems(), true);

                        requestAnimationFrame(function () {
                            befriend.filters.updateSectionHeights();
                        })
                    });
                }
            },
            search: function () {
                let section = befriend.filters.sections.work;
                const sectionData = befriend.filters.data.options?.['work'];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                const search_input = section_el.querySelector('.search-input');
                const input_container = section_el.querySelector('.input-container');
                const autocomplete_list = section_el.querySelector('.autocomplete-list');

                let debounceTimer;

                if (search_input) {
                    if(search_input._listener) {
                        return;
                    }

                    search_input._listener = true;

                    search_input.addEventListener('input', () => {
                        clearTimeout(debounceTimer);

                        let timeout = this.value ? 200 : 0;

                        debounceTimer = setTimeout(async () => {
                            const value = search_input.value.trim();
                            if (value.length < sectionData.autoComplete.minChars) {
                                befriend.filters.work.toggleAutocomplete(false);
                                return;
                            }

                            try {
                                const response = await befriend.auth.get(sectionData.autoComplete.endpoint, {
                                    search: value
                                });

                                if (response.data.items?.length) {
                                    //merge results with options
                                    for(let item of response.data.items) {
                                        let existing_option = sectionData?.options.find(existing => existing.token === item.token);

                                        if(!existing_option) {
                                            item._is_internal = true;
                                            sectionData.options.push(item);
                                        }
                                    }

                                    // Filter out items that already exist in filters data
                                    const existingTokens = new Set();

                                    const storedFilters = befriend.filters.work.getStoredFilter();

                                    if (storedFilters?.items) {
                                        for (let k in storedFilters.items) {
                                            const item = storedFilters.items[k];
                                            if (!item.deleted) {
                                                let option = sectionData?.options.find(opt => opt.token === item.token);

                                                if (option) {
                                                    existingTokens.add(option.token);
                                                }
                                            }
                                        }
                                    }

                                    const filteredItems = response.data.items.filter(item => !existingTokens.has(item.token));

                                    if (filteredItems.length) {
                                        const items_html = filteredItems.map(item => `
                                        <div class="item" data-id="${item.id}" data-token="${item.token}">
                                            <div class="name-meta">
                                                <div class="name">${item.name}</div>
                                            </div>
                                        </div>
                                        `).join('');

                                        autocomplete_list.innerHTML = items_html;
                                        befriend.filters.work.toggleAutocomplete(true);
                                    } else {
                                        autocomplete_list.innerHTML = '<div class="no-results">No results found</div>';
                                        befriend.filters.work.toggleAutocomplete(true);
                                    }
                                } else {
                                    autocomplete_list.innerHTML = '<div class="no-results">No results found</div>';
                                    befriend.filters.work.toggleAutocomplete(true);
                                }
                            } catch (e) {
                                console.error('Error searching work:', e);
                            }
                        }, timeout);
                    });

                    autocomplete_list.addEventListener('click', async (e) => {
                        const item = e.target.closest('.item');
                        if (!item) return;

                        const id = item.getAttribute('data-id');
                        const token = item.getAttribute('data-token');

                        if (await befriend.filters.work.addItem({
                            id,
                            token,
                        }, section_el)) {
                            // Close autocomplete and clear input
                            befriend.filters.work.toggleAutocomplete(false);
                            search_input.value = '';
                        }
                    });

                    // Focus/blur handling
                    search_input.addEventListener('focus', () => {
                        addClassEl('input-focus', input_container);

                        const value = search_input.value.trim();
                        if (value.length >= sectionData.autoComplete.minChars) {
                            befriend.filters.work.toggleAutocomplete(true);
                        }
                    });

                    search_input.addEventListener('blur', () => {
                        removeClassEl('input-focus', input_container);

                        setTimeout(function () {
                            befriend.filters.work.toggleAutocomplete(false);
                        }, 100);
                    });
                }
            },
            categories: function () {
                let section = befriend.filters.sections.work;
                const sectionData = befriend.filters.data.options?.['work'];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                const category_btns = section_el.querySelectorAll('.category-btn');

                for (let btn of category_btns) {
                    if(btn._listener) {
                        continue;
                    }

                    btn._listener = true;

                    btn.addEventListener('click', async () => {
                        removeElsClass(category_btns, 'active');
                        addClassEl('active', btn);

                        let category = btn.getAttribute('data-category')?.toLowerCase().trim();
                        let category_token = btn.getAttribute('data-category-token')?.trim();

                        try {
                            let added_item_tokens = new Set();

                            const storedFilters = befriend.filters.work.getStoredFilter();

                            if(storedFilters?.items) {
                                for(let k in storedFilters.items) {
                                    let item = storedFilters.items[k];

                                    if(!item.deleted) {
                                        added_item_tokens.add(item.token);
                                    }
                                }
                            }

                            let items;

                            if (category === 'mine') {
                                let table_key = befriend.filters.work.getTableKey();

                                items = Object.values(storedFilters?.items || {})
                                    .filter(item => item.table_key === table_key)
                                    .filter(item => !item.deleted)
                                    .filter(Boolean);
                            } else {
                                items = sectionData?.options
                                    .filter(
                                        item => category_token ? item.category_token === category_token : item.category?.toLowerCase() === category
                                    )
                                    .filter(item => !added_item_tokens.has(item.token))
                                    .filter(item => !item._is_internal);
                            }

                            befriend.filters.work.renderItems(section_el, items || [], category === 'mine');

                            requestAnimationFrame(() => {
                                befriend.filters.updateSectionHeights();
                            });
                        } catch (e) {
                            console.error('Error loading work:', e);
                        }
                    });
                }
            },
            items: function () {
                let section = befriend.filters.sections.work;
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let items_els = section_el.getElementsByClassName('item');

                for(let item of items_els) {
                    if(item._listener) {
                        continue;
                    }

                    item._listener = true;

                    item.addEventListener('click', async (e) => {
                        if(e.target.closest('.secondary-container')) {
                            return false;
                        }

                        e.preventDefault();
                        e.stopPropagation();

                        //hide if any section secondary is open
                        let token = item.getAttribute('data-token');

                        let wasSelected = elHasClass(item, 'active');

                        if (elHasClass(item, 'any')) {
                            if(wasSelected) {
                                return;
                            }

                            try {
                                befriend.toggleSpinner(true);

                                let tableKey = befriend.filters.work.getTableKey();

                                await befriend.auth.put('/filters/work', {
                                    table_key: tableKey,
                                    token: 'any',
                                    active: true
                                });

                                const anyButton = item;
                                const otherItems = section_el.querySelectorAll('.item:not(.any)');

                                addClassEl('active', anyButton);

                                for(let otherItem of otherItems) {
                                    const storedItem = Object.values(befriend.filters.data.filters?.work?.items || {})
                                        .find(item => item.id === parseInt(otherItem.getAttribute('data-id')));

                                    if (storedItem && storedItem.table_key === tableKey) {
                                        removeClassEl('active', otherItem);
                                    }
                                }

                                //update state data
                                if(befriend.filters.data.filters?.work?.items) {
                                    for(let k in befriend.filters.data.filters.work.items) {
                                        let item = befriend.filters.data.filters.work.items[k];
                                        if(item.table_key === tableKey) {
                                            item.is_active = false;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Error setting any instrument:', e);
                            }

                            befriend.toggleSpinner(false);

                            befriend.filters.work.updateTabCount(section_el);

                            return;
                        }

                        if (elHasClass(item, 'mine')) {
                            toggleElClass(item, 'active');

                            try {
                                befriend.toggleSpinner(true);

                                let tableKey = befriend.filters.work.getTableKey(token);

                                await befriend.auth.put('/filters/work', {
                                    table_key: tableKey,
                                    token,
                                    active: !wasSelected,
                                });

                                const activeItems = Array.from(section_el.querySelectorAll('.item.mine.active'))
                                    .filter(item => {
                                        const storedItem = Object.values(befriend.filters.data.filters?.work?.items || {})
                                            .find(stored => stored.id === parseInt(item.getAttribute('data-id')));
                                        return storedItem && storedItem.table_key === tableKey;
                                    });

                                const anyButton = section_el.querySelector('.item.any');

                                if(anyButton) {
                                    if (activeItems.length === 0) {
                                        addClassEl('active', anyButton);
                                    } else {
                                        removeClassEl('active', anyButton);
                                    }
                                }

                                //update state data
                                if(befriend.filters.data.filters?.work.items) {
                                    for(let k in befriend.filters.data.filters.work.items) {
                                        if(befriend.filters.data.filters.work.items[k].token === token) {
                                            befriend.filters.data.filters.work.items[k].is_active = !wasSelected;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Error removing instrument:', e);
                            }

                            befriend.toggleSpinner(false);

                            befriend.filters.work.updateTabCount(section_el);

                            return;
                        }

                        //select category item option
                        try {
                            // Remove item from current view
                            item.remove();

                            //add item to server/my filters
                            await befriend.filters.work.addItem({ token }, section_el);
                        } catch (e) {
                            console.error('Error adding instrument:', e);
                        }
                    });
                }
            },
            remove: function () {
                let section = befriend.filters.sections.work;
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let remove_els = section_el.querySelectorAll('.item .remove');

                for(let remove_el of remove_els) {
                    if(remove_el._listener) {
                        continue;
                    }

                    remove_el._listener = true;

                    remove_el.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        befriend.filters.hideActiveSecondaryIf();

                        let item = remove_el.closest('.item');

                        let token = item.getAttribute('data-token');

                        try {
                            befriend.toggleSpinner(true);

                            let tableKey = befriend.filters.work.getTableKey(token);

                            await befriend.auth.put('/filters/work', {
                                table_key: tableKey,
                                token,
                                is_delete: true
                            });

                            // Remove item and update Any button if needed
                            item.remove();

                            const activeItems = section_el.querySelectorAll('.item.mine.active');

                            if (activeItems.length === 0) {
                                const anyButton = section_el.querySelector('.item.any');
                                if (anyButton) addClassEl('active', anyButton);
                            }

                            //update state data
                            if(befriend.filters.data.filters?.work?.items) {
                                for(let k in befriend.filters.data.filters.work.items) {
                                    if(befriend.filters.data.filters.work.items[k].token === token) {
                                        befriend.filters.data.filters.work.items[k].deleted = true;
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error removing instrument:', e);
                        }

                        befriend.toggleSpinner(false);

                        befriend.filters.work.updateTabCount(section_el);

                        requestAnimationFrame(function () {
                            befriend.filters.updateSectionHeights();
                        });
                    });
                }
            },
        }
    },
    sortSecondary: function (originalArr, currentArr) {
        if (!Array.isArray(originalArr) || !Array.isArray(currentArr)) {
            return currentArr;
        }

        return [...currentArr].sort((a, b) => {
            // Keep 'any' at the start if it exists
            if (a === 'any') return -1;
            if (b === 'any') return 1;

            // Get indices from original array
            const indexA = originalArr.indexOf(a);
            const indexB = originalArr.indexOf(b);

            // Keep items not found in original array at the end
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;

            return indexA - indexB;
        });
    },
    initSections: async function () {
        return new Promise(async (resolve, reject) => {
            try {
                let sections_el = befriend.els.filters.querySelector('.sections');

                let html = '';

                for (let key in this.sections) {
                    let section = this.sections[key];

                    let collapsed_class = this.data.collapsed[key] ? 'collapsed' : '';
                    let interest_class = section.is_interest ? 'is_interest' : '';

                    html += `<div class="section ${section.token} ${interest_class} ${collapsed_class}" data-key="${key}">
                        <div class="section-top">
                            <div class="section-icon">${section.icon ? section.icon : ''}</div>
                            <div class="section-name">${section.name}</div>
                            
                            <div class="toggle-wrapper">
                                ${toggleHtml(true)}
                            </div>
                            
                            <div class="chevron">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001"><path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/></svg>
                            </div>
                        </div>
                        <div class="section-container">
                            <div class="filter-options"></div>
                        </div>
                    </div>`;
                }

                sections_el.innerHTML = html;

                await rafAwait();

                befriend.filters.updateSectionHeights();
            } catch(e) {
                console.error(e);
            }

            return resolve();
        });

    },
    initCollapsible: function () {
        let sections = befriend.els.filters.getElementsByClassName('section');

        for (let i = 0; i < sections.length; i++) {
            let section = sections[i];
            let section_top = section.querySelector('.section-top');
            let section_container = section.querySelector('.section-container');

            if (!section_top || section_top._listener) {
                continue;
            }

            section_top._listener = true;

            // Set initial height if not already set
            if (!section_container.style.height) {
                let is_collapsed = elHasClass(section, 'collapsed');
                if (is_collapsed) {
                    section_container.style.height = '0';
                } else {
                    setElHeightDynamic(section_container);
                }
            }

            section_top.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                let is_collapsed = elHasClass(section, 'collapsed');
                let section_key = this.getSectionKey(section);

                if (is_collapsed) {
                    removeClassEl('collapsed', section);
                    setElHeightDynamic(section_container);
                    delete this.data.collapsed[section_key];
                } else {
                    addClassEl('collapsed', section);
                    section_container.style.height = '0';
                    this.data.collapsed[section_key] = true;
                }

                // Save collapsed state to local storage
                befriend.user.setLocal('filters.collapsed', this.data.collapsed);

                //remove secondaries
                if(befriend.filters.secondaries.activeEl) {
                    removeClassEl('secondary-open', section);
                    //remove secondary classes
                    befriend.filters.transitionSecondary(befriend.filters.secondaries.activeEl, false);
                }

                let secondaryItemsOpen = section.getElementsByClassName('item-secondary-open');

                removeElsClass(secondaryItemsOpen, 'item-secondary-open');
            });
        }
    },
    updateSecondaryPosition: function (section_el, options_el) {
        let secondary_container = section_el.querySelector('.secondary-container');
        let secondaryContainerBox = secondary_container.getBoundingClientRect();
        let item_token = options_el.getAttribute('data-item-token');
        let item_el = section_el.querySelector(`.item.mine[data-token="${item_token}"]`);

        let secondary_el = item_el.querySelector('.secondary');
        let secondaryBox = secondary_el.getBoundingClientRect();

        let offsetTop = secondaryBox.bottom - secondaryContainerBox.top;
        let offsetLeft = secondaryBox.left - secondaryContainerBox.left;

        options_el.style.width = `${secondary_el.offsetWidth}px`;
        options_el.style.top = `${offsetTop}px`;
        options_el.style.left = `${offsetLeft}px`;
    },
    updateSectionHeights: function (without_transition) {
        const sections_el = befriend.els.filters.querySelector('.sections');
        const sections = sections_el.getElementsByClassName('section');

        for (let section of sections) {
            const container = section.querySelector('.section-container');
            let itemsContainerEl = section.querySelector('.items-container');
            const is_collapsed = elHasClass(section, 'collapsed');

            removeClassEl('is-scrollable', itemsContainerEl);

            if (without_transition) {
                container.style.transition = 'none';
                setTimeout(() => {
                    container.style.removeProperty('transition');
                }, befriend.variables.filters_section_transition_ms);
            }

            if (is_collapsed) {
                container.style.height = '0';
                continue;
            }

            // Clone the container to measure its height without affecting the DOM
            const containerClone = container.cloneNode(true);
            containerClone.style.position = 'absolute';
            containerClone.style.visibility = 'hidden';
            containerClone.style.height = 'auto';
            section.appendChild(containerClone);

            // Find any secondary options containers
            const secondaryOptions = containerClone.querySelectorAll('.secondary .options');

            // Temporarily set their height to 0 to exclude from measurement
            for(let option of secondaryOptions) {
                option.style.height = '0';
                option.style.position = 'absolute'; // Ensure they don't affect layout
            }

            // Get the height excluding expanded dropdowns
            const baseHeight = containerClone.offsetHeight;

            // Find current-selected elements that might have wrapped
            const currentSelectedEls = containerClone.querySelectorAll('.current-selected');
            let maxCurrentSelectedHeight = 0;

            for(let el of currentSelectedEls) {
                const height = el.offsetHeight;
                maxCurrentSelectedHeight = Math.max(maxCurrentSelectedHeight, height);
            }

            //set height on container
            container.style.height = `${baseHeight}px`;

            //see if items container is scrollable
            if(itemsContainerEl) {
                let clonedItemsContainer = containerClone.querySelector('.items-container');

                removeClassEl('is-scrollable', clonedItemsContainer);

                const scrollHeight = clonedItemsContainer.scrollHeight;
                const clientHeight = clonedItemsContainer.clientHeight;

                if(scrollHeight > clientHeight) {
                    addClassEl('is-scrollable', itemsContainerEl);
                }
            }

            // Remove the clone
            section.removeChild(containerClone);
        }
    },
    getSectionKey: function (section_el) {
        return section_el.getAttribute('data-key');
    },
    getFilterToken: function (filterOption) {
        return filterOption.getAttribute('data-filter-token');
    },
    sendReceiveHtml: function (send_enabled, receive_enabled, position_corner) {
        return `<div class="send-receive ${position_corner ? 'position-corner' : ''}">
                    <div class="option send ${send_enabled ? 'enabled' : ''}">
                        <div class="icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 511.998 512.0029">
                                  <path d="M510.539,36.2574c7.1675-21.5056-13.29-41.9661-34.7956-34.7985L18.8108,153.7717c-25.6598,8.5523-24.8644,45.1188,1.1409,52.5476l222.2321,63.4978,63.4949,222.2321c7.4317,26.0082,43.9953,26.8036,52.5476,1.1409L510.539,36.2574Z" fill="black"/>
                                  <path d="M474.7157,56.7382l-142.5848,427.7544-63.373-221.7995L474.7157,56.7382ZM455.2626,37.285l-205.9548,205.9548L27.5111,179.8698,455.2626,37.285Z" fill="white"/>
                            </svg>
                        </div>
<!--                        <div class="text">Send</div>-->
                    </div>
                    <div class="option receive ${receive_enabled ? 'enabled' : ''}">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 426.6667 512">
                          <path d="M394.6667,448H32c-17.6427,0-32-14.3573-32-32,0-9.3653,4.0747-18.2187,11.2-24.32,33.6213-28.416,52.8-69.76,52.8-113.536v-64.8107c0-82.3467,66.9867-149.3333,149.3333-149.3333s149.3333,66.9867,149.3333,149.3333v64.8107c0,43.7973,19.1787,85.12,52.6293,113.3867,7.296,6.2507,11.3707,15.104,11.3707,24.4693,0,17.6427-14.336,32-32,32Z" fill="black"/>
                          
                          <path d="M213.3333,85.3333c-70.592,0-128,57.408-128,128v64.8107c0,50.0907-21.9307,97.344-60.1813,129.6853-2.4533,2.0907-3.8187,5.056-3.8187,8.1707,0,5.888,4.7787,10.6667,10.6667,10.6667h362.6667c5.888,0,10.6667-4.7787,10.6667-10.6667,0-3.1147-1.3653-6.08-3.7333-8.1066-38.3147-32.4053-60.2667-79.68-60.2667-129.7493v-64.8107c0-70.592-57.408-128-128-128h0Z" fill="white"/>
                          
                          <path d="M245.3333,89.1733c-5.888,0-10.6667-4.7787-10.6667-10.6667v-35.84c0-11.7547-9.5787-21.3333-21.3333-21.3333s-21.3333,9.5787-21.3333,21.3333v35.84c0,5.888-4.7787,10.6667-10.6667,10.6667s-10.6667-4.7573-10.6667-10.6667v-35.84c0-23.5307,19.136-42.6667,42.6667-42.6667s42.6667,19.136,42.6667,42.6667v35.84c0,5.9093-4.7787,10.6667-10.6667,10.6667Z" fill="black"/>
                          <path d="M213.3333,512c-41.1733,0-74.6667-33.4933-74.6667-74.6667,0-5.888,4.7787-10.6667,10.6667-10.6667s10.6667,4.7787,10.6667,10.6667c0,29.3973,23.936,53.3333,53.3333,53.3333s53.3333-23.936,53.3333-53.3333c0-5.888,4.7787-10.6667,10.6667-10.6667s10.6667,4.7787,10.6667,10.6667c0,41.1733-33.4933,74.6667-74.6667,74.6667Z" fill="black"/>
                        </svg>
<!--                        <div class="text">Receive</div>-->
                    </div>
                </div>`;
    },
    createMultiSelectFilter(filterName) {
        function getFilterNameStr() {
            if(filterName.toLowerCase().startsWith('relationship')) {
                return 'relationship_status';
            }

            if(filterName.toLowerCase().startsWith('politics')) {
                return filterName;
            }

            return filterName.endsWith('s') ? filterName.substring(0, filterName.length - 1) : filterName;
        }

        let filterNameStr = getFilterNameStr();

        let section = befriend.filters.sections[filterName];

        return {
            init: function () {
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
                const filter_options = section_el.querySelector('.filter-options');

                const filter_data = befriend.filters.data.filters?.[filterName];
                const options = befriend.filters.data.options?.[filterName] || [];

                // Determine if "Any" should be selected
                let anySelected = false;

                if (!filter_data) {
                    anySelected = true;
                } else if (filter_data.items) {
                    const hasActiveSelections = filter_data.items &&
                        Object.values(filter_data.items).some(item =>
                            !item.deleted && !item.is_negative
                        );

                    const everySelected = options.every(option => {
                        return filter_data?.items &&
                            Object.values(filter_data.items).some(item =>
                                item[`${filterNameStr}_id`] === option.id &&
                                !item.deleted &&
                                !item.is_negative
                            );
                    });

                    if (!hasActiveSelections || everySelected) {
                        anySelected = true;
                    }
                }

                const anyButtonHtml = `
                <div class="item button any ${anySelected ? 'selected' : ''}" data-token="any">
                    <div class="name">Any</div>
                </div>`;

                let optionsHtml = '';

                for (let option of options) {
                    let selected = '';

                    const matchingItem = filter_data?.items ?
                        Object.values(filter_data.items)
                            .find(item => item[`${filterNameStr}_id`] === option.id) : null;

                    if (matchingItem && !matchingItem.is_negative && !matchingItem.deleted && !anySelected) {
                        selected = 'selected';
                    }

                    optionsHtml += `
                    <div class="item button ${option.token} ${selected}" ${matchingItem?.id ? `data-id="${matchingItem.id}"` : ''} data-token="${option.token}">
                        <div class="name">${option.name}</div>
                    </div>`;
                }

                let html = `
                <div class="filter-option" data-filter-token="${section.token}">
                    <div class="items-container">
                        <div class="buttons">
                            ${anyButtonHtml}
                            <div class="options-grid">
                                ${optionsHtml}
                            </div>
                        </div>
                    </div>
                </div>
            `;

                section_el.querySelector('.section-container')
                    .insertAdjacentHTML(
                        'afterbegin',
                        befriend.filters.sendReceiveHtml(true, true, true)
                );

                filter_options.innerHTML = html;
                this.initEvents(section_el);
            },
            initEvents: function (section_el) {
                const optionButtons = section_el.querySelectorAll(`.button`);
                const anyButton = section_el.querySelector(`.button[data-token="any"]`);
                const regularButtons = Array.from(optionButtons)
                    .filter(btn => btn.getAttribute(`data-token`) !== 'any');

                for (let button of optionButtons) {
                    if (button._listener) continue;
                    button._listener = true;

                    button.addEventListener('click', async function (e) {
                        e.preventDefault();
                        e.stopPropagation();

                        const token = this.getAttribute(`data-token`);
                        const isAny = token === 'any';
                        const wasSelected = elHasClass(this, 'selected');

                        try {
                            let response;

                            if (isAny) {
                                if (wasSelected) return false;

                                removeElsClass(regularButtons, 'selected');
                                addClassEl('selected', this);

                                response = await befriend.auth.put(section.endpoint, {
                                    [`${filterNameStr}_token`]: token,
                                    active: !wasSelected
                                });
                            } else {
                                toggleElClass(this, 'selected');

                                const allSelected = regularButtons.every(btn =>
                                    elHasClass(btn, 'selected')
                                );

                                if (allSelected) {
                                    addClassEl('selected', anyButton);
                                    removeElsClass(regularButtons, 'selected');

                                    response = await befriend.auth.put(section.endpoint, {
                                        [`${filterNameStr}_token`]: token,
                                        active: !wasSelected
                                    });

                                    await befriend.auth.put(section.endpoint, {
                                        [`${filterNameStr}_token`]: 'any',
                                        active: true
                                    });
                                } else {
                                    removeClassEl('selected', anyButton);

                                    response = await befriend.auth.put(section.endpoint, {
                                        [`${filterNameStr}_token`]: token,
                                        active: !wasSelected
                                    });
                                }
                            }

                            //add id to item
                            if(response?.data?.id) {
                                if(!button.getAttribute('data-id')) {
                                    button.setAttribute('data-id', response.data.id);

                                    // Initialize or update filters data structure
                                    if (!befriend.filters.data.filters[filterName]) {
                                        befriend.filters.data.filters[filterName] = {
                                            items: {}
                                        };
                                    }

                                    // Add new item to local data
                                    befriend.filters.data.filters[filterName].items[response.data.id] = {
                                        id: response.data.id,
                                        token
                                    };
                                }
                            }
                        } catch (e) {
                            console.error(`Error updating ${filterName} filter:`, e);
                            toggleElClass(this, 'selected');
                        }
                    });
                }
            }
        };
    },
    transitionSecondary: async function (secondary_el, show, on_internal) {
        let section_el = secondary_el.closest('.section');

        if(!section_el) {
            let section_key = secondary_el.getAttribute('data-section');
            section_el = befriend.els.filters.querySelector(`.section.${section_key}`);
        }

        let secondary_container = section_el.querySelector('.secondary-container');
        let item_el = secondary_el.closest('.item');
        let token = item_el.getAttribute('data-token');

        // Find all items with open secondaries in the same section
        const openSecondaryItems = section_el.querySelectorAll('.item-secondary-open');

        // Get the options element for the clicked secondary
        let options_el = secondary_container.querySelector(`.options[data-item-token="${token}"]`);
        let options_item_el = options_el.closest('.item');

        let activeEl = befriend.filters.secondaries.activeEl;

        if (secondary_el._transitionTimeout) {
            clearTimeout(secondary_el._transitionTimeout);
        }

        if (show) {
            // First set the current height of any open options before transitioning
            for(let openItem of openSecondaryItems) {
                if (openItem !== item_el && openItem !== options_item_el) {
                    const openToken = openItem.getAttribute('data-token');
                    const openOptions = secondary_container.querySelector(`.options[data-item-token="${openToken}"]`);
                    if (openOptions) {
                        // Set current height before transitioning to 0
                        openOptions.style.height = `${openOptions.scrollHeight}px`;
                        // Force reflow
                        void openOptions.offsetHeight;
                        // Now set height to 0 to trigger transition
                        openOptions.style.height = '0';

                        // Remove class from both main item and options item
                        removeClassEl('item-secondary-open', openItem);
                        const openOptionsItem = openOptions.closest('.item');
                        if (openOptionsItem) {
                            removeClassEl('item-secondary-open', openOptionsItem);
                        }
                    }
                }
            }

            // Handle active element from different section
            if (activeEl && activeEl !== secondary_el) {
                let active_section = activeEl.closest('.section');
                if (active_section !== section_el) {
                    let active_item = activeEl.closest('.item');
                    let active_options = active_section.querySelector(`.options[data-item-token="${active_item.getAttribute('data-token')}"]`);

                    removeClassEl('item-secondary-open', active_item);
                    if (active_options) {
                        const activeOptionsItem = active_options.closest('.item');
                        if (activeOptionsItem) {
                            removeClassEl('item-secondary-open', activeOptionsItem);
                        }
                        active_options.style.height = '0';
                    }

                    setTimeout(() => {
                        removeClassEl('secondary-open', active_section);
                        if (active_options) {
                            active_options.style.removeProperty('height');
                        }
                    }, befriend.variables.secondary_transition_ms);
                }
            }

            befriend.filters.updateSecondaryPosition(section_el, options_el);

            // Set initial height of 0 before showing
            options_el.style.height = '0';
            // Force reflow
            void options_el.offsetHeight;

            addClassEl('secondary-open', section_el);
            // Add class to both main item and options item
            addClassEl('item-secondary-open', item_el);
            addClassEl('item-secondary-open', options_item_el);

            requestAnimationFrame(() => {
                options_el.style.height = `${options_el.scrollHeight}px`;
            });

            befriend.filters.secondaries.activeEl = secondary_el;
        } else {
            const currentHeight = options_el.scrollHeight;
            options_el.style.height = `${currentHeight}px`;
            void options_el.offsetHeight;

            options_el.style.height = '0';

            // Remove class from both main item and options item
            removeClassEl('item-secondary-open', item_el);
            removeClassEl('item-secondary-open', options_item_el);

            secondary_el._transitionTimeout = setTimeout(function () {
                if (!document.querySelector('.item-secondary-open')) {
                    removeClassEl('secondary-open', section_el);
                }

                options_el.style.removeProperty('height');

                if (!on_internal) {
                    if (secondary_el === activeEl) {
                        befriend.filters.secondaries.activeEl = null;
                    }
                }
            }, befriend.variables.secondary_transition_ms);
        }
    },
    hideActiveSecondaryIf: function (target = null) {
        let open_secondary_el = befriend.filters.secondaries.activeEl;

        if (open_secondary_el && !target?.closest('.secondary')) {
            befriend.filters.transitionSecondary(open_secondary_el, false);
        }
    },
};