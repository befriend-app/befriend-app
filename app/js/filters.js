befriend.filters = {
    data: {
        filters: null,
        options: null,
        collapsed: {},
    },
    matches: {
        data: {},
        needsUpdate: false,
        init: function () {
            return new Promise(async (resolve, reject) => {
                befriend.filters.matches.updateCounts();

                setInterval(befriend.filters.matches.updateCounts, 60 * 10 * 1000); //update every 10 minutes automatically

                resolve();
            });
        },
        updateCounts: async function () {
            let matches_el = befriend.els.filters.querySelector('.matches-overview');
            let update_circle_el = matches_el.querySelector('.update-circle');
            let send_el = matches_el.querySelector('.send');
            let receive_el = matches_el.querySelector('.receive');
            let interests_el = matches_el.querySelector('.interests');
            let excluded_el = matches_el.querySelector('.excluded');

            let ts = timeNow();

            addClassEl('show', update_circle_el);

            try {
                let response = await befriend.auth.get('/filters/matches');

                if(response.data?.counts) {
                    befriend.filters.matches.data = response.data;
                    send_el.querySelector('.count').innerHTML = formattedNumberDisplay(response.data.counts.send);
                    receive_el.querySelector('.count').innerHTML = formattedNumberDisplay(response.data.counts.receive);
                    interests_el.querySelector('.count').innerHTML = `
                                                                                <div class="ultra category">
                                                                                    <div class="name">Ultra</div>
                                                                                    <div class="number">${formattedNumberDisplay(response.data.counts.interests.ultra)}</div>
                                                                                </div>
                                                                                
                                                                                <div class="super category">
                                                                                     <div class="name">Super</div>
                                                                                     <div class="number">${formattedNumberDisplay(response.data.counts.interests.super)}</div>
                                                                                </div>
                                                                            `;
                    excluded_el.querySelector('.count').innerHTML = formattedNumberDisplay(response.data.counts.excluded);
                }
            } catch(e) {
                console.error(e);
            }

            //show animation for a given duration
            let transition_duration = 2000;

            let td = timeNow() - ts;

            setTimeout(function () {
                removeClassEl('show', update_circle_el);
            }, Math.max(transition_duration - td, 0));
        },
    },
    groups: [
        {
            name: 'Notifications',
            key: 'notifications',
        },
        {
            name: 'General',
            key: 'general',
        },
        {
            name: 'Interests',
            key: 'interests',
        },
        {
            name: 'Schools & Work',
            key: 'schools_work',
        },
        {
            name: 'Personal',
            key: 'personal',
        },
    ],
    sections: {
        availability: {
            token: 'availability',
            name: 'Availability',
            group: 'notifications',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M138.6667,320h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM85.3333,298.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M138.6667,448h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM85.3333,426.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M288,320h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM234.6667,298.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M288,448h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM234.6667,426.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M437.3333,320h-64c-5.888,0-10.6667-4.7787-10.6667-10.6667v-64c0-5.888,4.7787-10.6667,10.6667-10.6667h64c5.888,0,10.6667,4.7787,10.6667,10.6667v64c0,5.888-4.7787,10.6667-10.6667,10.6667ZM384,298.6667h42.6667v-42.6667h-42.6667v42.6667Z"/><path d="M458.6667,512H53.3333c-29.3973,0-53.3333-23.936-53.3333-53.3333V96c0-29.3973,23.936-53.3333,53.3333-53.3333h405.3333c29.3973,0,53.3333,23.936,53.3333,53.3333v362.6667c0,29.3973-23.936,53.3333-53.3333,53.3333ZM53.3333,64c-17.6427,0-32,14.3573-32,32v362.6667c0,17.6427,14.3573,32,32,32h405.3333c17.6427,0,32-14.3573,32-32V96c0-17.6427-14.3573-32-32-32H53.3333Z"/><path d="M501.3333,192H10.6667c-5.888,0-10.6667-4.7787-10.6667-10.6667s4.7787-10.6667,10.6667-10.6667h490.6667c5.888,0,10.6667,4.7787,10.6667,10.6667s-4.7787,10.6667-10.6667,10.6667Z"/><path d="M117.3333,106.6667c-5.888,0-10.6667-4.7787-10.6667-10.6667V10.6667c0-5.888,4.7787-10.6667,10.6667-10.6667s10.6667,4.7787,10.6667,10.6667v85.3333c0,5.888-4.7787,10.6667-10.6667,10.6667Z"/><path d="M394.6667,106.6667c-5.888,0-10.6667-4.7787-10.6667-10.6667V10.6667c0-5.888,4.7787-10.6667,10.6667-10.6667s10.6667,4.7787,10.6667,10.6667v85.3333c0,5.888-4.7787,10.6667-10.6667,10.6667Z"/></svg>`,
        },
        activityTypes: {
            token: 'activity_types',
            name: 'Activity Types',
            group: 'notifications',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 415.9976 409.0015"><path d="M21.4841,152.0738C9.6343,152.0738,0,161.7081,0,173.554s9.6343,21.4841,21.4841,21.4841c4.6455,0,8.9244-1.5212,12.4427-4.037,3.335,26.6835,14.1433,51.4753,30.7089,71.7346-11.4949.4057-20.7352,9.8176-20.7352,21.4061,0,11.8498,9.6343,21.4841,21.4841,21.4841,11.7406,0,21.2852-9.4783,21.449-21.1877,6.0731,4.7625,12.5402,9.0765,19.4168,12.821l-12.2399,29.5816c-1.0765,2.6095.1599,5.6012,2.7655,6.6816.6436.2613,1.3028.3862,1.9581.3862,2.0088,0,3.9083-1.1858,4.7235-3.1555l11.9785-28.9458c3.7991,1.7201,7.6723,3.3272,11.6665,4.7235.5578.195,1.1273.2847,1.6889.2847,2.1102,0,4.0878-1.3184,4.825-3.4247.9322-2.668-.472-5.5817-3.1399-6.5178-17.5641-6.1355-33.135-15.8556-46.151-28.076l72.3431-72.347c3.3467,2.4417,7.2277,4.1775,11.448,4.9771v15.216c0,2.824,2.2896,5.1097,5.1136,5.1097s5.1136-2.2857,5.1136-5.1097v-15.1496c4.3296-.7528,8.3198-2.4768,11.7523-4.9498l6.3111,6.3072c.9985.9985,2.3052,1.4978,3.6119,1.4978,1.3106,0,2.6173-.4993,3.6158-1.4978,1.9971-1.9971,1.9971-5.2306,0-7.2277l-6.4242-6.4242c2.1258-3.1789,3.6119-6.8103,4.3179-10.7108h102.424c-.4447,11.959-2.4066,23.7347-6.0458,35.054-.862,2.6875.6163,5.5661,3.3037,6.432,2.6836.8581,5.57-.6124,6.432-3.3076,2.6914-8.3705,4.4817-16.9829,5.5583-25.7162,3.53,2.547,7.8284,4.0878,12.5051,4.0878,11.842,0,21.4802-9.6343,21.4802-21.4841s-9.6382-21.4802-21.4802-21.4802c-4.6533,0-8.9361,1.5212-12.4544,4.0448-3.0892-24.8893-12.6611-47.7932-27.0229-66.9253,10.3325-1.5524,18.3052-10.4027,18.3052-21.1565,0-11.8498-9.6382-21.4841-21.4802-21.4841-10.4885,0-19.2101,7.5592-21.0824,17.5134-19.959-16.1482-44.3958-26.9409-71.1378-30.2291,2.4768-3.5027,3.9668-7.7503,3.9668-12.353,0-11.8498-9.6382-21.4841-21.4841-21.4841s-21.4841,9.6343-21.4841,21.4841c0,4.6299,1.5056,8.8932,4.0097,12.4076-24.9049,3.1399-47.8088,12.7781-66.9292,27.2062-1.3808-10.5236-10.3091-18.6991-21.1994-18.6991-11.8459,0-21.4802,9.6343-21.4802,21.4841,0,10.6328,7.7777,19.4207,17.9346,21.1253-16.1638,19.9278-26.976,44.3373-30.3071,71.052-3.5027-2.4924-7.7621-3.9863-12.3764-3.9863ZM21.4841,184.8148c-6.2057,0-11.2608-5.0551-11.2608-11.2608s5.0551-11.2569,11.2608-11.2569,11.253,5.0512,11.253,11.2569-5.0473,11.2608-11.253,11.2608ZM173.4448,191.7187c-10.1141,0-18.3481-8.2262-18.3481-18.3442s8.234-18.3481,18.3481-18.3481,18.3442,8.234,18.3442,18.3481-8.2301,18.3442-18.3442,18.3442ZM145.3571,178.4881c.6982,3.8498,2.157,7.4305,4.236,10.5782l-72.4445,72.4445c-20.3803-22.3773-32.8034-51.5962-33.9931-83.0227h102.2016ZM197.2107,157.5462l72.3743-72.3743c20.3178,22.0614,33.1428,51.1125,34.4222,83.0929h-102.4786c-.7099-3.9044-2.196-7.5397-4.3179-10.7187ZM190.0922,150.2015c-3.374-2.43-7.2862-4.1424-11.5339-4.9147V43.0891c32.3003,1.2248,61.6244,14.2252,83.8067,34.8434l-72.2729,72.269ZM168.3312,145.2869c-4.3023.7801-8.2613,2.5275-11.6626,5.0083l-72.152-72.152c22.1589-20.6884,51.4909-33.7708,83.8145-35.0501v102.1938ZM149.593,157.6827c-2.079,3.1477-3.5378,6.7323-4.236,10.5821H43.0969c1.2755-31.8712,14.0107-60.8365,34.2115-82.8706l72.2846,72.2885ZM65.3845,295.4026c-6.2057,0-11.2608-5.0551-11.2608-11.2608s5.0551-11.2569,11.2608-11.2569,11.253,5.0512,11.253,11.2569-5.0473,11.2608-11.253,11.2608ZM325.7058,162.2971c6.2057,0,11.253,5.0512,11.253,11.2569s-5.0473,11.2608-11.253,11.2608-11.2569-5.0551-11.2569-11.2608,5.0512-11.2569,11.2569-11.2569ZM283.0535,56.7761c6.2057,0,11.253,5.0551,11.253,11.2608s-5.0473,11.253-11.253,11.253-11.2569-5.0473-11.2569-11.253,5.0512-11.2608,11.2569-11.2608ZM173.316,10.2233c6.2057,0,11.2569,5.0551,11.2569,11.2608s-5.0512,11.253-11.2569,11.253-11.2608-5.0473-11.2608-11.253,5.0551-11.2608,11.2608-11.2608ZM56.4562,63.8828c0-6.2057,5.0512-11.2608,11.2569-11.2608s11.2569,5.0551,11.2569,11.2608-5.0512,11.2569-11.2569,11.2569-11.2569-5.0512-11.2569-11.2569Z"/><path d="M5.1136,375.5428h18.7849c2.0985.0429,4.1502.0624,6.1823.0624.7567,0,1.4627-.0312,2.2116-.0351v28.3178c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1097-2.2896,5.1097-5.1136v-28.5753c11.6353-.4954,22.1199-1.6577,31.4968-3.452v32.0272c0,2.824,2.2857,5.1136,5.1097,5.1136,2.8279,0,5.1136-2.2896,5.1136-5.1136v-34.3597c12.3608-3.2101,22.6621-7.567,31.2783-12.7898v47.1496c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1136-2.2896,5.1136-5.1136v-54.2953c16.351-13.2696,25.1896-30.194,31.2744-47.3368v101.6322c0,2.824,2.2857,5.1136,5.1097,5.1136,2.8279,0,5.1136-2.2896,5.1136-5.1136v-135.5004c7.1224-20.5675,20.3217-33.5172,30.8493-40.9867v176.4872c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1136-2.2896,5.1136-5.1136v-182.7241c3.0736-1.5719,5.098-2.3481,5.2501-2.4027.1677-.0702,11.998-5.0005,27.4285-4.2048v189.3316c0,2.824,2.2896,5.1136,5.1136,5.1136,2.8279,0,5.1136-2.2896,5.1136-5.1136v-187.9235c3.6275.8113,7.3369,1.9581,11.0619,3.6431,7.4656,3.3779,14.194,8.4134,20.2164,14.9585v169.3219c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1097-2.2896,5.1097-5.1136v-155.6155c4.7976,7.9103,8.9517,17.1545,12.4154,27.7562,4.9537,15.1731,11.4402,26.8473,18.43,35.9005v91.9588c0,2.824,2.2896,5.1136,5.1136,5.1136s5.1136-2.2896,5.1136-5.1136v-80.7448c6.9936,6.4476,14.0224,10.7967,20.1891,13.6792,4.4232,2.0673,8.6475,3.5261,12.4973,4.5636v62.5021c0,2.824,2.2857,5.1136,5.1136,5.1136,2.824,0,5.1097-2.2896,5.1097-5.1136v-60.4933c5.3827.6553,8.7684.4291,8.862.4213l18.3208-.0039c2.824,0,5.1097-2.2935,5.1097-5.1136,0-2.8279-2.2896-5.1136-5.1097-5.1136l-18.6874.0195c-2.0088.0975-49.6303,2.668-70.3499-60.7507-10.3676-31.7464-26.6874-52.817-48.4953-62.623-28.5636-12.8561-55.7112-1.3457-56.5225-.9829-1.685.5929-41.3417,15.1145-54.1705,61.7337l-.9439,3.4364c-6.6114,24.195-13.6792,50.2076-36.743,68.1968-.4057.2535-.7957.5188-1.1156.8737-18.4729,13.8859-46.9233,22.744-92.8638,21.8313H5.1136c-2.8279,0-5.1136,2.2857-5.1136,5.1136,0,2.824,2.2857,5.1097,5.1136,5.1097Z"/></svg>`,
        },
        modes: {
            token: 'modes',
            name: 'Modes',
            group: 'notifications',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 469.976 374.017">
                    <path class="outline" d="M197.396,258.637l-33.524-6.472c.032-.676.104-1.348.104-2.032v-20.844c19.9322-11.3726,34.5883-30.1323,40.8-52.224,16.9671-2.0638,29.0486-17.4913,26.9848-34.4583-1.0477-8.6131-5.6629-16.3909-12.7208-21.4377l1.012-15.344C223.6666,51.1135,182.2443,3.8308,127.5327.2163c-29.6844-1.9611-58.6839,9.4926-79.0167,31.2088-18.8774,19.9906-28.5213,46.9727-26.592,74.4l1.012,15.344c-13.9034,9.9415-17.1152,29.2717-7.1737,43.1752,5.0467,7.058,12.8245,11.6732,21.4377,12.7208,6.2117,22.0917,20.8678,40.8514,40.8,52.224v20.844c0,.684.072,1.356.104,2.032l-33.528,6.472C18.7156,263.6609.0331,286.2932,0,312.637v54.38c.0022,3.8557,3.1203,6.9846,6.976,7h228c3.8651-.0022,6.9978-3.1349,7-7v-54.376c-.0315-26.3466-18.7166-48.9815-44.58-54.004ZM207.572,161.985c.26-2.724.4-5.484.4-8.28v-22.836c8.5444,3.8486,12.3511,13.8952,8.5024,22.4396-1.7631,3.9142-4.9442,7.0146-8.9024,8.6764h0ZM35.884,104.901c-3.0886-46.9975,32.5066-87.6002,79.5041-90.6888,25.4863-1.6749,50.3816,8.1617,67.8399,26.8048,16.2122,17.1684,24.4953,40.3407,22.84,63.896l-.692,10.756c-.9707-.1387-1.9547-.2307-2.952-.276-19.696-6.748-36-26.552-36.16-26.752-2.1433-2.6336-5.8656-3.3532-8.836-1.708-53.116,29.528-115.656,28.4-116.268,28.4-1.5244-.0167-3.0474.0984-4.552.344l-.724-10.776ZM23.976,146.321c.0157-6.6657,3.9255-12.7073,10-15.452v22.836c0,2.8.144,5.556.4,8.28-6.2971-2.6598-10.3926-8.8282-10.4-15.664ZM47.976,153.705v-24.44c18-.504,66.368-4.116,111.272-27.428,9.7588,10.693,21.5691,19.3134,34.728,25.348v26.52c0,40.3168-32.6832,73-73,73s-73-32.6832-73-73ZM120.976,240.705c9.8805.0048,19.6889-1.6823,29-4.988v14.4c0,16.0163-12.9837,29-29,29s-29-12.9837-29-29v-14.4c9.3111,3.3058,19.1195,4.9928,29,4.988ZM227.976,360.017H13.976v-47.376c.024-19.6404,13.9521-36.5141,33.232-40.26l33.788-6.52c8.6524,22.0804,33.5663,32.9658,55.6466,24.3134,11.1371-4.3642,19.9491-13.1762,24.3134-24.3134l33.788,6.52c19.2799,3.7459,33.208,20.6196,33.232,40.26v47.376Z M429.704,269.905l-13.396-2.588,15.452-1.368c16.2248-1.468,28.5575-15.2238,28.252-31.512l-2-99.964c-1.1376-53.2281-45.2097-95.4558-98.4378-94.3182-51.6266,1.1034-93.2148,42.6916-94.3182,94.3182l-2,99.968c-.2635,16.2755,12.0554,30.0066,28.264,31.504l15.456,1.372-13.412,2.588c-23.3664,4.5435-40.2448,24.996-40.272,48.8v48.312c.0022,3.8651,3.1349,6.9978,7,7h202.684c3.8651-.0022,6.9978-3.1349,7-7v-48.32c-.0311-23.801-16.9085-44.2491-40.272-48.792ZM361.64,241.5051c-35.3807-.0418-64.0551-28.7073-64.108-64.088v-23.068c11.4219-5.3275,21.695-12.8315,30.244-22.092,39.284,20.24,81.42,23.652,97.964,24.18v20.98c-.0463,35.3823-28.7177,64.0537-64.1,64.1v-.012ZM336.656,251.345c16.2012,5.5708,33.7988,5.5708,50,0v11.792c0,13.8071-11.1929,25-25,25s-25-11.1929-25-25v-11.792ZM277.252,234.7171l2-99.956c.9511-45.4983,38.6058-81.611,84.1041-80.6599,44.1592.9231,79.7368,36.5007,80.6599,80.6599l2,99.976c.1641,8.9305-6.6001,16.4699-15.496,17.272l-29.864,2.644v-9.6801c24.1594-13.9227,39.061-39.672,39.096-67.556v-27.908c.0003-1.8871-.7612-3.6943-2.112-5.012-1.3415-1.3316-3.1706-2.0545-5.06-2-.568.036-55.792,1.08-102.944-25.136-2.9692-1.6478-6.6925-.9297-8.836,1.704-.148.18-14.856,18.068-32.432,23.772-2.8839.9388-4.836,3.6271-4.836,6.66v27.92c.035,27.8955,14.9489,53.6535,39.124,67.572v9.66l-29.896-2.644c-8.8928-.8246-15.6507-8.3582-15.508-17.288ZM455.976,360.017h-188.68v-41.32c.0235-17.0948,12.1441-31.7817,28.924-35.048l29.388-5.664c8.1882,19.9077,30.9645,29.4081,50.8721,21.2199,9.6219-3.9576,17.2623-11.5979,21.2199-21.2199l29.348,5.664c16.7815,3.2646,28.9041,17.9519,28.928,35.048v41.32Z"></path>
                </svg>`,
        },
        networks: {
            token: 'networks',
            name: 'Networks',
            group: 'notifications',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 487 480"><path d="M384,192c52.9375,0,96-43.0625,96-96S436.9375,0,384,0c-38.4414,0-71.5859,22.7617-86.9023,55.4727l-25.707-9.4883c.3047-1.9688.6094-3.9375.6094-5.9844,0-22.0547-17.9453-40-40-40s-40,17.9453-40,40,17.9453,40,40,40c14.3281,0,26.8242-7.6406,33.8867-18.9922l25.6641,9.4727c-2.2539,8.1445-3.5508,16.6719-3.5508,25.5195,0,10.4805,1.7422,20.543,4.8633,29.9922l-87.9844,37.2891c-16.1094-30.457-48.0859-51.2812-84.8789-51.2812-11.9219,0-23.2969,2.2891-33.8398,6.2734l-22.1289-46.5039c9.6406-7.3125,15.9688-18.7695,15.9688-31.7695C80,17.9453,62.0547,0,40,0S0,17.9453,0,40s17.9453,40,40,40c3.3281,0,6.5195-.5273,9.6172-1.3047l22.1016,46.457c-28.4883,16.6719-47.7188,47.5195-47.7188,82.8477,0,33.1836,16.9297,62.4727,42.5938,79.7188l-14.6328,26.3047c-3.8086-1.1992-7.7695-2.0234-11.9609-2.0234-22.0547,0-40,17.9453-40,40s17.9453,40,40,40,40-17.9453,40-40c0-12.1133-5.5273-22.8555-14.0547-30.1914l14.6641-26.3594c12.0312,5.4453,25.3438,8.5508,39.3906,8.5508,21.9531,0,42.1445-7.4883,58.3359-19.9375l31.4883,34.6406c-15.9688,17.1523-25.8242,40.0664-25.8242,65.2969,0,4.8945.4883,9.6641,1.1914,14.3594l-37.0469,8.793c-6.375-13.6328-20.1289-23.1523-36.1445-23.1523-22.0547,0-40,17.9453-40,40s17.9453,40,40,40,40-17.9453,40-40c0-.4414-.1211-.8555-.1289-1.2969l36.9766-8.7656c12.6094,38.3086,48.6719,66.0625,91.1523,66.0625,52.9375,0,96-43.0625,96-96,0-16.4141-4.1523-31.8711-11.4492-45.3906l46.9922-30.5547c7.2656,7.3594,17.3281,11.9453,28.457,11.9453,22.0547,0,40-17.9453,40-40s-17.9453-40-40-40-40,17.9453-40,40c0,5.168,1.0625,10.0781,2.8555,14.6172l-47.1016,30.6211c-9.4258-12.1172-21.6641-21.9023-35.7539-28.3984l39.0469-108.2461c7.9688,2.1484,16.3125,3.4062,24.9531,3.4062ZM232,64c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM16,40c0-13.2305,10.7695-24,24-24s24,10.7695,24,24-10.7695,24-24,24-24-10.7695-24-24ZM40,376c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM112,448c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM440,256c13.2305,0,24,10.7695,24,24s-10.7695,24-24,24-24-10.7695-24-24,10.7695-24,24-24ZM336.8867,160.5117c3.5703-18.5039,19.8828-32.5117,39.1133-32.5117h16c19.2305,0,35.543,14.0078,39.1133,32.5117-13.2344,9.6875-29.4883,15.4883-47.1133,15.4883s-33.8789-5.8008-47.1133-15.4883ZM384,112c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM384,16c44.1133,0,80,35.8867,80,80,0,20-7.4336,38.2734-19.6172,52.3125-5.6055-14.7617-17.293-26.543-31.8555-32.3594,7.082-7.2188,11.4727-17.0742,11.4727-27.9531,0-22.0547-17.9453-40-40-40s-40,17.9453-40,40c0,10.8789,4.3906,20.7344,11.4727,27.9531-14.5625,5.8164-26.25,17.5977-31.8555,32.3594-12.1836-14.0391-19.6172-32.3125-19.6172-52.3125,0-44.1133,35.8867-80,80-80ZM40,208c0-44.1133,35.8867-80,80-80s80,35.8867,80,80c0,20.0625-7.4805,38.3828-19.7266,52.4414-5.5859-14.8164-17.2969-26.6562-31.8984-32.4883,7.0742-7.2188,11.4648-17.0742,11.4648-27.9531,0-22.0547-17.9453-40-40-40s-40,17.9453-40,40c0,10.8789,4.3906,20.7344,11.4727,27.9531-14.5195,5.7891-26.1914,17.5273-31.8164,32.2305-12.1133-14.0234-19.4961-32.2383-19.4961-52.1836ZM95.8398,200c0-13.2305,10.7695-24,24-24s24,10.7695,24,24-10.7695,24-24,24-24-10.7695-24-24ZM72.7539,272.4062c3.6055-18.4531,19.8945-32.4062,39.0859-32.4062h16c19.2656,0,35.6094,14.0547,39.1289,32.6172-13.207,9.6289-29.4102,15.3828-46.9688,15.3828-17.6875,0-33.9922-5.8398-47.2461-15.5938ZM232.7539,448.4062c3.6055-18.4531,19.8945-32.4062,39.0859-32.4062h16c19.2656,0,35.6094,14.0547,39.1289,32.6172-13.207,9.6289-29.4102,15.3828-46.9688,15.3828-17.6875,0-33.9922-5.8398-47.2461-15.5938ZM279.8398,400c-13.2305,0-24-10.7695-24-24s10.7695-24,24-24,24,10.7695,24,24-10.7695,24-24,24ZM360,384c0,20.0625-7.4805,38.3828-19.7266,52.4414-5.5859-14.8164-17.2969-26.6562-31.8984-32.4883,7.0742-7.2188,11.4648-17.0742,11.4648-27.9531,0-22.0547-17.9453-40-40-40s-40,17.9453-40,40c0,10.8789,4.3906,20.7344,11.4727,27.9531-14.5195,5.7891-26.1914,17.5273-31.8164,32.2305-12.1133-14.0234-19.4961-32.2383-19.4961-52.1836,0-44.1133,35.8867-80,80-80s80,35.8867,80,80ZM304.9531,291.4062c-7.9688-2.1484-16.3125-3.4062-24.9531-3.4062-21.9531,0-42.1445,7.4883-58.3359,19.9375l-31.4883-34.6406c15.9688-17.1523,25.8242-40.0664,25.8242-65.2969,0-10.4805-1.7422-20.543-4.8633-29.9922l87.9844-37.2891c9.8555,18.6328,25.6719,33.5859,44.8867,42.4414l-39.0547,108.2461Z"/></svg>`,
        },
        reviews: {
            token: 'reviews',
            name: 'Reviews',
            group: 'notifications',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 29 28.9766"><defs><style>.reviews-icon-cls1{fill-rule:evenodd;}</style></defs><path class="reviews-icon-cls1" d="M25.2466,13.9834c-.272.0459-.4556.3037-.4097.5762.1084.6406.1631,1.2852.1631,1.917,0,3.5242-1.5708,6.7053-4.1017,8.8234-.442-2.8699-2.4796-5.1718-5.1854-5.9955,1.0757-.7176,1.787-1.9402,1.787-3.3279,0-2.2061-1.7944-4-4-4s-4,1.7939-4,4c0,1.3877.7113,2.6104,1.787,3.3279-2.7057.8237-4.7433,3.1255-5.1854,5.9955-2.5309-2.1181-4.1017-5.2992-4.1017-8.8234,0-.6318.0547-1.2764.1631-1.917.0459-.2725-.1377-.5303-.4097-.5762-.2783-.0469-.5303.1377-.5767.4102-.1172.6943-.1768,1.3955-.1768,2.083,0,6.1406,4.3857,11.3232,10.4282,12.3232.0273.0049.0552.0068.082.0068.2402,0,.4521-.1738.4927-.418.0454-.2725-.1392-.5303-.4116-.5752-1.6849-.2789-3.2263-.9159-4.5611-1.8195.2412-3.3932,3.0299-6.0174,6.4698-6.0174s6.2286,2.6242,6.4698,6.0174c-1.3348.9036-2.8762,1.5406-4.5611,1.8195-.2725.0449-.457.3027-.4116.5752.0405.2441.2524.418.4927.418.0269,0,.0547-.002.082-.0068,6.0425-1,10.4282-6.1826,10.4282-12.3232,0-.6875-.0596-1.3887-.1768-2.083-.0464-.2725-.3013-.458-.5767-.4102ZM10.5,15.9766c0-1.6543,1.3457-3,3-3s3,1.3457,3,3-1.3457,3-3,3-3-1.3457-3-3Z"/><path class="reviews-icon-cls1" d="M18.9756,3.9551c-.0591-.1816-.2153-.3135-.4038-.3408l-3.1948-.4639-1.4287-2.8955c-.168-.3398-.7285-.3398-.8965,0l-1.4287,2.8955-3.1948.4639c-.1885.0273-.3447.1592-.4038.3408-.0586.1807-.0098.3799.1265.5127l2.312,2.2529-.5459,3.1816c-.0322.1885.0449.3779.1987.4893.1548.1123.3584.1289.5269.0381l2.8574-1.5029,2.8574,1.5029c.0732.0391.1533.0576.2329.0576.1035,0,.2065-.0322.2939-.0957.1538-.1113.231-.3008.1987-.4893l-.5459-3.1816,2.312-2.2529c.1362-.1328.1851-.332.1265-.5127ZM15.6509,6.1875c-.1177.1152-.1714.2803-.1436.4434l.4189,2.4424-2.1934-1.1533c-.0732-.0381-.1528-.0576-.2329-.0576s-.1597.0195-.2329.0576l-2.1934,1.1533.4189-2.4424c.0278-.1631-.0259-.3281-.1436-.4434l-1.7744-1.7285,2.4521-.3564c.1631-.0244.3037-.126.3765-.2734l1.0967-2.2227,1.0967,2.2227c.0728.1475.2134.249.3765.2734l2.4521.3564-1.7744,1.7285Z"/><path class="reviews-icon-cls1" d="M1.5351,12c-.0322.1885.0449.3779.1987.4893.1553.1123.3594.1279.5269.0381l2.2393-1.1777,2.2393,1.1777c.0732.0391.1533.0576.2329.0576.1035,0,.2065-.0322.2939-.0957.1538-.1113.231-.3008.1987-.4893l-.4277-2.4932,1.812-1.7656c.1362-.1328.1851-.332.1265-.5127-.0591-.1816-.2153-.3135-.4038-.3408l-2.5039-.3633-1.1196-2.2695c-.168-.3398-.7285-.3398-.8965,0l-1.1196,2.2695-2.5039.3633c-.1885.0273-.3447.1592-.4038.3408-.0586.1807-.0098.3799.1265.5127l1.812,1.7656-.4277,2.4932ZM1.5747,7.7324l1.7612-.2559c.1631-.0244.3037-.126.3765-.2734l.7876-1.5967.7876,1.5967c.0728.1475.2134.249.3765.2734l1.7612.2559-1.2744,1.2412c-.1177.1152-.1714.2803-.1436.4434l.3008,1.7539-1.5752-.8281c-.0732-.0381-.1528-.0576-.2329-.0576s-.1597.0195-.2329.0576l-1.5752.8281.3008-1.7539c.0278-.1631-.0259-.3281-.1436-.4434l-1.2744-1.2412Z"/><path class="reviews-icon-cls1" d="M26.5718,6.8877l-2.5039-.3633-1.1196-2.2695c-.168-.3398-.7285-.3398-.8965,0l-1.1196,2.2695-2.5039.3633c-.1885.0273-.3447.1592-.4038.3408-.0586.1807-.0098.3799.1265.5127l1.812,1.7656-.4277,2.4932c-.0322.1885.0449.3779.1987.4893.1548.1123.3584.1279.5269.0381l2.2393-1.1777,2.2393,1.1777c.0732.0391.1533.0576.2329.0576.1035,0,.2065-.0322.2939-.0957.1538-.1113.231-.3008.1987-.4893l-.4277-2.4932,1.812-1.7656c.1362-.1328.1851-.332.1265-.5127-.0591-.1816-.2153-.3135-.4038-.3408ZM24.1509,8.9736c-.1177.1152-.1714.2803-.1436.4434l.3008,1.7539-1.5752-.8281c-.0732-.0381-.1528-.0576-.2329-.0576s-.1597.0195-.2329.0576l-1.5752.8281.3008-1.7539c.0278-.1631-.0259-.3281-.1436-.4434l-1.2744-1.2412,1.7612-.2559c.1631-.0244.3037-.126.3765-.2734l.7876-1.5967.7876,1.5967c.0728.1475.2134.249.3765.2734l1.7612.2559-1.2744,1.2412Z"/><circle cx="13.5" cy="28.4766" r=".5"/></svg>`,
        },
        verifications: {
            token: 'verifications',
            name: 'Verifications',
            group: 'notifications',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 435.382 494"><path d="M410.213,67.013L213.021.627c-2.484-.836-5.174-.836-7.658,0L8.171,67.013c-4.883,1.644-8.171,6.221-8.171,11.373v164.825c0,122.08,87.022,227.462,206.92,250.572.75.145,1.511.217,2.271.217s1.521-.072,2.271-.217c119.897-23.11,206.92-128.492,206.92-250.572V78.386c.001-5.153-3.287-9.73-8.169-11.373h0ZM394.383,243.211c0,109.829-77.738,204.737-185.191,226.557-107.453-21.82-185.191-116.728-185.191-226.557V87.008L209.192,24.662l185.191,62.346v156.203ZM186.917,290.563l126.273-120.9c4.787-4.583,12.383-4.418,16.967.369,4.583,4.787,4.418,12.383-.369,16.967l-134.402,128.683c-2.317,2.219-5.308,3.332-8.3,3.332-2.908,0-5.818-1.052-8.116-3.161l-74.957-68.838c-4.881-4.483-5.204-12.074-.722-16.956,4.483-4.881,12.075-5.203,16.956-.722l66.67,61.226Z"/></svg>`,
        },
        distance: {
            token: 'distance',
            name: 'Distance',
            group: 'general',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30.3688 25.9848"><defs><style>.distance-icon-cls-1{fill-rule:evenodd;}</style></defs><path class="distance-icon-cls-1" d="M3.5723,17.9278c-.8842-.2233-1.5396-1.0246-1.5396-1.9781,0-1.1254.9139-2.0395,2.0392-2.0395s2.0388.9141,2.0388,2.0395c0,.9534-.6551,1.7548-1.5393,1.9781v3.5597c0,.9278.3683,1.8174,1.024,2.4733.6557.6562,1.5454,1.0246,2.4726,1.0246h1.9983c1.9314,0,3.497-1.5661,3.497-3.4979V4.4972c0-2.4838,2.0129-4.4972,4.4957-4.4972h1.9983c1.1925,0,2.3359.4738,3.1791,1.3172.8433.8437,1.3169,1.9874,1.3169,3.1801v3.0194c.8842.2229,1.5393,1.0246,1.5393,1.9777,0,1.1258-.9135,2.0399-2.0388,2.0399s-2.0392-.9142-2.0392-2.0399c0-.9531.6554-1.7548,1.5396-1.9777v-3.0194c0-.9274-.3686-1.8174-1.0244-2.4733s-1.5451-1.0246-2.4726-1.0246h-1.9983c-1.9311,0-3.4966,1.5661-3.4966,3.4983v16.99c0,2.4838-2.0129,4.4972-4.4961,4.4972h-1.9983c-1.1921,0-2.3359-.4738-3.1788-1.3172-.8433-.8434-1.3169-1.9874-1.3169-3.1801v-3.5597ZM4.0719,16.99c.5739,0,1.0397-.466,1.0397-1.0402,0-.5738-.4658-1.0402-1.0397-1.0402s-1.04.4664-1.04,1.0402c0,.5742.4661,1.0402,1.04,1.0402ZM23.8891,8.4674c-.4958.079-.8753.5092-.8753,1.027,0,.5742.4661,1.0402,1.04,1.0402s1.0397-.466,1.0397-1.0402c0-.5178-.3795-.948-.8753-1.027-.0515.0179-.1067.0276-.1644.0276s-.1132-.0097-.1647-.0276h0ZM4.0801,1.4899c2.2506,0,4.0637,1.5595,4.0637,4.1269,0,.7352-.3332,1.7069-.8211,2.7-1.068,2.1726-2.847,4.4813-2.847,4.4813-.0945.1225-.2404.1941-.3949.1945-.1548,0-.3008-.0716-.3956-.1937,0,0-1.7872-2.3083-2.86-4.4813-.4907-.9935-.8252-1.9652-.8252-2.7008C0,3.0501,1.8301,1.4899,4.0801,1.4899ZM4.0801,2.4896c-1.7023,0-3.0809,1.1857-3.0809,3.1272,0,.6173.31,1.4241.7216,2.2581.7246,1.4673,1.7882,2.9984,2.3584,3.7811.5678-.7831,1.6259-2.3134,2.3468-3.7803.4102-.834.7188-1.6412.7188-2.2589,0-1.9407-1.363-3.1272-3.0646-3.1272h0ZM23.9723,12.5017c2.4354,0,4.3965,1.6879,4.3965,4.4661,0,.7982-.3628,1.8528-.8931,2.9311-1.1655,2.3721-3.1079,4.8921-3.1079,4.8921-.0945.1225-.2404.1941-.3949.1945-.1548,0-.3008-.0712-.3956-.1937,0,0-1.9512-2.5199-3.1222-4.8921-.5326-1.0787-.8975-2.1337-.8975-2.9319,0-2.7775,1.9798-4.4661,4.4146-4.4661h0ZM23.9723,13.5014c-1.8867,0-3.4155,1.314-3.4155,3.4664,0,.6804.34,1.57.7942,2.4896.8095,1.6396,2.0061,3.3524,2.6202,4.193.6118-.841,1.8022-2.553,2.608-4.1923.4518-.9196.7904-1.81.7904-2.4904,0-2.1519-1.5113-3.4664-3.3974-3.4664Z"/></svg>`,
        },
        ages: {
            token: 'ages',
            name: 'Age',
            group: 'general',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 433.2848 484.2606"><path d="M389.6874,441.4878H37.5974c-3.8212,0-6.9189-3.0977-6.9189-6.9189v-150.8947c0-3.8212,3.0977-6.9189,6.9189-6.9189s6.9189,3.0977,6.9189,6.9189v143.9758h338.2521v-143.9758c0-3.8212,3.0977-6.9189,6.9189-6.9189s6.9189,3.0977,6.9189,6.9189v150.8947c0,3.8212-3.0977,6.9189-6.9189,6.9189Z"/><path d="M235.6515,189.9989c-3.8212,0-6.9189-3.0977-6.9189-6.9189v-87.0123h-30.1803v87.0123c0,3.8212-3.0977,6.9189-6.9189,6.9189s-6.9189-3.0977-6.9189-6.9189v-87.6627c.0076-7.2915,5.9167-13.2006,13.2082-13.2082h31.4326c7.2942.0038,13.2075,5.914,13.2151,13.2082v87.6627c0,3.8212-3.0977,6.9189-6.9189,6.9189Z"/><path d="M213.6424,76.8262c-13.9946-.0152-25.3357-11.3563-25.3509-25.3509,0-11.0703,14.7304-39.597,19.2415-48.0865,2.1068-3.3741,6.5501-4.4015,9.9242-2.2946.9294.5804,1.7142,1.3652,2.2946,2.2946,4.5111,8.4895,19.2415,37.0439,19.2415,48.0865-.0153,13.9946-11.3563,25.3356-25.3509,25.3509ZM213.6424,21.9246c-5.104,9.3088-8.9742,19.2425-11.5131,29.5507.0048,6.3585,5.1633,11.5092,11.5218,11.5044,6.3517-.0048,11.4996-5.1527,11.5044-11.5044-2.5388-10.3082-6.4091-20.2419-11.5131-29.5507Z"/><path d="M213.6424,96.1092c-3.8212,0-6.9189-3.0977-6.9189-6.9189v-19.283c0-3.8212,3.0977-6.9189,6.9189-6.9189s6.9189,3.0977,6.9189,6.9189v19.283c0,3.8212-3.0977,6.9189-6.9189,6.9189Z"/><path d="M280.7559,290.5931c-13.8526.1544-27.2732-4.8185-37.6804-13.9624-16.7421-14.924-42.0134-14.924-58.7555,0-21.6794,18.6154-53.7022,18.6154-75.3816,0-16.7603-14.9319-42.0506-14.9319-58.8108,0-6.0497,5.0154-12.9482,8.9075-20.3693,11.4923-5.6912,1.7797-11.8893.7527-16.7023-2.7676-4.7582-3.4634-7.5596-9.0044-7.5278-14.8895v-55.9533c.0267-21.1726,17.1859-38.3287,38.3585-38.3516h339.5114c21.1726.0229,38.3318,17.1789,38.3585,38.3516v55.9533c.0281,5.891-2.7814,11.4354-7.5486,14.8964-4.7969,3.552-11.0089,4.5818-16.6954,2.7676-7.4116-2.584-14.3007-6.4738-20.3416-11.4854-16.7342-14.917-41.9936-14.917-58.7278,0-10.411,9.1404-23.8341,14.1085-37.6873,13.9485ZM213.6908,251.605c13.8526-.1544,27.2732,4.8185,37.6804,13.9624,16.7456,14.9219,42.0168,14.9219,58.7624,0,21.6638-18.6152,53.6763-18.6152,75.3401,0,4.8033,4.0515,10.2874,7.2188,16.1972,9.3544,1.4777.4809,3.0963.2236,4.352-.6919,1.2053-.8632,1.9131-2.2607,1.8958-3.7431v-55.9741c-.0191-13.5333-10.9873-24.4985-24.5206-24.5137H43.8867c-13.5334.0152-24.5016,10.9804-24.5206,24.5137v55.9533c-.0131,1.4779.6909,2.8706,1.8889,3.7362,1.259.92,2.884,1.1775,4.3658.6919,5.92-2.1349,11.4137-5.3046,16.2249-9.3613,10.4118-9.1453,23.8372-14.1183,37.6943-13.9624,13.8571-.1559,27.2825,4.817,37.6943,13.9624,16.7478,14.9229,42.0215,14.9229,58.7693,0,10.4147-9.1318,23.8371-14.0921,37.6873-13.9278Z"/><path d="M389.6874,375.4744c-14.3104.1994-28.2237-4.7066-39.2441-13.8378-18.0802-15.0518-44.3284-15.0518-62.4087,0-22.8872,18.4852-55.5733,18.4852-78.4605,0-18.0659-15.0482-44.3013-15.0482-62.3671,0-11.0167,9.1282-24.9246,14.0339-39.2303,13.8378-14.3022.2001-28.207-4.7063-39.2164-13.8378-8.6599-7.452-19.7533-11.4674-31.1767-11.2848-3.8212,0-6.9189-3.0977-6.9189-6.9189s3.0977-6.9189,6.9189-6.9189c14.3022-.2001,28.207,4.7063,39.2164,13.8378,18.0659,15.0482,44.3013,15.0482,62.3671,0,22.8828-18.483,55.5639-18.483,78.4467,0,18.0713,15.0476,44.3097,15.0476,62.381,0,22.8979-18.4843,55.5903-18.4843,78.4882,0,8.6684,7.4561,19.7719,11.4716,31.2043,11.2848,3.8212,0,6.9189,3.0977,6.9189,6.9189s-3.0977,6.9189-6.9189,6.9189Z"/><path d="M420.3658,484.2606H6.9189c-3.8212,0-6.9189-3.0977-6.9189-6.9189v-28.5129c.0114-11.692,9.4868-21.1674,21.1788-21.1788h384.9271c11.692.0115,21.1673,9.4868,21.1788,21.1788v28.5129c0,3.8212-3.0977,6.9189-6.9189,6.9189ZM13.8378,470.4227h399.6091v-21.594c-.0038-4.0527-3.2882-7.3372-7.341-7.341H21.1788c-4.0527.0038-7.3371,3.2882-7.341,7.341v21.594Z"/></svg>`,
        },
        genders: {
            token: 'genders',
            name: 'Gender',
            group: 'general',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 495.114 512.0002"><path d="M454.451,247.8192h-.073c-13.284,0-24.795,7.735-30.268,18.937l-45.856-45.857c17.131-27.83,24.362-61.106,20.364-93.722-4.077-33.256-19.752-64.327-44.138-87.49C327.157,13.7342,291.226-.3898,253.256.0082c-37.944.367-73.621,15.142-100.462,41.604-10.967,10.813-19.99,23.062-26.911,36.323C55.163,85.8582,0,146.0072,0,218.8132c0,32.31,11.16,63.918,31.423,89.001,2.604,3.224,7.329,3.728,10.556,1.122,3.225-2.605,3.728-7.331,1.122-10.556-18.113-22.421-28.088-50.678-28.088-79.567,0-62.004,44.747-113.739,103.639-124.638-4.224,11.334-7.025,23.223-8.298,35.451-36.733,12.982-63.124,48.058-63.124,89.187,0,52.13,42.411,94.54,94.539,94.54,27.254,0,51.841-11.602,69.109-30.114,9.004,2.857,18.299,4.846,27.752,5.888,2.697.297,5.398.511,8.1.656-18.324,27.087-46.928,46.927-80.842,53.471-3.532.681-6.084,3.773-6.084,7.37v39.504c0,4.146,3.36,7.506,7.506,7.506h20.567c9.961,0,18.065,8.091,18.065,18.035,0,9.961-8.104,18.065-18.065,18.065h-20.567c-4.146,0-7.506,3.36-7.506,7.506v37.702c0,4.837-1.871,9.371-5.262,12.763-3.414,3.406-7.95,5.283-12.773,5.283-9.962,0-18.065-8.095-18.065-18.045v-37.703c0-4.146-3.36-7.506-7.506-7.506h-20.567c-9.951,0-18.045-8.104-18.045-18.065,0-9.944,8.095-18.035,18.045-18.035h20.567c4.146,0,7.506-3.36,7.506-7.506v-39.504c0-3.597-2.552-6.689-6.084-7.37-18.301-3.531-35.248-10.904-50.374-21.912-3.35-2.439-8.046-1.702-10.485,1.652-2.44,3.351-1.701,8.046,1.652,10.485,15.232,11.086,32.121,18.877,50.28,23.205v25.938h-13.061c-18.228,0-33.058,14.825-33.058,33.047,0,18.239,14.83,33.078,33.058,33.078h13.061v30.195c0,18.228,14.839,33.058,33.078,33.058,8.827,0,17.13-3.434,23.384-9.674,6.232-6.233,9.664-14.538,9.664-23.384v-30.195h13.061c18.239,0,33.078-14.839,33.078-33.078,0-18.222-14.839-33.047-33.078-33.047h-13.063v-25.94c38.689-9.24,70.649-34.11,89.68-67.038,23.34-1.609,46.152-8.808,66.098-21.086l45.857,45.858c-11.203,5.476-18.938,17.003-18.938,30.34,0,18.561,15.102,33.663,33.664,33.663h73.501c12.922,0,23.435-10.513,23.435-23.435v-73.502c0-18.561-15.101-33.663-33.663-33.663h0ZM141.768,298.3412c-43.851,0-79.527-35.676-79.527-79.528,0-32.4,19.481-60.307,47.33-72.694.301,38.311,15.34,74.264,42.476,101.402,12.571,12.57,27.343,22.659,43.415,29.846-14.159,13-33.002,20.974-53.694,20.974ZM473.102,354.9842c0,4.644-3.779,8.422-8.422,8.422h-73.501c-10.284,0-18.651-8.366-18.651-18.724,0-10.284,8.367-18.65,18.651-18.65,3.036,0,5.773-1.829,6.935-4.634s.52-6.033-1.626-8.181l-55.471-55.471c-2.831-2.831-6.565-4.295-10.347-4.295-2.669,0-5.364.729-7.782,2.223-24.487,15.123-53.823,21.712-82.611,18.531-29.64-3.269-56.478-16.167-77.611-37.301-24.69-24.689-38.218-57.515-38.095-92.432.124-34.913,13.891-67.646,38.764-92.169,49.205-48.512,130.719-49.308,180.808-1.732,21.866,20.77,35.922,48.625,39.575,78.432,3.594,29.313-2.921,59.211-18.346,84.187-3.608,5.845-2.756,13.3,2.072,18.129l55.47,55.47c2.147,2.146,5.374,2.788,8.181,1.626,2.805-1.161,4.634-3.899,4.634-6.935,0-10.284,8.366-18.65,18.65-18.65h.073c10.284,0,18.65,8.366,18.65,18.65v73.504Z"/><path d="M343.921,122.2012c-4.088.689-6.844,4.561-6.155,8.649,4.532,26.895-4.259,54.448-23.517,73.705-9.013,9.014-19.581,15.54-30.845,19.611.068-1.778.114-3.56.114-5.352,0-59.901-37.337-111.238-89.953-131.97.484-.508.951-1.026,1.449-1.524,32.873-32.873,86.362-32.873,119.235,0,4.909,4.909,9.192,10.386,12.729,16.279,2.134,3.555,6.744,4.705,10.3,2.572,3.554-2.134,4.706-6.745,2.572-10.3-4.168-6.943-9.21-13.392-14.985-19.168-38.728-38.726-101.74-38.726-140.468,0-38.726,38.727-38.726,101.74,0,140.468,19.364,19.363,44.798,29.045,70.234,29.045s50.87-9.682,70.234-29.045c22.685-22.686,33.041-55.14,27.704-86.815-.688-4.088-4.552-6.843-8.648-6.155h0ZM170.367,144.6202c29.757,11.514,50.929,40.415,50.929,74.193,0,1.175-.034,2.342-.087,3.504-9.516-4.097-18.434-10.002-26.194-17.763-16.518-16.517-24.729-38.238-24.648-59.934ZM235.938,227.1062c.239-2.734.37-5.498.37-8.293,0-41.627-27.039-77.044-64.467-89.64,1.983-10.5,5.974-20.687,11.957-29.954,49.287,17.38,84.707,64.424,84.707,119.593,0,3.122-.125,6.219-.351,9.293-10.685,1.724-21.634,1.39-32.216-.999h0Z"/></svg>`,
            importance: {
                active: false,
                default: 10,
            },
        },
        movies: {
            token: 'movies',
            name: 'Movies',
            group: 'interests',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 480"><path d="M16,464h32v16h16v-16h224v16h16v-16h32v16h16V0h-16v16h-32V0h-16v16H64V0h-16v16H16V0H0v480h16v-16ZM304,32h32v32h-32v-32ZM304,80h32v32h-32v-32ZM304,128h32v32h-32v-32ZM304,176h32v32h-32v-32ZM304,224h32v32h-32v-32ZM304,272h32v32h-32v-32ZM304,320h32v32h-32v-32ZM304,368h32v32h-32v-32ZM304,416h32v32h-32v-32ZM64,128V32h224v128H64v-32ZM64,272v-96h224v128H64v-32ZM64,416v-96h224v128H64v-32ZM16,32h32v32H16v-32ZM16,80h32v32H16v-32ZM16,128h32v32H16v-32ZM16,176h32v32H16v-32ZM16,224h32v32H16v-32ZM16,272h32v32H16v-32ZM16,320h32v32H16v-32ZM16,368h32v32H16v-32ZM16,416h32v32H16v-32Z"/></svg>`,
            importance: {
                active: true,
                default: 6,
            },
            config: {
                endpoint: `/filters/movies`,
                key: 'movies',
                hasDynamicCategories: true,
                hasTabs: true,
                hasTableKey: true,
                tabs: [
                    { key: 'movies', col: 'movie_id', name: 'Movies', singular: 'Movie' },
                    { key: 'genres', col: 'movie_genre_id', name: 'Genres', singular: 'Genre' },
                ],
            },
        },
        tv_shows: {
            token: 'tv_shows',
            name: 'TV Shows',
            group: 'interests',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 422"><path d="M504.5,0H7.5C3.358,0,0,3.357,0,7.5v347c0,4.143,3.358,7.5,7.5,7.5h188.5c4.142,0,7.5-3.357,7.5-7.5s-3.358-7.5-7.5-7.5H15V15h482v332h-45v-15h22.5c4.142,0,7.5-3.357,7.5-7.5V37.5c0-4.143-3.358-7.5-7.5-7.5H37.5c-4.142,0-7.5,3.357-7.5,7.5v287c0,4.143,3.358,7.5,7.5,7.5h309.5v15h-121c-4.142,0-7.5,3.357-7.5,7.5v22.5h-82.5c-20.678,0-37.5,16.822-37.5,37.5,0,4.143,3.358,7.5,7.5,7.5h300c4.142,0,7.5-3.357,7.5-7.5,0-20.678-16.822-37.5-37.5-37.5h-82.5v-15h211c4.142,0,7.5-3.357,7.5-7.5V7.5c0-4.143-3.358-7.5-7.5-7.5ZM437,347h-15v-15h15v15ZM407,332v15h-15v-15h15ZM45,45h422v272H45V45ZM362,332h15v15h-15v-15ZM397.215,407H114.785c3.095-8.73,11.437-15,21.215-15h240c9.778,0,18.12,6.27,21.215,15ZM278.5,377h-45v-15h45v15Z"/><path d="M337.75,174.505l-117-67.55c-2.32-1.34-5.18-1.34-7.5,0s-3.75,3.815-3.75,6.495v135.1c0,2.68,1.43,5.155,3.75,6.495,1.16.67,2.455,1.005,3.75,1.005s2.59-.335,3.75-1.005l117-67.55c2.32-1.34,3.75-3.815,3.75-6.495s-1.43-5.155-3.75-6.495h0ZM224.5,235.56v-109.12l94.5,54.56-94.5,54.56Z"/></svg>`,
            importance: {
                active: true,
                default: 6,
            },
            config: {
                endpoint: `/filters/tv-shows`,
                key: 'tv_shows',
                hasDynamicCategories: true,
                hasTabs: true,
                hasTableKey: true,
                tabs: [
                    { key: 'shows', col: 'tv_show_id', name: 'Shows', singular: 'Show' },
                    { key: 'genres', col: 'tv_show_genre_id', name: 'Genres', singular: 'Genre' },
                ],
            },
        },
        sports: {
            token: 'sports',
            name: 'Sports',
            group: 'interests',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 480"><path d="M240,0C107.4531,0,0,107.4531,0,240s107.4531,240,240,240,240-107.4531,240-240C479.8516,107.5156,372.4844.1484,240,0ZM425.8633,115.1211l-16.6328,70.7031-87.6289,29.207-73.6016-58.8711v-86.7461l84-33.5977c38.0312,17.2305,70.5234,44.6836,93.8633,79.3047ZM427.1992,362.7617l-79.3359,12.5273-43.1992-57.0664,22.0078-88,86.6562-28.8789,49.6406,59.5664c-3.3828,36.3711-15.668,71.3516-35.7695,101.8516ZM132.4883,375.3438l-79.6875-12.582c-20.1016-30.5078-32.3828-65.4961-35.7617-101.875l49.6016-59.5664,86.6562,28.8789,22.0078,88.0469-42.8164,57.0977ZM16.0703,237.0156c.4258-35.6875,9.4297-70.7539,26.25-102.2305l12.9766,55.1992-39.2266,47.0312ZM190.2461,312l-21.2227-84.9766,70.9766-56.7773,70.9922,56.8008-21.2383,84.9531h-99.5078ZM424.7031,189.9531l12.9766-55.1992c16.8203,31.4766,25.8242,66.5391,26.25,102.2305l-39.2266-47.0312ZM310.1836,27.3203l-70.1836,28.0703-70.5586-27.9414c45.6719-15.2227,95.043-15.2656,140.7422-.1289ZM147.6172,36l84.3828,33.4414v86.7188l-73.6016,58.8711-87.6289-29.207-16.6328-70.7031c23.2617-34.4961,55.6133-61.8789,93.4805-79.1211ZM66.168,381.0703l65.0312,10.2734,39.3281,61.6016c-40.9609-13.4531-77.1875-38.4023-104.3594-71.875ZM193.4648,459.1055l-47.7383-74.7383,42.2734-56.3672h104l42.8789,56.6406-41.5977,72.9023c-32.7227,8.0586-66.8438,8.6055-99.8086,1.6016l-.0078-.0391ZM315.5039,450.8711l34.0977-59.6719,64.2617-10.1367c-25.8164,31.793-59.8281,55.9297-98.3594,69.8086Z"/></svg>`,
            importance: {
                active: true,
                default: 7,
            },
            config: {
                endpoint: `/filters/sports`,
                key: 'sports',
                hasSecondary: true,
                hasDynamicCategories: true,
                hasTabs: true,
                hasTableKey: true,
                tabs: [
                    { key: 'teams', col: 'sport_team_id', name: 'Teams', singular: 'Team' },
                    { key: 'leagues', col: 'sport_league_id', name: 'Leagues', singular: 'League' },
                    { key: 'play', col: 'sport_play_id', name: 'Play', singular: 'Sport' },
                ],
            },
        },
        music: {
            token: 'music',
            name: 'Music',
            group: 'interests',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 476.17 512.001"><path d="M149.313,82.855v272.542c-15.859-14.147-36.757-22.76-59.632-22.76-49.45,0-89.681,40.231-89.681,89.682s40.231,89.682,89.681,89.682c49.389,0,89.578-40.13,89.68-89.495h.002v-219.031l266.757-67.621v147.195c-15.859-14.147-36.757-22.76-59.631-22.76-49.451,0-89.682,40.231-89.682,89.681s40.231,89.682,89.682,89.682,89.681-40.232,89.681-89.682V0L149.313,82.855ZM89.682,481.95c-32.88,0-59.631-26.75-59.631-59.632s26.75-59.632,59.631-59.632,59.632,26.75,59.632,59.632c-.001,32.882-26.751,59.632-59.632,59.632ZM179.363,172.476v-66.238L446.12,38.618v66.237l-266.757,67.621ZM386.489,409.602c-32.881,0-59.632-26.751-59.632-59.632s26.75-59.631,59.632-59.631,59.631,26.75,59.631,59.631-26.75,59.632-59.631,59.632Z"/></svg>`,
            importance: {
                active: true,
                default: 5,
            },
            config: {
                endpoint: `/filters/music`,
                key: 'music',
                hasDynamicCategories: true,
                hasTabs: true,
                hasTableKey: true,
                tabs: [
                    { key: 'genres', col: 'music_genre_id', name: 'Genres', singular: 'Genre' },
                    { key: 'artists', col: 'music_artist_id', name: 'Artists', singular: 'Artist' },
                ],
            },
        },
        instruments: {
            token: 'instruments',
            name: 'Instruments',
            group: 'interests',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.0001 511.846"><path d="M488.9347,328.303c-3.9248-5.1988-5.3417-11.9144-3.8888-18.4131,1.6899-7.5056,2.4059-15.2383,2.1279-22.9809-1.3769-38.9381-27.6517-72.2395-64.6618-82.997v-112.7885l13.1074-23.5808c.62-1.1149.945-2.3689.945-3.6438V18.4981c0-10.1995-8.2976-18.4981-18.4981-18.4981h-41.341c-10.1995,0-18.4971,8.2976-18.4971,18.4981v45.3998c0,1.2749.325,2.5289.945,3.6438l13.1114,23.5868v112.7735c-14.4733,4.2218-27.7436,12.1014-38.4381,22.7929v-24.4898h7.4606c4.1418,0,7.4996-3.3578,7.4996-7.4996s-3.3578-7.4996-7.4996-7.4996h-189.8607c-4.1418,0-7.4996,3.3578-7.4996,7.4996s3.3578,7.4996,7.4996,7.4996h6.8387v56.7712c-32.3854,27.1607-50.8875,66.7107-50.8875,109.0927,0,34.4763,12.3204,66.1277,32.7854,90.7896l-23.5028,40.315c-2.0859,3.5788-.876,8.1696,2.7019,10.2565,1.1879.692,2.4869,1.0209,3.7708,1.0209,2.5809,0,5.0928-1.3329,6.4857-3.7238l21.204-36.3722c25.6367,24.8048,60.533,40.096,98.9382,40.096,16.5752,0,32.8164-2.8249,48.2726-8.3956,3.8968-1.4039,5.9167-5.7017,4.5128-9.5985-1.4039-3.8958-5.7007-5.9167-9.5985-4.5128-13.8203,4.9807-28.3506,7.5066-43.1869,7.5066-70.2396,0-127.3838-57.1442-127.3838-127.3838-1.3889-68.5977,58.7341-128.4877,127.3838-127.3838,22.5639,0,44.4948,5.9207,63.8279,17.1432-3.9528,10.2525-6.0497,21.216-6.0497,32.3244,0,6.8487.782,13.6893,2.3219,20.328,1.4089,6.0957-.006,12.5264-3.8788,17.6401-1.1,1.4509-2.1519,2.9279-3.1768,4.4188-11.7104-17.3601-31.6174-28.3366-53.0444-28.3366-35.2163,0-63.8669,28.6506-63.8669,63.8669s28.6506,63.8669,63.8669,63.8669c12.6944,0,25.0818-3.8608,35.5193-10.8335,11.0145,51.8505,57.2012,90.7456,112.1075,90.7446,64.8888.08,114.9144-53.6544,114.5914-114.5994-.001-25.1078-7.9756-48.9486-23.0639-68.9436h0ZM397.3972,310.3258c-3.4808,0-6.8637.42-10.1125,1.1899v-19.0731h20.229v19.0741c-3.2508-.771-6.6347-1.191-10.1165-1.191ZM387.2836,254.3356h20.229v23.1089h-20.229v-23.1089ZM387.2836,239.3363v-23.0989h20.229v23.0989h-20.229ZM407.5127,96.6833v28.3376h-20.229v-28.3376h20.229ZM407.5127,140.0212v23.1089h-20.229v-23.1089h20.229ZM407.5127,178.1293v23.1089h-20.229v-23.1089h20.229ZM373.2283,18.4981c0-1.9289,1.5689-3.4988,3.4978-3.4988h41.341c1.9289,0,3.4988,1.5689,3.4988,3.4988v43.4559l-10.9655,19.727h-26.4077l-10.9645-19.726V18.4981ZM318.847,243.5461c-11.5674-6.4307-23.9308-11.1715-36.7582-14.1493v-27.1887h36.7582v41.338ZM208.8524,202.2081v29.4026c-12.5024,3.7348-24.4368,9.2046-35.5683,16.3352v-45.7368h35.5683v-.001ZM223.8516,228.0199v-25.8107h43.2379v24.5458c-5.7157-.695-11.4924-1.0669-17.3092-1.0669-8.8046-.001-17.4681.789-25.9287,2.3319ZM249.7804,416.9376c-26.9457,0-48.8676-21.9219-48.8676-48.8676s21.9219-48.8676,48.8676-48.8676c18.9791,0,36.3982,11.2555,44.3348,28.3126-8.1446,16.8742-12.2754,36.5412-11.1184,56.3783-9.0516,8.4296-20.724,13.0444-33.2164,13.0444h0ZM468.1387,467.3632c-18.1821,18.4761-44.2438,29.6315-70.7306,29.4856-54.4493-.005-99.0442-44.0159-99.6001-98.5492-.245-21.7959,6.6927-43.2849,20.148-61.12,6.5677-8.6716,8.9506-19.6341,6.5367-30.0815-1.2839-5.5347-1.9359-11.2354-1.9359-16.9442,0-17.1741,5.9657-33.9513,16.7982-47.2397,8.6736-10.6395,20.14-18.6981,32.9294-23.2699v98.6182c-11.3124,7.9366-18.7281,21.066-18.7281,35.9032,0,16.1452,8.8346,30.9395,23.0569,38.6091,3.6468,1.9669,8.1946.604,10.1605-3.0418s.604-8.1946-3.0418-10.1605c-9.3615-5.0478-15.1763-14.7833-15.1763-25.4067,0-15.9032,12.9384-28.8406,28.8416-28.8406s28.8416,12.9374,28.8416,28.8406c0,10.7635-5.9277,20.558-15.4692,25.5627-3.6678,1.9239-5.0828,6.4577-3.1588,10.1245,1.3409,2.5569,3.9488,4.0178,6.6477,4.0178,1.174,0,2.3649-.276,3.4768-.859,14.4973-7.6036,23.5018-22.4889,23.5018-38.8461,0-14.8353-7.4146-27.9646-18.7251-35.9012v-98.6172c28.6096,10.1675,48.5776,36.8502,49.6726,67.7957.231,6.4597-.364,12.9034-1.7739,19.1641-2.4169,10.8135-.029,22.0159,6.5517,30.7325,13.1074,17.3702,20.036,38.0862,20.036,59.9101,0,26.4377-10.2495,51.3375-28.8596,70.1136h0Z"/><path d="M83.9885,203.3111c-4.1418,0-7.4996,3.3578-7.4996,7.4996v291.4828c0,4.1418,3.3578,7.4996,7.4996,7.4996s7.4996-3.3578,7.4996-7.4996V210.8107c0-4.1418-3.3578-7.4996-7.4996-7.4996Z"/><path d="M144.8315,153.5795c2.0519.569,4.1388.851,6.2117.851,3.9378,0,7.8306-1.0169,11.3515-3.0089,5.3747-3.0419,9.2436-7.9936,10.8965-13.9573l.028-.104c1.6499-5.9507.883-12.1874-2.1579-17.5621s-7.9936-9.2436-13.9453-10.8935L29.3371,73.4534c-5.9497-1.6479-12.1884-.883-17.5621,2.1579-5.3747,3.0419-9.2435,7.9936-10.8965,13.9573l-.028.104c-1.6499,5.9507-.883,12.1874,2.1579,17.5621,3.0409,5.3747,7.9936,9.2436,13.9453,10.8935l59.5361,16.5052v41.19c0,4.1418,3.3578,7.4996,7.4996,7.4996s7.4996-3.3578,7.4996-7.4996v-37.0322l53.3424,14.7883ZM15.3078,93.6674l.028-.104c.579-2.0899,1.9379-3.8298,3.8258-4.8978,1.8869-1.0679,4.0778-1.3379,6.1687-.758l127.8788,35.4513c4.3148,1.1959,6.8517,5.6797,5.6517,10.0065l-.028.104c-.579,2.0899-1.9379,3.8298-3.8258,4.8978-1.8869,1.0669-4.0778,1.3389-6.1687.758L20.9595,103.6739c-4.3148-1.1969-6.8517-5.6797-5.6517-10.0065h0Z"/><path d="M429.7225,432.4049h-65.6868c-4.1418,0-7.4996,3.3578-7.4996,7.4996s3.3578,7.4996,7.4996,7.4996h65.6868c4.1418,0,7.4996-3.3578,7.4996-7.4996s-3.3578-7.4996-7.4996-7.4996Z"/></svg>`,
            importance: {
                active: true,
                default: 6,
            },
            config: {
                endpoint: `/filters/instruments`,
                key: 'instruments',
                hasSecondary: true,
            },
        },
        schools: {
            token: 'schools',
            name: 'Schools',
            group: 'schools_work',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 402.0025"><path d="M506.62,86.4425L258.62.4425c-1.7-.59-3.54-.59-5.24,0L5.38,86.4425c-3.22,1.12-5.38,4.15-5.38,7.56s2.16,6.44,5.38,7.56l74.62,25.88v103.83h.01c.21,15.31,18.81,27.59,55.3,36.5,32.33,7.88,75.19,12.23,120.69,12.23,38.05,0,74.25-3.04,104-8.65v36.03c-9.31,3.3-16,12.19-16,22.62,0,5.72,2.02,10.99,5.38,15.12-5.75,5.13-9.38,12.59-9.38,20.88v28c0,4.42,3.58,8,8,8h40c4.42,0,8-3.58,8-8v-28c0-8.29-3.63-15.75-9.38-20.88,3.36-4.13,5.38-9.39,5.38-15.12,0-10.43-6.69-19.32-16-22.62v-39.45c.23-.06.46-.11.69-.16,36.7-8.96,55.31-21.33,55.31-36.77v-103.56l74.62-25.88c3.22-1.12,5.38-4.15,5.38-7.56s-2.16-6.44-5.38-7.56h0ZM380,386.0025h-24v-20c0-6.62,5.38-12,12-12s12,5.38,12,12v20ZM360,330.0025c0-4.41,3.59-8,8-8s8,3.59,8,8-3.59,8-8,8-8-3.59-8-8ZM256,264.0025c-44.25,0-85.77-4.18-116.9-11.78-35.36-8.63-43.1-18.24-43.1-21.22v-98.02l157.38,54.57c.85.29,1.74.44,2.62.44s1.77-.15,2.62-.44l101.38-35.15v102.65c-29.28,5.8-65.61,8.95-104,8.95h0ZM416,231.0025c0,2.89-7.29,12.02-40,20.44v-104.59l40-13.87v98.02ZM372.67,131.0825c-.5-.36-1.04-.69-1.63-.93l-116-47.55c-4.09-1.68-8.76.28-10.44,4.37s.28,8.76,4.37,10.44l101.19,41.48-94.16,32.64L32.42,94.0025,256,16.4725l223.58,77.53-106.91,37.08Z"/></svg>`,
            importance: {
                active: true,
                default: 6,
            },
            config: {
                endpoint: `/filters/schools`,
                key: 'schools',
                hasSelect: true,
                hasCategories: false,
            },
        },
        work: {
            token: 'work',
            name: 'Work',
            group: 'schools_work',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 488 432"><path d="M456,72h-104v-32c-.0273-22.082-17.918-39.9727-40-40h-144c-22.082.0273-39.9727,17.918-40,40v32H24c-13.2539,0-24,10.7461-24,24v178.0781c.0508,10.1484,6.4453,19.1758,16,22.5859v111.3359c0,13.2539,10.7461,24,24,24h400c13.2539,0,24-10.7461,24-24v-111.3281c9.5547-3.4141,15.9531-12.4453,16-22.5938V96c0-13.2539-10.7461-24-24-24ZM144,40c0-13.2539,10.7461-24,24-24h144c13.2539,0,24,10.7461,24,24v32h-16v-32c0-4.418-3.582-8-8-8h-144c-4.418,0-8,3.582-8,8v32h-16v-32ZM304,72h-128v-24h128v24ZM448,408c0,4.418-3.582,8-8,8H40c-4.418,0-8-3.582-8-8v-108.5859l176,24.2734v20.3125c0,13.2539,10.7461,24,24,24h16c13.2539,0,24-10.7461,24-24v-20.3125l176-24.2734v108.5859ZM256,344c0,4.418-3.582,8-8,8h-16c-4.418,0-8-3.582-8-8v-48c0-4.418,3.582-8,8-8h16c4.418,0,8,3.582,8,8v48ZM464,274.0781c.0039,3.9883-2.9297,7.3711-6.8789,7.9297l-2.2188.3047-182.9023,25.2227v-11.5352c0-13.2539-10.7461-24-24-24h-16c-13.2539,0-24,10.7461-24,24v11.5352l-185.1133-25.5273c-3.9492-.5547-6.8906-3.9375-6.8867-7.9297V96c0-4.418,3.582-8,8-8h432c4.418,0,8,3.582,8,8v178.0781Z"/></svg>`,
            importance: {
                active: true,
                default: 4,
            },
            config: {
                endpoint: `/filters/work`,
                key: 'work',
                hasTabs: true,
                hasTableKey: true,
                tabs: [
                    {
                        key: 'industries',
                        col: 'work_industry_id',
                        name: 'Industries',
                        singular: 'Industry',
                    },
                    { key: 'roles', col: 'work_role_id', name: 'Roles', singular: 'Role' },
                ],
            },
        },
        life_stages: {
            token: 'life_stages',
            name: 'Life Stage',
            group: 'personal',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480.612 511.998"><path d="M353.336,304.254c-.597-6.81-4.287-12.756-10.124-16.315-7.295-4.446-16.499-4.113-23.453.851l-54.336,38.798-4.514-41.989c-1.378-12.815-12.136-22.479-25.024-22.479-12.507,0-23.227,9.344-24.933,21.734l-7.727,56.096-35.227-47.339c-4.688-6.301-12.454-9.719-20.27-8.916-7.967.817-14.724,5.649-18.073,12.924-3.349,7.276-2.626,15.55,1.934,22.134l58.567,84.569c-.742,43.266-21.788,96.837-22.005,97.383-.918,2.316-.63,4.937.77,6.998,1.4,2.061,3.73,3.295,6.221,3.295h113.93c2.637,0,5.081-1.381,6.441-3.639,1.361-2.258,1.439-5.065.208-7.396-.273-.512-26.729-51.326-24.576-112.704l75.063-66.176c5.128-4.521,7.727-11.019,7.128-17.829ZM336.262,310.802l-77.464,68.294c-1.52,1.34-2.434,3.236-2.537,5.259-2.547,50.02,12.68,93.11,21.021,112.606h-91.357v-.001c6.568-18.761,19.292-59.665,19.292-94.956,0-1.53-.467-3.024-1.338-4.281l-59.925-86.53c-2.163-3.123-1.166-6.133-.636-7.283.529-1.149,2.168-3.864,5.946-4.252,2.56-.263,5.125.86,6.669,2.934l46.201,62.086c1.822,2.449,4.945,3.555,7.904,2.794,2.957-.76,5.162-3.232,5.578-6.257l10.235-74.306c.687-4.986,5.001-8.747,10.034-8.747,5.187,0,9.516,3.889,10.071,9.046l5.89,54.783c.286,2.657,1.96,4.963,4.398,6.057,2.438,1.094,5.275.81,7.448-.741l64.807-46.275c2.038-1.457,4.742-1.556,6.884-.25,1.713,1.045,2.796,2.79,2.971,4.788s-.5871,3.905-2.0921,5.232Z"/><path d="M468.612,217.611c0-17.421-5.677-34.482-16.092-48.65,4.817-7.583,7.337-16.204,7.337-25.25,0-26.82-22.669-48.639-50.533-48.639-.222,0-.445.001-.668.004-10.156-33.16-42.274-56.599-78.83-56.599-7.579,0-15.043.987-22.268,2.941C293.669,16.054,266.317,0,236.067,0c-33.816,0-63.873,20.305-75.595,50.206-7.214-1.692-14.606-2.547-22.059-2.547-41.936,0-78.765,27.298-89.69,65.656-24.365,3.586-42.711,23.707-42.711,48.009,0,12.353,4.961,24.224,13.59,33.15C7.052,207.384,0,224.377,0,242.264c0,32.569,22.964,60.362,55.359,68.018,6.867,39.992,41.276,70.819,83.862,74.224,4.126.328,7.765-2.756,8.096-6.897.331-4.14-2.757-7.764-6.897-8.095-37.323-2.984-67.128-30.89-70.871-66.353-.357-3.379-2.935-6.098-6.288-6.636-27.941-4.479-48.221-27.299-48.221-54.261,0-16.238,7.505-31.574,20.592-42.073,1.84-1.477,2.881-3.731,2.811-6.089s-1.243-4.547-3.168-5.911c-9.039-6.409-14.223-16.202-14.223-26.867,0-18.053,14.919-32.772,33.963-33.508,3.431-.132,6.337-2.573,7.061-5.93,7.39-34.295,39.494-59.187,76.337-59.187,8.386,0,16.676,1.281,24.643,3.807,1.941.615,4.051.417,5.845-.55s3.118-2.621,3.669-4.583c7.667-27.28,33.778-46.333,63.498-46.333,26.63,0,50.458,15.11,60.704,38.495,1.584,3.619,5.703,5.394,9.421,4.062,7.562-2.707,15.514-4.079,23.633-4.079,31.812,0,59.476,21.487,65.778,51.091.823,3.867,4.5,6.43,8.412,5.88,1.762-.25,3.548-.377,5.308-.377,19.57,0,35.493,15.072,35.493,33.599,0,7.559-2.601,14.703-7.52,20.661-2.322,2.812-2.291,6.883.07,9.66,10.6,12.465,16.204,27.534,16.204,43.579,0,31.953-22.743,59.628-55.308,67.302-2.025.477-3.762,1.772-4.798,3.577-1.035,1.805-1.277,3.959-.666,5.948,6.404,20.864-.909,36.955-8.17,46.78-12.625,17.082-35.205,28.559-56.185,28.559-2.162,0-4.344-.101-6.485-.301-4.145-.38-7.8,2.654-8.186,6.79-.386,4.135,2.655,7.8,6.789,8.186,2.604.243,5.255.366,7.881.366,25.916,0,52.718-13.604,68.28-34.659,11.608-15.705,15.869-34.155,12.317-52.656,35.4319-11.516,59.5719-43.392,59.5719-79.892Z"/></svg>`,
            importance: {
                active: true,
                default: 7,
            },
            config: {
                endpoint: '/filters/life-stages',
            },
        },
        relationships: {
            token: 'relationships',
            name: 'Relationship Status',
            group: 'personal',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 66 52.022"><g><path d="M58.545,29.362c-1.875-1.082-4.052-1.579-6.199-1.436-.948-1.935-2.469-3.567-4.344-4.65-1.659-.957-3.543-1.463-5.449-1.463-3.891,0-7.516,2.092-9.458,5.458-5.147,8.913,4.238,22.789,4.64,23.375.516.752,1.333,1.225,2.252,1.296.184.013,1.175.08,2.625.08,5.771,0,16.035-1.007,19.929-7.751,3.007-5.211,1.215-11.9-3.996-14.909ZM60.808,43.271c-3.392,5.874-12.856,6.751-18.196,6.751h-.002c-1.379,0-2.306-.063-2.479-.075-.303-.023-.576-.181-.748-.432-.373-.544-9.081-13.409-4.557-21.244,1.587-2.75,4.547-4.458,7.726-4.458,1.556,0,3.094.413,4.449,1.195,1.711.987,3.061,2.537,3.8,4.362.171.425.611.681,1.065.615,1.914-.269,3.964.12,5.677,1.108,4.258,2.459,5.722,7.922,3.265,12.178Z"/><path d="M31.959,44.327c-1.347.739-2.313,1.211-2.665,1.379-.805.385-1.785.385-2.588,0-2.529-1.209-24.706-12.259-24.706-27.706C2,9.178,9.178,2,18,2c3.411,0,6.666,1.058,9.411,3.059.351.256.827.256,1.178,0,2.746-2.001,6-3.059,9.411-3.059,8.822,0,16,7.178,16,16,0,2.359-.545,4.78-1.622,7.193-.225.505.002,1.096.506,1.32.504.228,1.096-.001,1.321-.506,1.191-2.671,1.795-5.364,1.795-8.007C56,8.075,47.925,0,38,0c-3.596,0-7.038,1.046-10,3.031-2.962-1.985-6.404-3.031-10-3.031C8.075,0,0,8.075,0,18c0,16.671,23.198,28.246,25.843,29.511.669.32,1.416.489,2.157.489s1.487-.169,2.157-.489c.368-.176,1.373-.667,2.764-1.43.484-.266.662-.873.396-1.357-.266-.485-.874-.665-1.358-.397Z"/></g></svg>`,
            importance: {
                active: true,
                default: 8,
            },
            config: {
                endpoint: '/filters/relationships',
            },
        },
        languages: {
            token: 'languages',
            name: 'Languages',
            group: 'personal',
            icon: `<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 682.6671 682.6666"><defs><style>.language-cls-1,.language-cls-2{fill:none;}.language-cls-2{stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:26.6667px;}.language-cls-3{clip-path:url(#clippath);}</style><clipPath id="clippath"><rect class="language-cls-1" y="0" width="682.6666" height="682.6666"/></clipPath></defs><g id="g369"><g id="g371"><g class="language-cls-3"><g id="g373"><g id="g379"><path id="path381" class="language-cls-2" d="M177.3333,493.324l57.072-149.8493c1.1667-2.852,5.2027-2.856,6.3747-.0067l56.5533,149.856"/></g><g id="g383"><path id="path385" class="language-cls-2" d="M195.1324,456.0034h84.6893"/></g><g id="g387"><path id="path389" class="language-cls-2" d="M356,130h178.6667"/></g><g id="g391"><path id="path393" class="language-cls-2" d="M477.5027,130v12.9133c0,67.28-50.08,124.04-116.836,132.42h0"/></g><g id="g395"><path id="path397" class="language-cls-2" d="M413.164,130v12.9133c0,67.28,50.08,124.04,116.836,132.42h0"/></g><g id="g399"><path id="path401" class="language-cls-2" d="M445.3333,130v-48"/></g><g id="g403"><path id="path405" class="language-cls-2" d="M385.3338,13.3333h-106.616c-31.692,0-57.384,25.692-57.384,57.3853v215.896c0,31.6933,25.692,57.3853,57.384,57.3853h233.2827l99.948,85.3333v-85.3333h0c31.6933,0,57.3853-25.692,57.3853-57.3853V70.7187c0-31.6933-25.692-57.3853-57.3853-57.3853h-106.6147"/></g><g id="g407"><path id="path409" class="language-cls-2" d="M461.3333,344v182.6147c0,31.6933-25.692,57.3853-57.3853,57.3853h-233.2813l-99.948,85.3333v-85.3333h0c-31.6933,0-57.3853-25.692-57.3853-57.3853v-215.896c0-31.6933,25.692-57.3853,57.3853-57.3853h150.6147"/></g><g id="g411"><path id="path413" class="language-cls-2" d="M445.3333,13.3333h0"/></g></g></g></g></g></svg>`,
            importance: {
                active: true,
                default: 8,
            },
            config: {
                endpoint: '/filters/languages',
            },
        },
        politics: {
            token: 'politics',
            name: 'Politics',
            group: 'personal',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 508.8916"><path d="M256,130.9697c13.2734,0,24.0664-10.7969,24.0664-24.0664s-10.7969-24.0703-24.0664-24.0703-24.0664,10.7969-24.0664,24.0703,10.7969,24.0664,24.0664,24.0664ZM256,97.833c5,0,9.0664,4.0703,9.0664,9.0703,0,4.9961-4.0664,9.0664-9.0664,9.0664s-9.0664-4.0664-9.0664-9.0664,4.0664-9.0703,9.0664-9.0703Z"/><path d="M504.5,460.7627h-9.0664v-25.6328c0-4.1406-3.3594-7.5-7.5-7.5h-25.6328v-25.6328c0-4.1406-3.3555-7.5-7.5-7.5h-9.0625v-164.1289h9.0625c4.1445,0,7.5-3.3594,7.5-7.5v-25.6328h25.6328c4.1445,0,7.5-3.3594,7.5-7.5v-33.1328c0-4.1406-3.3555-7.5-7.5-7.5h-14.2227L260.2695,1.333c-2.5664-1.7773-5.9688-1.7773-8.5391,0L38.293,149.1025h-14.2266c-4.1406,0-7.5,3.3555-7.5,7.5v33.1328c0,4.1406,3.3594,7.5,7.5,7.5h25.6328v25.6328c0,4.1406,3.3594,7.5,7.5,7.5h9.0664v164.1289h-9.0664c-4.1406,0-7.5,3.3555-7.5,7.5v25.6328h-25.6328c-4.1406,0-7.5,3.3594-7.5,7.5v25.6328H7.5c-4.1445,0-7.5,3.3555-7.5,7.5v33.1289c0,4.1445,3.3555,7.5,7.5,7.5h497c4.1445,0,7.5-3.3555,7.5-7.5v-33.1289c0-4.1406-3.3555-7.5-7.5-7.5ZM447.3008,427.6299h-67.832v-18.1328h67.832v18.1328ZM396.0312,394.4971v-164.1289h34.7031v164.1289h-34.7031ZM447.3008,215.3682h-67.832v-18.1328h67.832v18.1328ZM371.9688,230.3682h9.0625v164.1289h-9.0625c-4.1445,0-7.5,3.3555-7.5,7.5v25.6328h-59.5508v-25.6328c0-4.1445-3.3594-7.5-7.5-7.5h-9.0664v-164.1289h9.0664c4.1406,0,7.5-3.3594,7.5-7.5v-25.6328h59.5508v25.6328c0,4.1406,3.3555,7.5,7.5,7.5ZM222.0859,197.2354h67.832v18.1328h-67.832v-18.1328ZM238.6484,230.3682h34.7031v164.1289h-34.7031v-164.1289ZM289.918,409.4971v18.1328h-67.832v-18.1328h67.832ZM31.5664,164.1025h130.8828c4.1445,0,7.5-3.3594,7.5-7.5,0-4.1445-3.3555-7.5-7.5-7.5h-97.8047L256,16.6221l191.3594,132.4805h-254.9102c-4.1406,0-7.5,3.3555-7.5,7.5,0,4.1406,3.3594,7.5,7.5,7.5h287.9844v18.1328H31.5664v-18.1328ZM64.6992,197.2354h67.8359v18.1328h-67.8359v-18.1328ZM115.9688,230.3682v164.1289h-34.7031v-164.1289h34.7031ZM64.6992,409.4971h67.8359v18.1328h-67.8359v-18.1328ZM140.0352,394.4971h-9.0664v-164.1289h9.0664c4.1406,0,7.5-3.3594,7.5-7.5v-25.6328h59.5508v25.6328c0,4.1406,3.3555,7.5,7.5,7.5h9.0625v164.1289h-9.0625c-4.1445,0-7.5,3.3555-7.5,7.5v25.6328h-59.5508v-25.6328c0-4.1445-3.3594-7.5-7.5-7.5ZM31.5664,442.6299h448.8672v18.1328H31.5664v-18.1328ZM497,493.8955H15v-18.1328h482v18.1328Z"/></svg>`,
            importance: {
                active: true,
                default: 6,
            },
            config: {
                endpoint: '/filters/politics',
            },
        },
        religion: {
            token: 'religion',
            name: 'Religion',
            group: 'personal',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 442.446 512.0022"><path d="M433.4083,352.6975c-12.6727-13.5867-34.0359-14.3288-47.6216-1.6581l-4.0142,3.7442-38.2011-24.9574,2.6532-57.7492c1.9611-42.6983-.126-56.3271-14.8928-97.2203-11.4286-31.6487-27.0185-71.1939-39.5442-102.9696-8.9655-22.7422-16.7079-42.3833-19.1921-49.7597-.011-.032-.021-.063-.033-.096-6.5324-18.77-23.6923-24.7454-37.265-20.9441-5.1623,1.4451-10.1495,4.4442-14.0728,8.8545-3.9232-4.4102-8.9095-7.4094-14.0728-8.8545-13.5747-3.7992-30.7327,2.1731-37.266,20.9431-.011.032-.022.063-.033.096-1.9891,5.9063-7.4224,19.8481-12.9977,34.0319-2.0201,5.1413.509,10.9456,5.6493,12.9657,5.1443,2.0241,10.9456-.51,12.9657-5.6483,6.5334-16.6239,11.3006-28.9276,13.3207-34.9149,2.6141-7.4494,8.3905-9.4935,12.9687-8.2124,4.7713,1.3361,9.0615,6.5394,6.8174,17.1389l-23.3573,100.4435c-5.0023,3.6432-9.8705,9.6745-13.8928,19.3201-11.5816,27.7755-21.3202,57.3991-26.7185,81.2705-1.2181,5.3883,2.1621,10.7416,7.5484,11.9607,5.3863,1.2181,10.7416-2.1611,11.9597-7.5484,5.1553-22.8002,14.5118-51.2238,25.6704-77.9843,5.2293-12.5397,9.7405-12.1307,11.4386-11.9797,5.4283.488,9.4485,5.3363,8.9615,10.8066-.458,5.1493-2.4601,23.9143-4.3972,42.0623-2.0351,19.065-3.9572,37.073-4.4302,42.3963-1.1651,13.0887,1.1351,28.9706,3.5702,45.7845,7.0584,48.7407,15.7859,109.046-49.2847,149.3422l-79.9074-74.5261,38.8581-25.3884c2.9632-1.9371,4.6823-5.2953,4.5203-8.8315l-2.9152-63.4555c-1.8441-40.1382-.176-51.0128,13.7258-89.5089,3.6082-9.9935,7.8054-21.2562,12.8307-34.4319,1.9681-5.1603-.62-10.9396-5.7803-12.9077s-10.9386.621-12.9077,5.7803c-5.0673,13.2877-9.3045,24.6594-12.9547,34.7659-14.7668,40.8932-16.8539,54.522-14.8928,97.2203l2.6521,57.7492-38.2011,24.9584-4.0132-3.7432c-13.5867-12.6737-34.9489-11.9296-47.6226,1.6581-12.6707,13.5867-11.9267,34.9499,1.6601,47.6216l110.052,102.6416c6.4834,6.0473,14.7348,9.0385,22.9703,9.0385,9.0235,0,18.026-3.5932,24.6513-10.6966,6.1383-6.5814,9.3465-15.1598,9.0335-24.1543-.25-7.1634-2.7151-13.9038-7.0314-19.4531,24.8324-16.2959,41.6203-36.427,50.8488-61.0123,9.2285,24.5863,26.0154,44.7164,50.8478,61.0123-4.3152,5.5493-6.7814,12.2897-7.0304,19.4531-.313,8.9945,2.8951,17.573,9.0335,24.1553,6.6264,7.1044,15.6269,10.6956,24.6513,10.6956,8.2345,0,16.4879-2.9922,22.9703-9.0385l110.052-102.6416v-.001c13.5897-12.6737,14.3338-34.0359,1.6621-47.6236h0ZM153.747,487.6608c-5.1503,5.5233-13.8328,5.8233-19.3531.674l-110.052-102.6426c-5.5213-5.1483-5.8233-13.8307-.674-19.3521,2.6921-2.8882,6.3503-4.3472,10.0185-4.3472,3.3462,0,6.7004,1.2161,9.3345,3.6732l110.052,102.6426c2.6751,2.4941,4.2182,5.8813,4.3452,9.5355.127,3.6562-1.1761,7.1424-3.6712,9.8165h0ZM206.7569,133.6225l14.4678-62.2144,14.4678,62.2144c-5.6003,1.2291-10.5616,4.0222-14.4678,7.8584-3.9052-3.8362-8.8675-6.6294-14.4678-7.8584h0ZM221.2247,250.8359c.247,3.3382.224,6.9804,0,10.9006-.223-3.9202-.247-7.5624,0-10.9006ZM237.5186,294.0182c2.4351-16.8139,4.7352-32.6958,3.5702-45.7845-.474-5.3233-2.3961-23.3313-4.4302-42.3973-1.9371-18.147-3.9392-36.912-4.3972-42.0623-.487-5.4703,3.5332-10.3176,8.9615-10.8066,1.7011-.15,6.2103-.56,11.4386,11.9797,11.1586,26.7615,20.5151,55.185,25.6704,77.9843,1.2181,5.3873,6.5724,8.7655,11.9597,7.5484,5.3873-1.2191,8.7665-6.5724,7.5484-11.9607-5.3983-23.8713-15.1368-53.4939-26.7194-81.2705-4.0222-9.6475-8.8895-15.6779-13.8928-19.3211l-23.3563-100.4405c-2.2431-10.5996,2.0461-15.8029,6.8174-17.1389,4.5783-1.2811,10.3566.765,12.9697,8.2154,2.6612,7.8894,10.1046,26.7695,19.5221,50.6578,12.4787,31.6547,28.0085,71.0499,39.3392,102.4276,13.9018,38.4961,15.5688,49.3707,13.7247,89.5089l-2.9152,63.4555c-.162,3.5362,1.5571,6.8954,4.5202,8.8315l38.8581,25.3884-79.9064,74.5261c-65.0686-40.2952-56.3411-100.6015-49.2827-149.3412h0ZM418.1074,385.6922l-110.052,102.6436c-5.5213,5.1483-14.2028,4.8463-19.353-.674-2.4951-2.6751-3.7982-6.1613-3.6712-9.8165s1.6701-7.0414,4.3452-9.5355l110.052-102.6436c2.6341-2.4571,5.9883-3.6732,9.3345-3.6732,3.6672,0,7.3254,1.4611,10.0175,4.3472,5.1503,5.5213,4.8483,14.2038-.673,19.3521h0Z"/><path d="M145.7376,110.8872c1.2841.551,2.6201.812,3.9342.812,3.8802,0,7.5714-2.2721,9.1965-6.0633l.003-.007c2.1751-5.0763-.177-10.9526-5.2543-13.1277-5.0763-2.1791-10.9576.179-13.1327,5.2553s.176,10.9546,5.2533,13.1307h0Z"/></svg>`,
            importance: {
                active: true,
                default: 5,
            },
            config: {
                endpoint: '/filters/religion',
            },
        },
        drinking: {
            token: 'drinking',
            name: 'Drinking',
            group: 'personal',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 405.3412 481.28"><g id="Layer_50"><path d="M366.9181,7.8375c-1.1103-4.5979-5.225-7.8373-9.955-7.8375H48.3781c-4.7301.0002-8.8447,3.2396-9.955,7.8375L6.0181,142.0375c-15.1216,61.6174-1.4029,126.7677,37.2825,177.055,35.9032,45.7209,90.9998,72.1802,149.13,71.6175v70.09h-78.9325c-5.6554,0-10.24,4.5846-10.24,10.24s4.5846,10.24,10.24,10.24h178.345c5.6554,0,10.24-4.5846,10.24-10.24s-4.5846-10.24-10.24-10.24h-78.9325v-70.09c58.1302.5627,113.2268-25.8967,149.13-71.6175,38.6853-50.2872,52.404-115.4374,37.2825-177.0547L366.9181,7.8375ZM56.4406,20.48h292.46l25.4525,105.4072c-52.6856,62.0859-125.3759,36.4453-184.025,15.703-16.1529-6.25-32.752-11.2792-49.6575-15.045-43.6736-7.8538-89.48,8.1125-114.4832,19.2247L56.4406,20.48ZM345.9506,306.4225c-32.3912,41.1647-82.1855,64.792-134.5575,63.8475h-17.445c-52.372.9445-102.1663-22.6828-134.5575-63.8475-29.7752-38.6391-43.2619-87.389-37.5794-135.8375,15.3066-7.8762,67.9428-32.3942,115.2294-23.8848,15.8103,3.6002,31.3379,8.3452,46.46,14.1975,31.89,11.2775,69.79,24.6825,107.505,24.6825,33.3133.7256,65.4775-12.1876,89.0406-35.7478,12.57,54.6694.0661,112.096-34.0956,156.5901h0Z"/></g></svg>`,
            importance: {
                active: true,
                default: 7,
            },
            config: {
                endpoint: '/filters/drinking',
            },
        },
        smoking: {
            token: 'smoking',
            name: 'Smoking',
            group: 'personal',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 511.9995 512.0008"><path d="M431.1587,207.2378c24.542,24.542,29.457,62.551,11.952,92.432-2.207,3.768-1.714,8.532,1.217,11.768,1.94,2.142,4.652,3.287,7.415,3.287,1.41,0,2.834-.299,4.175-.916,10.358-4.764,19.734-11.304,27.869-19.437,37.541-37.542,37.541-98.626,0-136.167-23.823-23.822-29.274-59.803-13.565-89.533,2.103-3.981,1.287-8.876-1.994-11.959s-8.218-3.594-12.061-1.246l-13.867,8.471c-10.202,6.232-18.791,14.654-24.84,24.355-11.32,18.156-16.277,39.923-13.958,61.292,2.355,21.698,12.177,42.173,27.657,57.653ZM434.4307,98.8738c2.28-3.658,5.074-7.077,8.285-10.164-1.578,9.658-1.708,19.563-.314,29.277,2.972,20.711,12.392,39.509,27.243,54.36,28.89,28.89,29.72,75.377,2.488,105.276,5.208-30.166-4.193-61.89-26.831-84.528-25.249-25.247-29.719-63.992-10.871-94.221h0Z"/><path d="M509.0708,427.7397l-144.335-144.336c-3.905-3.905-10.237-3.905-14.143,0-3.905,3.905-3.905,10.237,0,14.143l100.018,100.018-53.048,53.047-229.393-229.394,53.047-53.047,65.737,65.737c3.905,3.905,10.238,3.905,14.142,0,3.905-3.905,3.905-10.237,0-14.142L84.2608,2.9287c-3.905-3.905-10.237-3.905-14.143,0L2.9287,70.1178c-3.905,3.905-3.905,10.237,0,14.143l424.811,424.811c1.953,1.953,4.512,2.929,7.071,2.929s5.119-.976,7.071-2.929l67.189-67.189c3.905-3.906,3.905-10.238,0-14.143h0ZM154.0278,207.0747l-19.452-19.452,53.047-53.047,19.452,19.452-53.047,53.047ZM77.1898,24.1417l96.291,96.291-53.047,53.047L24.1418,77.1897l53.048-53.048ZM434.8108,487.8578l-23.104-23.104,53.048-53.047,23.104,23.104-53.048,53.047Z"/><path d="M325.8448,268.6657c5.523,0,10-4.477,10-10v-.011c0-5.523-4.477-9.995-10-9.995s-10,4.482-10,10.005,4.477,10.001,10,10.001h0Z"/></svg>`,
            importance: {
                active: true,
                default: 8,
            },
            config: {
                endpoint: '/filters/smoking',
            },
        },
    },
    secondaries: {
        activeEl: null,
    },
    active: {
        init: function () {
            this.events();
            this.set();
        },
        set: function () {
            for (let key in befriend.filters.sections) {
                const section = befriend.filters.sections[key];
                const sectionEl = befriend.els.filters.querySelector(`.section.${section.token}`);

                if (!sectionEl) continue;

                const sectionToggle = sectionEl.querySelector('.section-top .toggle');

                if (!sectionToggle) continue;

                // Check if we have filter data for this section
                const filterData = befriend.filters.data?.filters?.[section.token];

                if (filterData && !filterData.is_active) {
                    removeClassEl('active', sectionToggle);
                } else {
                    addClassEl('active', sectionToggle);
                }
            }

            // Handle individual filter option toggles
            let filterOptionToggles =
                befriend.els.filters.querySelectorAll('.filter-option .toggle');

            for (let toggle of filterOptionToggles) {
                //skip availability days
                if (toggle.closest('.day-section')) {
                    continue;
                }

                let filterOptionEl = toggle.closest('.filter-option');
                if (!filterOptionEl) continue;

                let filterToken = befriend.filters.getFilterToken(filterOptionEl);
                if (!filterToken) continue;

                const filterData = befriend.filters.data?.filters?.[filterToken];

                //skip reviews/verifications if not set
                let skipReview = false;
                let skipVerification = false;

                for (let k in befriend.filters.reviews.ratings) {
                    let data = befriend.filters.reviews.ratings[k];

                    if (data.token === filterToken) {
                        if (typeof filterData?.is_active === 'undefined') {
                            skipReview = true;
                            break;
                        }
                    }
                }

                for (let k in befriend.filters.verifications.options) {
                    let data = befriend.filters.verifications.options[k];

                    if (data.token === filterToken) {
                        if (typeof filterData?.is_active === 'undefined') {
                            skipVerification = true;
                        }
                    }
                }

                if (skipReview || skipVerification) {
                    continue;
                }

                // Skip send/receive toggles
                if (toggle.closest('.send-receive')) {
                    continue;
                }

                if (filterData && !filterData.is_active) {
                    removeClassEl('active', toggle);
                } else {
                    addClassEl('active', toggle);
                }
            }
        },
        events: function () {
            const toggles = befriend.els.filters.querySelectorAll(
                '.section-top .toggle, .filter-option .toggle',
            );

            for (let toggle of toggles) {
                if (toggle._listener) {
                    continue;
                }

                toggle._listener = true;

                toggle.addEventListener('click', async function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    let filter_token;
                    let section = toggle.closest('.section');
                    let filter_option = toggle.closest('.filter-option');

                    if (filter_option) {
                        filter_token = befriend.filters.getFilterToken(filter_option);
                    } else if (section) {
                        filter_token =
                            befriend.filters.sections[section.getAttribute('data-key')]?.token;
                    }

                    if (!filter_token) {
                        console.error('Could not find filter token');
                        return;
                    }

                    let active = !elHasClass(toggle, 'active');

                    //toggle on/off label
                    let toggle_label = filter_option?.querySelector('.toggle-label');

                    if (toggle_label?.innerText) {
                        toggle_label.innerHTML = active ? 'On' : 'Off';
                    }

                    if (active) {
                        addClassEl('active', toggle);
                    } else {
                        removeClassEl('active', toggle);
                    }

                    async function updateState() {
                        try {
                            await befriend.auth.put('/filters/active', {
                                filter_token,
                                active
                            });

                            if(filter_token in befriend.filters.data.filters) {
                                befriend.filters.data.filters[filter_token].is_active = active;
                            } else {
                                befriend.filters.data.filters[filter_token] = {
                                    is_active: active
                                }
                            }

                            //update match counts after filter update
                            befriend.filters.matches.updateCounts();
                        } catch (e) {
                            console.error('Error updating filter active state:', e);

                            // Revert UI state on error
                            if (active) {
                                removeClassEl('active', toggle);
                            } else {
                                addClassEl('active', toggle);
                            }
                        }
                    }

                    clearTimeout(toggle._timeout);

                    toggle._timeout = setTimeout(updateState, 500);
                });
            }
        },
    },
    sendReceive: {
        init: function () {
            this.events();
            this.set();
        },
        set: function () {
            let filter_options = befriend.els.filters.getElementsByClassName('filter-option');

            for (let filter_option of filter_options) {
                let filter_token = befriend.filters.getFilterToken(filter_option);

                let filter_data = befriend.filters.data.filters?.[filter_token];

                if (!filter_data) {
                    continue;
                }

                // Set send/receive states
                let send_receive = filter_option.querySelector('.send-receive');

                //try to find send/receive on parent
                if (!send_receive) {
                    send_receive = filter_option.closest('.section').querySelector('.send-receive');
                }

                if (send_receive) {
                    let send_option = send_receive.querySelector('.option.send');
                    let receive_option = send_receive.querySelector('.option.receive');

                    // Set send state
                    if (send_option) {
                        if (!filter_data.is_send) {
                            removeClassEl('enabled', send_option);
                        }
                    }

                    // Set receive state
                    if (receive_option) {
                        if (!filter_data.is_receive) {
                            removeClassEl('enabled', receive_option);
                        }
                    }
                }
            }
        },
        events: function () {
            const sendReceiveElements = befriend.els.filters.querySelectorAll('.send-receive');

            for (let element of sendReceiveElements) {
                if (element._listener) continue;
                element._listener = true;

                const options = element.querySelectorAll('.option');

                for (let option of options) {
                    option.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();

                        // Toggle enabled class
                        this.classList.toggle('enabled');

                        // Get the filter type and option type
                        let filterToken;
                        let section = this.closest('.section');
                        let filter_option = this.closest('.filter-option');

                        if (filter_option) {
                            filterToken = befriend.filters.getFilterToken(filter_option);
                        } else if (section) {
                            filterToken =
                                befriend.filters.sections[section.getAttribute('data-key')]?.token;
                        }

                        const optionType = this.classList.contains('send') ? 'send' : 'receive';

                        // Save the state
                        befriend.filters.sendReceive.save(
                            filterToken,
                            optionType,
                            elHasClass(this, 'enabled'),
                        );
                    });
                }
            }
        },
        save: async function (filterToken, optionType, isEnabled) {
            let filters = befriend.filters.data.filters;

            let filter = filters[filterToken];

            if (!filter) {
                filter = filters[filterToken] = {};
            }

            if(optionType === 'send') {
                filter.is_send = isEnabled;
            } else if(optionType === 'receive') {
                filter.is_receive = isEnabled;
            }

            try {
                await befriend.auth.put('/filters/send-receive', {
                    filter_token: filterToken,
                    type: optionType,
                    enabled: isEnabled,
                });
            } catch (e) {
                console.error('Error updating filter send/receive state:', e);
            }

            if(befriend.filters.isSectionActive(filterToken)) {
                befriend.filters.matches.updateCounts();
            }
        },
    },
    importance: {
        min: 0,
        max: 10,
        default: 7,
        values: {}, //per section
        init: function () {
            this.set();
        },
        getValue: function (section_key, token) {
            let section = befriend.filters.sections[section_key];
            let storedData = befriend.filters.data.filters?.[section.token];

            if (this.values[section_key] && token in this.values[section_key]) {
                return this.values[section_key][token];
            }

            if (!(section_key in this.values)) {
                this.values[section_key] = {};
            }

            let storedItem = Object.values(storedData?.items || {}).find(
                (stored) => stored.token === token,
            );

            if (isNumeric(storedItem?.importance)) {
                this.values[section_key][token] = storedItem.importance;
                return storedItem.importance;
            }

            return section.importance?.default || this.default;
        },
        set: function (section_key) {
            if(section_key in befriend.filters.data.filters) {
                let filterData = befriend.filters.data.filters[section_key];

                if (!(section_key in this.values)) {
                    this.values[section_key] = {};
                }

                if (filterData.items) {
                    for (let id in filterData.items) {
                        let itemData = filterData.items[id];

                        if (typeof itemData.importance !== 'undefined') {
                            this.values[section_key][id] = itemData.importance;
                        }
                    }
                }
            }

            let section = befriend.filters.sections[section_key];

            if (!section?.importance?.active) {
                return;
            }

            let section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

            let items_container = section_el.querySelector('.items-container');

            if (!items_container) {
                console.error('Need correct HTML structure', section.token);
                return;
            }

            let items_els = items_container.getElementsByClassName('item');

            for (let item of items_els) {
                let item_token = item.getAttribute('data-token');

                //skip any
                if (item_token === 'any') {
                    continue;
                }

                let importance_el = item.querySelector('.importance');

                if (!importance_el) {
                    let value = this.getValue(section.token, item_token);

                    let importance_html = this.getImportanceHtml(
                        section.token,
                        item_token,
                        value,
                    );

                    item.insertAdjacentHTML('afterbegin', importance_html);
                }
            }

            this.initForSection(section);
        },
        initForSection: function (section) {
            if (!section.importance?.active) return;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const importance_els = section_el.querySelectorAll('.importance');

            for (let importance of importance_els) {
                if (importance._listener) continue;
                importance._listener = true;

                importance.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const item = importance.closest('.item');
                    const id = item.getAttribute('data-id');
                    const token = item.getAttribute('data-token');
                    const name = item.querySelector('.name')?.textContent;
                    const currentValue = befriend.filters.importance.getValue(section.token, token);

                    befriend.filters.importance.showImportancePopup(
                        section.token,
                        {
                            id,
                            token,
                        },
                        name,
                        currentValue,
                    );
                });
            }
        },
        showImportancePopup: function (sectionToken, item, name, currentValue = 7) {
            const popupHtml = `
            <div class="importance-popup-overlay">
                <div class="importance-popup">
                    <div class="popup-header">
                        <div class="title">${name}</div>
                        <div class="sub">Filter Importance</div>
                    </div>
                    
                    <div class="importance-slider">
                        <div class="slider-container">
                            <div class="slider-track"></div>
                            <div class="slider-range"></div>
                            <div class="thumb">
                                <span class="thumb-value"></span>
                            </div>
                        </div>
                    </div>
                    <div class="popup-actions">
                        <button class="cancel-btn">Cancel</button>
                        <button class="save-btn">Save</button>
                    </div>
                </div>
            </div>`;

            const popupEl = document.createElement('div');
            popupEl.innerHTML = popupHtml;
            document.body.appendChild(popupEl);

            const overlay = popupEl.querySelector('.importance-popup-overlay');
            void overlay.offsetWidth;
            requestAnimationFrame(() => addClassEl('active', overlay));

            const container = popupEl.querySelector('.slider-container');
            const range = popupEl.querySelector('.slider-range');
            const thumb = popupEl.querySelector('.thumb');
            let isDragging = false;
            let startY, startTop;

            const setPosition = (value) => {
                const percent = (value - this.min) / (this.max - this.min);
                const height = container.offsetHeight;
                const position = height - percent * height;
                thumb.style.top = `${position}px`;
                range.style.height = `${height - position}px`;
                thumb.querySelector('.thumb-value').textContent = Math.round(value);
            };

            const getValueFromPosition = (position) => {
                const height = container.offsetHeight;
                const percent = 1 - position / height;
                return Math.min(
                    Math.max(percent * (this.max - this.min) + this.min, this.min),
                    this.max,
                );
            };

            function handleStart(e) {
                isDragging = true;
                startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                startTop = parseFloat(thumb.style.top) || 0;
                e.preventDefault();
            }

            function handleMove(e) {
                if (!isDragging) return;
                const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                const dy = clientY - startY;
                const newTop = Math.min(Math.max(0, startTop + dy), container.offsetHeight);
                const value = getValueFromPosition(newTop);
                setPosition(value);
            }

            function handleEnd(e) {
                isDragging = false;
                let importancePopup = document.querySelector('.importance-popup-overlay');

                if (importancePopup && !e.target.closest('.importance-popup')) {
                    fireClick(importancePopup.querySelector('.cancel-btn'));
                }
            }

            if(isTouchDevice()) {
                // Touch events
                thumb.addEventListener('touchstart', handleStart);
                document.addEventListener('touchmove', handleMove);
                document.addEventListener('touchend', handleEnd);
            } else {
                // Mouse events
                thumb.addEventListener('mousedown', handleStart);
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleEnd);
            }

            // Click track to set value
            container.addEventListener('click', (e) => {
                if (e.target === thumb) return;
                const rect = container.getBoundingClientRect();
                const clickPosition = e.clientY - rect.top;
                const value = getValueFromPosition(clickPosition);
                setPosition(value);
            });

            // Set initial position
            setPosition(currentValue);

            const closePopup = () => {
                removeClassEl('active', overlay);
                setTimeout(() => popupEl.remove(), 300);
            };

            const cancelBtn = popupEl.querySelector('.cancel-btn');
            const saveBtn = popupEl.querySelector('.save-btn');

            cancelBtn.addEventListener('click', closePopup);

            saveBtn.addEventListener('click', () => {
                const value = parseInt(thumb.querySelector('.thumb-value').textContent);

                if (!(sectionToken in this.values)) {
                    this.values[sectionToken] = {};
                }

                let prevValue = this.values[sectionToken][item.token];

                this.values[sectionToken][item.token] = value;
                befriend.filters.importance.updateIndicator(sectionToken, item.token, value);
                befriend.filters.importance.saveValue(sectionToken, item, value, prevValue);
                closePopup();
            });

            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closePopup();
            });

            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') closePopup();
            });
        },
        updateIndicator: function (sectionToken, itemToken, value) {
            //get item with mine selector
            let item = befriend.els.filters
                .querySelector(`.section.${sectionToken}`)
                .querySelector(`.item.mine[data-token="${itemToken}"]`);

            //if no item, try querying without mine selector
            if (!item) {
                item = befriend.els.filters
                    .querySelector(`.section.${sectionToken}`)
                    .querySelector(`.item[data-token="${itemToken}"]`);
            }

            if(!item) {
                return;
            }

            const importance_el = item.querySelector('.importance');
            if (!importance_el) {
                return;
            }

            const indicator_el = importance_el.querySelector('.indicator');
            if (!indicator_el) {
                return;
            }

            const position = ((value - this.min) / (this.max - this.min)) * 100;

            importance_el.setAttribute('title', `Filter Importance: ${value}/${this.max}`);
            indicator_el.innerHTML = `
            <style>
                .section.${sectionToken} [data-token="${itemToken}"] .importance .indicator::after {
                    left: ${position}%;
                }
            </style>`;
        },
        saveValue: async function (sectionToken, item, value, prevValue) {
            try {
                value = parseInt(value);
                prevValue = isNumeric(prevValue) ? prevValue : null;

                //do not update if no change
                if(value === prevValue) {
                    return;
                }

                item.id = parseInt(item.id);

                await befriend.auth.put('/filters/importance', {
                    section: sectionToken,
                    filter_item_id: item.id,
                    importance: value
                });

                //update local data
                let filter = befriend.filters.data.filters[sectionToken];

                if(filter?.items) {
                    //find item
                    for(let filter_item of Object.values(filter.items)) {
                        if(filter_item.id === item.id) {
                            filter_item.importance = value;
                        }
                    }
                }

                //update match counts if threshold changed
                let importance_threshold = 8;

                const needsUpdate = (value >= importance_threshold && (!prevValue || prevValue < importance_threshold)) ||
                    (prevValue >= importance_threshold && value < importance_threshold);

                if (needsUpdate) {
                    if(befriend.filters.isSectionActive(sectionToken)) {
                        befriend.filters.matches.updateCounts();
                    }
                }
            } catch (e) {
                console.error('Error saving importance:', e);
            }
        },
        getImportanceHtml: function (sectionToken, token, currentValue) {
            const position = ((currentValue - this.min) / (this.max - this.min)) * 100;
            return `
            <div class="importance" title="Filter Importance: ${currentValue}/${this.max}">
                <div class="indicator">
                    <style>
                        .section.${sectionToken} [data-token="${token}"] .importance .indicator::after {
                            left: ${position}%;
                        }
                    </style>
                </div>
            </div>`;
        },
    },
    availability: {
        data: {},
        days: [
            { index: 0, name: 'Sunday' },
            { index: 1, name: 'Monday' },
            { index: 2, name: 'Tuesday' },
            { index: 3, name: 'Wednesday' },
            { index: 4, name: 'Thursday' },
            { index: 5, name: 'Friday' },
            { index: 6, name: 'Saturday' },
        ],
        times: {
            default: {
                start: '09:00',
                end: '21:00',
            },
        },
        selectedDay: null,
        init: function () {
            const section = befriend.filters.sections.availability;
            const filter_data = befriend.filters.data.filters?.['availability'];

            if (filter_data?.items) {
                const availability = {};

                for (let [id, record] of Object.entries(filter_data.items)) {
                    const dayIndex = record.day_of_week;

                    if (!availability[dayIndex]) {
                        availability[dayIndex] = {
                            isDisabled: !record.is_active,
                            isAny: false,
                            times: {},
                        };
                    }

                    // Handle day-level record
                    if (record.is_day) {
                        availability[dayIndex].isDisabled = !record.is_active;
                        availability[dayIndex].isAny = record.is_any_time;
                    }
                    // Handle time-level records
                    else if (record.is_time) {
                        availability[dayIndex].times[id] = {
                            id: id,
                            start: record.start_time?.slice(0, 5), // Convert HH:mm:ss to HH:mm
                            end: record.end_time?.slice(0, 5),
                        };
                    }
                }

                this.data = availability;
            }

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            let daysHtml = this.days
                .map(
                    (day) => `
            <div class="day-section" data-day-index="${day.index}">
                <div class="day-tab">
                    <div class="day-info">
                        <div class="day-name">
                            <div class="name">
                                ${day.name}
                            </div>
                        </div>
                        <div class="selected-container">
                            
                            <div class="selected-times"></div>
                        </div>
                    </div>
                    <div class="day-actions">
                        ${toggleHtml(true, null, 'toggle-24')}
                    </div>
                    <div class="chevron">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001"><path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/></svg>
                    </div>
                </div>
                <div class="time-slots-container">
                    <div class="wrapper">
                        <div class="time-slots"></div>
                        <div class="time-actions">
                            <button class="add-time-btn">
                                <div class="icon-name">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><g id="Ebene_1"><path d="M46.5,4h-4.5V1c0-.552-.447-1-1-1s-1,.448-1,1v3H10V1c0-.552-.448-1-1-1s-1,.448-1,1v3H3.5c-1.93,0-3.5,1.57-3.5,3.5v39c0,1.93,1.57,3.5,3.5,3.5h43c1.93,0,3.5-1.57,3.5-3.5V7.5c0-1.93-1.57-3.5-3.5-3.5ZM3.5,6h4.5v3c0,.552.448,1,1,1s1-.448,1-1v-3h30v3c0,.552.447,1,1,1s1-.448,1-1v-3h4.5c.827,0,1.5.673,1.5,1.5v6.5H2v-6.5c0-.827.673-1.5,1.5-1.5ZM46.5,48H3.5c-.827,0-1.5-.673-1.5-1.5v-30.5h46v30.5c0,.827-.673,1.5-1.5,1.5Z"/><path d="M33,30h-7v-7c0-.552-.448-1-1-1s-1,.448-1,1v7h-7c-.552,0-1,.447-1,1s.448,1,1,1h7v7c0,.553.448,1,1,1s1-.447,1-1v-7h7c.553,0,1-.447,1-1s-.447-1-1-1Z"/></g></svg>
                                    Add Time
                                </div>      
                            </button>
                            <button class="any-time-btn">
                                <div class="icon-name">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 450.536 463.816"><g id="Layer_25"><path d="M348.504,31.304v-10.288c0-11.592-9.432-21.016-21.016-21.016s-21.016,9.432-21.016,21.016v8.832h-64.688v-8.832c0-11.592-9.432-21.016-21.016-21.016s-21.016,9.432-21.016,21.016v8.832h-64.688v-8.832c0-11.592-9.432-21.016-21.016-21.016s-21.016,9.432-21.016,21.016v10.296C39.528,39.752,0,84.712,0,138.824v216.016c0,60.088,49.688,108.976,110.768,108.976h220c61.08,0,110.768-48.888,110.768-108.976v-216.016c0-54.112-39.528-99.072-93.032-107.52h0ZM322.472,21.016c0-2.768,2.248-5.016,5.016-5.016s5.016,2.248,5.016,5.016v33.04c0,2.768-2.248,5.016-5.016,5.016s-5.016-2.248-5.016-5.016V21.016ZM215.752,21.016c0-2.768,2.248-5.016,5.016-5.016s5.016,2.248,5.016,5.016v33.04c0,2.768-2.248,5.016-5.016,5.016s-5.016-2.248-5.016-5.016V21.016ZM109.032,21.016c0-2.768,2.248-5.016,5.016-5.016s5.016,2.248,5.016,5.016v33.04c0,2.768-2.248,5.016-5.016,5.016s-5.016-2.248-5.016-5.016V21.016ZM93.032,47.44v6.608c0,11.592,9.432,21.016,21.016,21.016s21.016-9.432,21.016-21.016v-8.2h64.688v8.208c0,11.592,9.432,21.016,21.016,21.016s21.016-9.432,21.016-21.016v-8.208h64.688v8.208c0,11.592,9.432,21.016,21.016,21.016s21.016-9.432,21.016-21.016v-6.616c43.832,8.08,76,44.976,76.936,89.4H16.096c.936-44.424,33.112-81.312,76.936-89.4ZM425.536,354.84c0,51.264-42.504,92.976-94.768,92.976H110.768c-52.256,0-94.768-41.712-94.768-92.976v-201.992h409.528v201.992h.008Z"/></g><path d="M111.3384,371.1272c-19.4207,0-32.2954-13.0932-32.2954-30.9862,0-15.9286,10.4741-29.2402,27.7126-32.2954l58.4811-12.2195c14.8385-2.8368,23.566-13.0918,23.566-26.8389,0-19.422-13.3102-32.9507-33.1677-32.9507h-67.8631v-17.4562h67.8631c30.1139,0,50.8437,20.7285,50.8437,50.8424,0,22.039-15.2747,38.6229-37.3144,42.7689l-57.608,11.3471c-8.9465,1.3092-14.8378,7.638-14.8378,16.3655,0,8.5104,6.1097,14.1839,15.7109,13.9655h93.3941v17.4575h-94.4849Z"/><path d="M345.0368,240.2009h17.4562v130.9263h-17.4562v-42.3334h-67.4276c-17.4562,0-29.2402-12.2195-29.2402-27.7126,0-3.2736.4368-6.7643,1.746-10.4735l25.9666-77.6833,16.8023,5.4558-26.6218,78.7734c-.4368,1.3092-.6539,2.8368-.6539,4.3644,0,6.1091,3.9275,9.8195,10.9103,9.8195h68.5183v-71.1367Z"/></svg>
                                    Any Time
                                </div>
                            </button>
                            <button class="copy-all-btn">
                                <div class="icon-name">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 420 419.0138"><path d="M366.0771,35.7422h-15.4895v-13.1703c0-12.4661-8.4905-22.5719-18.9641-22.5719s-18.9641,10.1058-18.9641,22.5719v13.1703H97.3406v-13.1703C97.3391,10.1058,88.8474.0014,78.3738.0031c-10.4715.0017-18.96,10.1051-18.9615,22.5688v13.1703h-15.4895C19.6763,35.7748.0274,59.1618,0,88.0211v278.7138c.0274,28.8593,19.6763,52.2463,43.9229,52.2789h322.1543c24.2466-.0325,43.8955-23.4196,43.9229-52.2789V88.0211c-.0274-28.8593-19.6763-52.2463-43.9229-52.2789ZM323.8704,22.5719c0-5.0966,3.4712-9.2282,7.7532-9.2282s7.7532,4.1316,7.7532,9.2282v39.6862c0,5.0966-3.4712,9.2282-7.7532,9.2282s-7.7532-4.1316-7.7532-9.2282h0V22.5719ZM70.6233,22.5719c.0019-5.0966,3.4746-9.2263,7.7566-9.2241,4.2793.0023,7.7478,4.1307,7.7497,9.2241v39.6862c-.0019,5.0966-3.4746,9.2263-7.7566,9.2241-4.2793-.0023-7.7478-4.1307-7.7497-9.2241V22.5719ZM366.0771,405.67H43.9229c-18.0571-.0263-32.6899-17.4428-32.7119-38.9352v-222.6319h387.5781v222.6319c-.0221,21.4924-14.6548,38.9089-32.7119,38.9352ZM398.7891,130.7592H11.2109v-42.7381c.0221-21.4924,14.6548-38.9089,32.7119-38.9352h15.4895v13.1722c.0014,12.4661,8.4931,22.5705,18.9667,22.5688,10.4715-.0017,18.96-10.1051,18.9615-22.5688v-13.1722h215.3189v13.1722c0,12.4661,8.4905,22.5719,18.9641,22.5719s18.9641-10.1058,18.9641-22.5719v-13.1722h15.4895c18.0571.0263,32.6899,17.4428,32.7119,38.9352v42.7381Z"/><path d="M233.802,209.6609h-93.2674c-8.7515,0-15.8596,7.108-15.8596,15.8596v133.8203c0,8.7515,7.108,15.8596,15.8596,15.8596h93.2674c8.7515,0,15.8596-7.108,15.8596-15.8596v-133.8203c-.0411-8.7515-7.1491-15.8596-15.8596-15.8596ZM238.527,359.2997c0,2.6296-2.1365,4.7661-4.7661,4.7661h-93.2674c-2.6296,0-4.7661-2.1365-4.7661-4.7661v-133.7792c0-2.6296,2.1365-4.7661,4.7661-4.7661h93.2674c2.6296,0,4.7661,2.1365,4.7661,4.7661v133.7792Z"/><path d="M269.4655,174.5726h-93.2674c-8.7515,0-15.8596,7.108-15.8596,15.8596,0,3.0815,2.4652,5.5467,5.5467,5.5467s5.5467-2.4652,5.5467-5.5467c0-2.6296,2.1365-4.7661,4.7661-4.7661h93.2674c2.6296,0,4.7661,2.1365,4.7661,4.7661v133.8203c0,2.6296-2.1365,4.7661-4.7661,4.7661-3.0815,0-5.5467,2.4652-5.5467,5.5467s2.4652,5.5467,5.5467,5.5467c8.7515,0,15.8596-7.108,15.8596-15.8596v-133.8203c0-8.7515-7.108-15.8596-15.8596-15.8596Z"/></svg>
                                    Copy
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `,
                )
                .join('');

            filter_options.innerHTML = `
            <div class="filter-option" data-filter-token="${section.token}">
                <div class="days-container">
                    ${daysHtml}
                </div>
            </div>
        `;

            this.initEvents(section_el);
            this.setData();
        },
        initEvents: function (section_el) {
            // Day tab click handler
            const dayTabs = section_el.querySelectorAll('.day-tab');
            for (const tab of dayTabs) {
                if (tab._listener) continue;
                tab._listener = true;

                tab.addEventListener('click', (e) => {
                    // Don't handle click if clicking toggle or if day is disabled
                    if (e.target.closest('.toggle')) return;

                    const daySection = tab.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');

                    if (this.selectedDay === dayIndex) {
                        this.closeTimeSlots(daySection);
                        this.selectedDay = null;
                    } else {
                        if (this.selectedDay !== null) {
                            const prevSection = section_el.querySelector(
                                `.day-section[data-day-index="${this.selectedDay}"]`,
                            );
                            this.closeTimeSlots(prevSection);
                        }
                        this.openTimeSlots(daySection, 0, true);
                        this.selectedDay = dayIndex;
                    }
                });
            }

            // Initialize toggle handlers
            const toggles = section_el.querySelectorAll('.day-tab .toggle');
            for (const toggle of toggles) {
                if (toggle._listener) continue;
                toggle._listener = true;

                toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const daySection = toggle.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');
                    const isActive = toggle.classList.contains('active');

                    this.toggleDayAvailability(dayIndex, !isActive);
                });
            }

            this.initTimeButtons(section_el);
        },
        initTimeButtons: function (section_el) {
            // Add time button handler
            const addTimeBtns = section_el.querySelectorAll('.add-time-btn');
            for (const btn of addTimeBtns) {
                if (btn._listener) continue;
                btn._listener = true;

                btn.addEventListener('click', () => {
                    const daySection = btn.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');
                    this.showTimePickerPopup(dayIndex);
                });
            }

            // Any time button handler
            const anyTimeBtns = section_el.querySelectorAll('.any-time-btn');
            for (const btn of anyTimeBtns) {
                if (btn._listener) continue;
                btn._listener = true;

                btn.addEventListener('click', () => {
                    const daySection = btn.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');
                    this.setAnyTime(dayIndex);
                });
            }

            // Copy to all days button handler
            const copyBtns = section_el.querySelectorAll('.copy-all-btn');
            for (const btn of copyBtns) {
                if (btn._listener) continue;
                btn._listener = true;

                btn.addEventListener('click', () => {
                    const daySection = btn.closest('.day-section');
                    const dayIndex = daySection.getAttribute('data-day-index');
                    this.copyToAllDays(dayIndex);
                });
            }
        },
        getDaySection: function (dayIndex) {
            return befriend.els.filters.querySelector(`.day-section[data-day-index="${dayIndex}"]`);
        },
        toggleDayAvailability: function (dayIndex, isAvailable) {
            const daySection = this.getDaySection(dayIndex);
            if (!daySection) return;

            const toggle = daySection.querySelector('.toggle');
            const selectedTimesEl = daySection.querySelector('.selected-times');

            const currentData = this.data[dayIndex] || {
                isDisabled: true,
                isAny: false,
                times: {},
            };

            if (isAvailable) {
                addClassEl('active', toggle);

                // Initialize or update data for this day
                this.data[dayIndex] = {
                    isDisabled: false,
                    isAny: currentData.isAny,
                    times: currentData.times || {}, // Preserve existing times
                };

                // Check if we have stored filter data
                const filter_data = befriend.filters.data.filters?.['availability'];
                if (filter_data?.items) {
                    const dayRecord = Object.values(filter_data.items).find(
                        (record) => record.day_of_week === parseInt(dayIndex) && record.is_day,
                    );

                    // If we have a day record and it was set to any time, restore that state
                    if (dayRecord?.is_any_time) {
                        this.data[dayIndex].isAny = true;
                        this.data[dayIndex].times = {}; // Clear times when setting to any time
                    }
                }
            } else {
                removeClassEl('active', toggle);

                // Update the data but preserve the times and isAny state
                this.data[dayIndex] = {
                    ...currentData,
                    isDisabled: true,
                };

                selectedTimesEl.innerHTML = '<span class="not-available">Not Available</span>';
            }

            // Update the UI without affecting the time slots container state
            this.updateDayTimesDisplay(dayIndex);
            this.updateDayUI(dayIndex);
            this.saveData();
        },
        setAnyTime: function (dayIndex) {
            const daySection = this.getDaySection(dayIndex);
            if (!daySection) return;

            // Clear existing times and set isAny
            this.data[dayIndex] = {
                isAny: true,
                times: {},
                isDisabled: false, // Ensure day is enabled when setting any time
            };

            // Update UI state
            const toggle = daySection.querySelector('.toggle');
            addClassEl('active', toggle);

            // Remove has-slots class since we're clearing times
            const timeSlotsContainer = daySection.querySelector('.time-slots-container');
            removeClassEl('has-slots', timeSlotsContainer);

            // Keep time slots container open if it was open
            if (this.selectedDay === dayIndex) {
                const timeSlots = daySection.querySelector('.time-slots');
                let timeSlotEls = timeSlots.getElementsByClassName('time-slot');
                let timeSlotCount = timeSlotEls?.length || 0;
                let timeSlotHeight = timeSlotEls?.[0]?.offsetHeight || 0;

                timeSlots.innerHTML = ''; // Clear existing time slots

                requestAnimationFrame(() => {
                    this.openTimeSlots(
                        daySection,
                        timeSlotCount * (timeSlotHeight + befriend.variables.filters_time_slot_gap),
                    );
                });
            }

            this.updateDayTimesDisplay(dayIndex);
            this.updateDayUI(dayIndex);
            this.saveData();
        },
        async copyToAllDays(sourceDayIndex) {
            const sourceData = this.data[sourceDayIndex];
            if (!sourceData) return;

            // Calculate the height of time slots for UI updates
            const sourceSection = this.getDaySection(sourceDayIndex);
            const timeSlots = sourceSection.querySelectorAll('.time-slot');
            const totalGap = (timeSlots.length - 1) * befriend.variables.filters_time_slot_gap;
            const totalHeight =
                Array.from(timeSlots).reduce((sum, slot) => sum + slot.offsetHeight, 0) + totalGap;

            for (const day of this.days) {
                if (day.index.toString() !== sourceDayIndex) {
                    // Deep copy the source data and explicitly set isAny to false
                    const copiedData = {
                        ...sourceData,
                        times: {},
                        isAny: sourceData.isAny,
                    };

                    // Generate new IDs for each time slot
                    if (sourceData.times) {
                        for (let k in sourceData.times) {
                            let timeSlot = sourceData.times[k];
                            const newTimeId = 'time_' + Math.random().toString(36).substr(2, 9);
                            copiedData.times[newTimeId] = {
                                ...timeSlot,
                            };
                            delete copiedData.times[newTimeId].id;
                        }
                    }

                    this.data[day.index] = copiedData;

                    const daySection = this.getDaySection(day.index);
                    if (!daySection) continue;

                    // Update toggle state
                    const toggle = daySection.querySelector('.toggle');
                    if (sourceData.isDisabled) {
                        removeClassEl('active', toggle);
                    } else {
                        addClassEl('active', toggle);
                    }

                    // Update UI
                    this.updateDayUI(day.index);
                    this.updateDayTimesDisplay(day.index);

                    // Update container classes based on new state
                    const timeSlotsContainer = daySection.querySelector('.time-slots-container');
                    if (Object.keys(copiedData.times).length > 0) {
                        addClassEl('has-slots', timeSlotsContainer);
                    } else {
                        removeClassEl('has-slots', timeSlotsContainer);
                    }

                    // If this day is currently selected, update its height
                    if (this.selectedDay === day.index.toString()) {
                        timeSlotsContainer.style.height = `${totalHeight + 40}px`; // Add padding
                    }
                }
            }

            // Save data immediately after copying
            await this.saveData();
        },
        showTimePickerPopup: function (dayIndex, existingTimeId = null) {
            const existingTime = existingTimeId
                ? this.data[dayIndex]?.times?.[existingTimeId]
                : null;
            const dayData = this.data[dayIndex];

            // Set default times without using lastTimes
            let defaultStart = this.times.default.start;
            let defaultEnd = this.times.default.end;

            let popupHtml = `
    <div class="availability-time-picker-popup">
        <div class="popup-header">${existingTime ? 'Edit Time' : 'Add Time'}</div>
        <div class="time-inputs">
            <div class="time-input">
                <label>Start Time</label>
                <input type="time" class="start-time" value="${existingTime?.start || defaultStart}">
            </div>
            <div class="time-input">
                <label>End Time</label>
                <input type="time" class="end-time" value="${existingTime?.end || defaultEnd}">
            </div>
        </div>
        <div class="popup-actions">
            <button class="cancel-btn">Cancel</button>
            <button class="save-btn">Save</button>
        </div>
    </div>
    `;

            const popupEl = document.createElement('div');
            addClassEl('availability-popup-overlay', popupEl);
            popupEl.innerHTML = popupHtml;
            document.body.appendChild(popupEl);

            const cancelBtn = popupEl.querySelector('.cancel-btn');
            const saveBtn = popupEl.querySelector('.save-btn');

            cancelBtn.addEventListener('click', () => {
                popupEl.remove();
            });

            saveBtn.addEventListener('click', () => {
                const startTime = popupEl.querySelector('.start-time').value;
                const endTime = popupEl.querySelector('.end-time').value;

                // Normalize and compare times
                const { normalizedStart, normalizedEnd } = this.normalizeTimeRange(
                    startTime,
                    endTime,
                );

                if (!this.data[dayIndex]) {
                    this.data[dayIndex] = { times: {} };
                }

                // Handle overlapping times
                const newTime = { start: normalizedStart, end: normalizedEnd };
                const existingTimes = Object.values(this.data[dayIndex].times || {});
                const allTimes = [...existingTimes, newTime];
                const mergedTimes = this.mergeOverlappingTimes(allTimes);

                // Clear existing times and add merged times
                this.data[dayIndex].times = {};
                this.data[dayIndex].isAny = false;

                for(let time of mergedTimes) {
                    const timeId = existingTimeId || this.generateTimeId();
                    this.data[dayIndex].times[timeId] = time;
                }

                this.updateDayUI(dayIndex);
                this.updateDayTimesDisplay(dayIndex);

                this.saveData();
                popupEl.remove();

                let daySection = this.getDaySection(dayIndex);

                addClassEl('has-slots', daySection.querySelector('.time-slots-container'));

                void daySection;

                this.openTimeSlots(daySection);
            });
        },
        normalizeTimeRange: function (startTime, endTime) {
            // Convert time to minutes for comparison
            const startMinutes = this.timeToMinutes(startTime);
            let endMinutes = this.timeToMinutes(endTime);

            // If end time is earlier than start time, add 24 hours
            if (endMinutes < startMinutes) {
                endMinutes += 24 * 60;

                const hours = Math.floor(endMinutes / 60);
                const minutes = endMinutes % 60;
                endTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }

            return {
                normalizedStart: startTime,
                normalizedEnd: endTime,
            };
        },
        timeToMinutes: function (timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        },
        updateDayTimesDisplay: function (dayIndex) {
            const daySection = this.getDaySection(dayIndex);
            if (!daySection) return;

            const selectedTimesEl = daySection.querySelector('.selected-times');
            const dayData = this.data[dayIndex];
            const toggle = daySection.querySelector('.toggle');
            const isActive = toggle && elHasClass(toggle, 'active');

            // If toggle is off, always show "Not Available" regardless of other states
            if (!isActive) {
                selectedTimesEl.innerHTML = '<span class="not-available">Not Available</span>';
                return;
            }

            if (!dayData || (!dayData.times && !dayData.isAny)) {
                selectedTimesEl.innerHTML = '<span class="no-times">No times set</span>';
                return;
            }

            if (dayData.isAny) {
                selectedTimesEl.innerHTML = '<span class="any-time">Any Time</span>';
                return;
            }

            const timeSlots = Object.values(dayData.times || {});
            if (timeSlots.length === 0) {
                selectedTimesEl.innerHTML = '<span class="no-times">No times set</span>';
                return;
            }

            const timeStrings = timeSlots
                .sort((a, b) => a.start.localeCompare(b.start))
                .map(
                    (time) =>
                        `<div class="selected-time">${this.formatTimeDisplay(time.start)} - ${this.formatTimeDisplay(time.end)}</div>`,
                );

            selectedTimesEl.innerHTML = timeStrings.join('');
        },
        updateDayUI: function (dayIndex) {
            const daySection = this.getDaySection(dayIndex);
            const timeSlotsEl = daySection.querySelector('.time-slots');
            const timeSlotsContainer = daySection.querySelector('.time-slots-container');
            const dayData = this.data[dayIndex];

            // Clear existing time slots
            timeSlotsEl.innerHTML = '';

            // Handle "Any Time" case
            if (dayData?.isAny) {
                removeClassEl('has-slots', timeSlotsContainer);
                return;
            }

            // Handle regular time slots
            if (dayData?.times && Object.keys(dayData.times).length > 0) {
                addClassEl('has-slots', timeSlotsContainer);

                const sortedTimes = Object.entries(dayData.times).sort(([, a], [, b]) =>
                    a.start.localeCompare(b.start),
                );

                const timeSlotsHtml = sortedTimes
                    .map(
                        ([timeId, time]) => `
                <div class="time-slot" data-time-id="${timeId}">
                    <div class="time-range">${this.formatTimeDisplay(time.start)} - ${this.formatTimeDisplay(time.end)}</div>
                    <button class="delete-btn" title="Delete">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 355.8033 427.0013"><path d="M232.4016,154.7044c-5.5234,0-10,4.4766-10,10v189c0,5.5195,4.4766,10,10,10s10-4.4805,10-10v-189c0-5.5234-4.4766-10-10-10Z"/><path d="M114.4016,154.7044c-5.5234,0-10,4.4766-10,10v189c0,5.5195,4.4766,10,10,10s10-4.4805,10-10v-189c0-5.5234-4.4766-10-10-10Z"/><path d="M28.4016,127.1224v246.3789c0,14.5625,5.3398,28.2383,14.668,38.0508,9.2852,9.8398,22.207,15.4258,35.7305,15.4492h189.2031c13.5273-.0234,26.4492-5.6094,35.7305-15.4492,9.3281-9.8125,14.668-23.4883,14.668-38.0508V127.1224c18.543-4.9219,30.5586-22.8359,28.0781-41.8633-2.4844-19.0234-18.6914-33.2539-37.8789-33.2578h-51.1992v-12.5c.0586-10.5117-4.0977-20.6055-11.5391-28.0312C238.4212,4.0482,228.3118-.0846,217.8001.0013h-88.7969c-10.5117-.0859-20.6211,4.0469-28.0625,11.4688-7.4414,7.4258-11.5977,17.5195-11.5391,28.0312v12.5h-51.1992c-19.1875.0039-35.3945,14.2344-37.8789,33.2578-2.4805,19.0273,9.5352,36.9414,28.0781,41.8633ZM268.0032,407.0013H78.8001c-17.0977,0-30.3984-14.6875-30.3984-33.5v-245.5h250v245.5c0,18.8125-13.3008,33.5-30.3984,33.5ZM109.4016,39.5013c-.0664-5.207,1.9805-10.2188,5.6758-13.8945,3.6914-3.6758,8.7148-5.6953,13.9258-5.6055h88.7969c5.2109-.0898,10.2344,1.9297,13.9258,5.6055,3.6953,3.6719,5.7422,8.6875,5.6758,13.8945v12.5H109.4016v-12.5ZM38.2024,72.0013h270.3984c9.9414,0,18,8.0586,18,18s-8.0586,18-18,18H38.2024c-9.9414,0-18-8.0586-18-18s8.0586-18,18-18Z"/><path d="M173.4016,154.7044c-5.5234,0-10,4.4766-10,10v189c0,5.5195,4.4766,10,10,10s10-4.4805,10-10v-189c0-5.5234-4.4766-10-10-10Z"/></svg>
                    </button>
                </div>
            `,
                    )
                    .join('');

                timeSlotsEl.innerHTML = timeSlotsHtml;

                // Add delete handlers
                const deleteButtons = timeSlotsEl.querySelectorAll('.delete-btn');
                for (const btn of deleteButtons) {
                    if (btn._listener) continue;
                    btn._listener = true;

                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const timeSlot = btn.closest('.time-slot');
                        const timeId = timeSlot.getAttribute('data-time-id');
                        const timeSlotHeight = timeSlot.offsetHeight;

                        this.deleteTimeSlot(dayIndex, timeId);
                        timeSlot.remove();

                        requestAnimationFrame(() => {
                            this.openTimeSlots(
                                daySection,
                                timeSlotHeight + befriend.variables.filters_time_slot_gap,
                            );
                        });
                    });
                }
            } else {
                removeClassEl('has-slots', timeSlotsContainer);
            }
        },
        formatTimeDisplay: function (time) {
            const [hours, minutes] = time.split(':');
            let hr = parseInt(hours);

            if (hr >= 24) {
                hr = hr - 24;
            }

            const ampm = hr >= 12 ? 'pm' : 'am';
            const hr12 = hr % 12 || 12;
            return `${hr12}:${minutes} ${ampm}`;
        },
        deleteTimeSlot: function (dayIndex, timeId) {
            if (this.data[dayIndex]?.times?.[timeId]) {
                let daySection = this.getDaySection(dayIndex);
                let timeSlotsContainer = daySection.querySelector('.time-slots-container');

                delete this.data[dayIndex].times[timeId];

                if (Object.keys(this.data[dayIndex].times).length === 0) {
                    delete this.data[dayIndex];
                    removeClassEl('has-slots', timeSlotsContainer);
                }
                this.updateDayUI(dayIndex);
                this.updateDayTimesDisplay(dayIndex);
                this.saveData();
            }
        },
        generateTimeId: function () {
            return 'time_' + Math.random().toString(36).substr(2, 9);
        },
        doTimesOverlap: function (time1Start, time1End, time2Start, time2End) {
            const t1s = new Date(`2000/01/01 ${time1Start}`);
            const t1e = new Date(`2000/01/01 ${time1End}`);
            const t2s = new Date(`2000/01/01 ${time2Start}`);
            const t2e = new Date(`2000/01/01 ${time2End}`);

            return t1s < t2e && t2s < t1e;
        },
        mergeOverlappingTimes: function (times) {
            if (!times || times.length === 0) return [];

            // Convert time strings to comparable format and sort
            const timeRanges = times.map(time => {
                const [startHours, startMinutes] = time.start.split(':').map(Number);
                const [endHours, endMinutes] = time.end.split(':').map(Number);

                let startTotalMinutes = startHours * 60 + startMinutes;
                let endTotalMinutes = endHours * 60 + endMinutes;

                // If end time is less than start time, add 24 hours to end time
                if (endTotalMinutes < startTotalMinutes) {
                    endTotalMinutes += 24 * 60;
                }

                return {
                    ...time,
                    startMinutes: startTotalMinutes,
                    endMinutes: endTotalMinutes
                };
            }).sort((a, b) => a.startMinutes - b.startMinutes);

            const merged = [timeRanges[0]];

            for (let i = 1; i < timeRanges.length; i++) {
                const current = timeRanges[i];
                const last = merged[merged.length - 1];

                if (current.startMinutes <= last.endMinutes) {
                    // Merge the ranges
                    last.endMinutes = Math.max(last.endMinutes, current.endMinutes);

                    // Convert back to HH:mm format
                    const hours = Math.floor(last.endMinutes / 60);
                    const minutes = last.endMinutes % 60;
                    last.end = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                } else {
                    merged.push(current);
                }
            }

            return merged.map(range => ({
                start: range.start,
                end: range.end
            }));
        },
        openTimeSlots: async function (daySection, minusPixels = 0, autoScrollIfNotVisible) {
            const container = daySection.querySelector('.time-slots-container');
            addClassEl('selected', daySection);

            let setHeight = container.scrollHeight - minusPixels;
            container.style.height = `${setHeight}px`;

            if (autoScrollIfNotVisible) {
                await timeoutAwait(300);

                const filterSection = befriend.els.filters
                    .querySelector('.section.availability')
                    .querySelector('.filter-option');

                const dayRect = daySection.getBoundingClientRect();
                const filterRect = filterSection.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();

                // Calculate vertical positions relative to the viewport
                const dayBottom = dayRect.bottom;
                const filterBottom = filterRect.bottom;

                // Check if the day section is below the filter section
                if (dayBottom > filterBottom) {
                    // Calculate the scroll amount needed
                    const scrollAmount = dayBottom - filterBottom + 10;

                    // Scroll the container, not the filter section
                    filterSection.scrollBy({
                        top: scrollAmount,
                        behavior: 'smooth',
                    });
                }
            }
        },
        closeTimeSlots: function (daySection) {
            if (!daySection) return;
            const container = daySection.querySelector('.time-slots-container');
            removeClassEl('selected', daySection);
            container.style.height = '0';
        },
        setData() {
            try {
                const filter_data = befriend.filters.data.filters?.['availability'];

                // Initialize toggles and displays for each day
                for (const day of this.days) {
                    const daySection = this.getDaySection(day.index);
                    if (!daySection) continue;

                    const toggle = daySection.querySelector('.toggle');
                    const timeSlotsContainer = daySection.querySelector('.time-slots-container');

                    // Set initial toggle state and container display
                    const dayRecords = Object.values(filter_data?.items || {}).filter(
                        (record) => record.day_of_week === day.index,
                    );

                    // Find the day-level record
                    const dayLevelRecord = dayRecords.find((record) => record.is_day);

                    if (dayLevelRecord) {
                        // Initialize day data structure
                        this.data[day.index] = {
                            isDisabled: !dayLevelRecord.is_active,
                            isAny: dayLevelRecord.is_any_time,
                            times: {},
                        };

                        // Process time slots only if not "Any Time"
                        if (!dayLevelRecord.is_any_time) {
                            const timeRecords = dayRecords.filter((record) => !record.is_day);
                            for (let record of timeRecords) {
                                const timeId = record.id;
                                this.data[day.index].times[timeId] = {
                                    start: record.start_time?.slice(0, 5),
                                    end: record.end_time?.slice(0, 5),
                                };
                            }
                        }

                        if (dayLevelRecord.is_active) {
                            addClassEl('active', toggle);
                        } else {
                            removeClassEl('active', toggle);
                        }
                    } else {
                        // Default to active if no day record exists
                        addClassEl('active', toggle);
                        timeSlotsContainer.style.display = '';
                        this.data[day.index] = {
                            isDisabled: false,
                            isAny: false,
                            times: {},
                        };
                    }

                    this.updateDayUI(day.index);
                    this.updateDayTimesDisplay(day.index);
                }
            } catch (e) {
                console.error('Error loading availability data:', e);
            }
        },
        updateIds: function (idMapping) {
            for (let dayIndex in this.data) {
                const dayData = this.data[dayIndex];

                if (dayData.times) {
                    const updatedTimes = {};
                    for (let [oldId, timeSlot] of Object.entries(dayData.times)) {
                        const newId = idMapping[oldId] || oldId;
                        updatedTimes[newId] = {
                            ...timeSlot,
                            id: newId,
                        };

                        const timeSlotEl = befriend.els.filters.querySelector(
                            `[data-time-id="${oldId}"]`,
                        );
                        if (timeSlotEl) {
                            timeSlotEl.setAttribute('data-time-id', newId);
                        }
                    }

                    dayData.times = updatedTimes;
                }
            }
        },
        async saveData() {
            try {
                const availabilityData = {};
                for (const [dayIndex, dayData] of Object.entries(this.data)) {
                    availabilityData[dayIndex] = {
                        isDisabled: dayData.isDisabled || false,
                        isAny: dayData.isAny || false,
                        times: dayData.times || {},
                    };
                }

                let response = await befriend.auth.put('/filters/availability', {
                    availability: availabilityData,
                });

                if(befriend.filters.isSectionActive('availability')) {
                    befriend.filters.matches.updateCounts();
                }

                if (response?.data?.idMapping) {
                    this.updateIds(response.data.idMapping);
                }
            } catch (e) {
                console.error('Error saving availability data:', e);
            }
        },
    },
    activity_types: {
        selected: {
            level_1: null,
            level_2: null,
            level_3: null,
        },
        init: function () {
            this.render();
            this.initEvents();
        },
        getNegativeState(activity_type_id) {
            activity_type_id = parseInt(activity_type_id);
            let section = befriend.filters.sections.activityTypes;
            const filter_data = befriend.filters.data.filters?.[section.token];

            if (filter_data?.items) {
                for (let k in filter_data?.items) {
                    let data = filter_data?.items[k];

                    if (data.activity_type_id === activity_type_id) {
                        return data.is_negative;
                    }
                }
            }

            return null;
        },
        hasAnyNegatives: function () {
            const section = befriend.filters.sections.activityTypes;
            const filterData = befriend.filters.data.filters?.[section.token];

            if (!filterData || !filterData.items) {
                return false;
            }

            for (let k in filterData.items) {
                let item = filterData.items[k];

                if (item.is_negative) {
                    return true;
                }
            }

            return false;
        },
        updateFilterData: function (activityIds, isActive, isAll) {
            const section = befriend.filters.sections.activityTypes;
            const filterData = befriend.filters.data.filters?.[section.token];

            if (!filterData) {
                return;
            }

            if (isAll) {
                if (filterData?.items) {
                    for (let k in filterData.items) {
                        let item = filterData.items[k];
                        item.is_negative = false;
                    }
                }
            } else if (activityIds.length) {
                if (filterData?.items) {
                    for (let k in filterData.items) {
                        let item = filterData.items[k];
                        if (activityIds.includes(item.activity_type_id)) {
                            item.is_negative = !isActive;
                        }
                    }
                }
            }
        },
        render: function () {
            let section = befriend.filters.sections.activityTypes;
            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            let activities = befriend.activities.activityTypes.data;

            let html = ``;
            let level_1_html = ``;

            //create rows and add hidden placeholder row below each row for multi-level select
            let activities_row = [];

            //all activities
            activities_row.push(`
            <div class="activity all ${this.hasAnyNegatives() ? '' : 'active'} level_1_activity" data-token="all">
                    <div class="activity_wrapper">
                        All
                    </div>
            </div>`);

            let level_1_ids = Object.keys(activities);

            for (let i = 0; i < level_1_ids.length; i++) {
                let level_1_id = level_1_ids[i];

                if (activities_row.length === befriend.variables.filter_activity_row_items) {
                    let row_html = activities_row.join('');

                    level_1_html += `<div class="level_1_row">
                                            ${row_html}
                                        </div>`;
                    level_1_html += `<div class="level_2"></div>`;

                    activities_row.length = [];
                }

                let activity = activities[level_1_id];

                let image_html = ``;

                if (activity.image) {
                    image_html += `<div class="image">
                                        ${activity.image}
                                    </div>`;
                } else if (activity.emoji) {
                }

                let icon_html = ``;

                if (image_html) {
                    icon_html = `<div class="icon">${image_html}</div>`;
                }

                let center_class = icon_html ? '' : 'center';

                let negative_state = this.getNegativeState(level_1_id);

                let is_checked = negative_state === null ? true : !negative_state;

                let chevron_html = '';

                if (activity.sub && Object.keys(activity.sub).length) {
                    chevron_html = `<div class="chevron">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001"><path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/></svg>
                                    </div>`;
                }

                activities_row.push(`
                        <div class="activity level_1_activity" data-id="${level_1_id}" data-token="${activity.token}">
                            ${chevron_html}
                            ${checkboxHtml(is_checked)}
                            ${activity.sub && Object.keys(activity.sub).length ? this.getCircleHtml('level-1') : ''}
                            <div class="activity_wrapper ${center_class}">
                                ${icon_html}
                                <div class="name">${activity.name}</div>
                            </div>
                        </div>
                    `);
            }

            if (activities_row.length) {
                let row_html = activities_row.join('');
                level_1_html += `<div class="level_1_row">
                                            ${row_html}
                                        </div>`;
                level_1_html += `<div class="level_2"></div>`;
            }

            html = `
                    <div class="level_1">${level_1_html}</div>
                `;

            filter_options.innerHTML = `<div class="filter-option" data-filter-token="${section.token}">
                                            <div class="activities-wrapper">
                                                ${html}
                                            </div>
                                        </div>`;

            //set number of activity types selected if not all/none
            let level_1_activities = section_el.getElementsByClassName('level_1_activity');
            for (let activity_el of level_1_activities) {
                if (activity_el.getAttribute('data-token') !== 'all') {
                    this.updateCircleStates(activity_el);
                }
            }

            let last_row = lastArrItem(section_el.getElementsByClassName('level_1_row'));

            last_row.style.marginBottom = '0px';
        },
        initEvents: function () {
            this.checkboxEvents();
            this.level1();
        },
        updateLevelHeight: async function (level_num, skip_set_prev) {
            let level_el = befriend.els.filters.querySelector(`.level_${level_num}.show`);

            if (!level_el) {
                return;
            }

            let last_row = lastArrItem(level_el.getElementsByClassName(`level_${level_num}_row`));

            last_row.style.marginBottom = '0px';

            let level_height = await setElHeightDynamic(level_el, true);

            if (!skip_set_prev) {
                level_el.setAttribute('data-prev-height', `${level_height}px`);
            }

            level_el.style.height = `${level_height}px`;
        },
        initCheckboxState: function (parentEl, childEl) {
            const parentCheckbox = parentEl.querySelector('.checkbox');
            const childCheckbox = childEl.querySelector('.checkbox');
            const childId = childEl.getAttribute('data-id');

            // Check if this item has a negative state
            const isNegative = this.getNegativeState(childId);

            if (parentCheckbox && childCheckbox) {
                // If there's a negative state
                if (isNegative !== null) {
                    if (isNegative) {
                        removeClassEl('checked', childCheckbox);
                    } else {
                        addClassEl('checked', childCheckbox);
                    }
                }
                // Otherwise inherit from parent
                else if (elHasClass(parentCheckbox, 'checked')) {
                    addClassEl('checked', childCheckbox);
                } else {
                    removeClassEl('checked', childCheckbox);
                }
            }
        },
        checkboxEvents: function () {
            let section = befriend.filters.sections.activityTypes;
            let section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            let checkboxes = section_el.getElementsByClassName('checkbox');
            let allActivityEl = section_el.querySelector('.activity.all');

            for (let checkbox of checkboxes) {
                if (checkbox._listener) {
                    continue;
                }

                checkbox._listener = true;

                checkbox.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    let updateIds = [];
                    let updateTokens = {};

                    let activity_el = checkbox.closest('.activity');
                    let token = activity_el.getAttribute('data-token');
                    let activityId = activity_el.getAttribute('data-id');

                    let next_level_el = null;
                    let parent_activity = null;
                    let level_checkboxes = null;

                    // Determine level and get related elements
                    if (elHasClass(activity_el, 'level_3_activity')) {
                        let level_3_el = activity_el.closest('.level_3');
                        let level_2_id = level_3_el.getAttribute('data-level-2-id');
                        parent_activity = section_el.querySelector(
                            `.level_2_activity[data-id="${level_2_id}"]`,
                        );
                        level_checkboxes = level_3_el
                            .querySelector('.level_3_container')
                            .getElementsByClassName('checkbox');
                    } else if (elHasClass(activity_el, 'level_2_activity')) {
                        let level_2_el = activity_el.closest('.level_2');
                        let parent_id = level_2_el.getAttribute('data-parent-id');
                        parent_activity = section_el.querySelector(
                            `.level_1_activity[data-id="${parent_id}"]`,
                        );
                        next_level_el = section_el.querySelector(
                            `.level_3[data-level-2-id="${activityId}"]`,
                        );
                        level_checkboxes = level_2_el
                            .querySelector('.level_2_container')
                            .getElementsByClassName('checkbox');
                    } else if (elHasClass(activity_el, 'level_1_activity')) {
                        next_level_el = section_el.querySelector(
                            `.level_2[data-parent-id="${activityId}"]`,
                        );
                        level_checkboxes = activity_el
                            .closest('.level_1')
                            .getElementsByClassName('checkbox');
                    }

                    let wasSelected = elHasClass(checkbox, 'checked');

                    toggleElClass(checkbox, 'checked');

                    //set update state for server for main token
                    updateIds.push(parseInt(activityId));
                    updateTokens[token] = !wasSelected;

                    if (wasSelected) {
                        // Remove active state from circle
                        const circle = activity_el.querySelector('.circle');
                        if (circle) {
                            removeClassEl('active', circle);
                        }

                        // Uncheck all child elements
                        if (next_level_el) {
                            befriend.filters.activity_types.toggleCheckboxes(
                                false,
                                false,
                                next_level_el,
                                updateTokens,
                                updateIds,
                            );
                        }

                        if (activityId in befriend.activities.activityTypes.data) {
                            let activity = befriend.activities.activityTypes.data[activityId];

                            if (activity.sub) {
                                for (let sub_id in activity.sub) {
                                    updateTokens[sub_id] = true;

                                    if (!updateIds.includes(parseInt(sub_id))) {
                                        updateIds.push(parseInt(sub_id));
                                    }
                                }
                            }
                        }

                        removeClassEl('active', allActivityEl);

                        // Check if all siblings are unchecked
                        if (level_checkboxes && parent_activity) {
                            let all_unchecked = Array.from(level_checkboxes).every(
                                (el) => !elHasClass(el, 'checked'),
                            );

                            if (all_unchecked) {
                                // Also uncheck parent if this was the last checked item

                                let parent_id = parent_activity.getAttribute('data-id');
                                let parent_token = parent_activity.getAttribute('data-token');
                                updateIds.push(parseInt(parent_id));
                                updateTokens[parent_token] = false;

                                removeClassEl(
                                    'checked',
                                    parent_activity.querySelector('.checkbox'),
                                );

                                // For level 3, also check level 1 parent
                                if (elHasClass(activity_el, 'level_3_activity')) {
                                    let level_2_el = parent_activity.closest('.level_2');
                                    let level_1_id = level_2_el.getAttribute('data-parent-id');
                                    let level_1_activity = section_el.querySelector(
                                        `.level_1_activity[data-id="${level_1_id}"]`,
                                    );

                                    // Check if all level 2 siblings are also unchecked
                                    let level_2_checkboxes =
                                        level_2_el.getElementsByClassName('checkbox');
                                    let all_level_2_unchecked = Array.from(
                                        level_2_checkboxes,
                                    ).every((el) => !elHasClass(el, 'checked'));

                                    if (all_level_2_unchecked && level_1_activity) {
                                        let level_1_token =
                                            level_1_activity.getAttribute('data-token');

                                        updateIds.push(parseInt(level_1_id));
                                        updateTokens[level_1_token] = false;
                                        removeClassEl(
                                            'checked',
                                            level_1_activity.querySelector('.checkbox'),
                                        );
                                    }
                                }
                            }
                        }
                    } else {
                        // Check all child elements
                        if (next_level_el) {
                            befriend.filters.activity_types.toggleCheckboxes(
                                true,
                                false,
                                next_level_el,
                                updateTokens,
                                updateIds,
                            );
                        }

                        // Check parent activities
                        if (parent_activity) {
                            let parent_id = parent_activity.getAttribute('data-id');
                            let parent_token = parent_activity.getAttribute('data-token');

                            updateIds.push(parseInt(parent_id));
                            updateTokens[parent_token] = true;
                            addClassEl('checked', parent_activity.querySelector('.checkbox'));

                            // Update circle state for parent when enabling
                            befriend.filters.activity_types.updateCircleStates(parent_activity);

                            // For level 3, also check level 1 parent
                            if (elHasClass(activity_el, 'level_3_activity')) {
                                let level_2_el = parent_activity.closest('.level_2');
                                let level_1_id = level_2_el.getAttribute('data-parent-id');
                                let level_1_activity = section_el.querySelector(
                                    `.level_1_activity[data-id="${level_1_id}"]`,
                                );

                                if (level_1_activity) {
                                    let level_1_token = level_1_activity.getAttribute('data-token');

                                    updateIds.push(parseInt(level_1_id));
                                    updateTokens[level_1_token] = true;
                                    addClassEl(
                                        'checked',
                                        level_1_activity.querySelector('.checkbox'),
                                    );
                                }
                            }
                        }
                    }

                    befriend.filters.activity_types.updateFilterData(updateIds, !wasSelected);

                    try {
                        befriend.filters.data.filters[section.token] =
                            await befriend.filters.activity_types.updateServer(
                                updateTokens,
                                !wasSelected,
                            );
                    } catch (e) {
                        console.error(e);
                    }

                    //Update circle count
                    if (elHasClass(activity_el, 'level_2_activity')) {
                        let level_2_el = activity_el.closest('.level_2');
                        let parent_id = level_2_el.getAttribute('data-parent-id');

                        const parent_activity = section_el.querySelector(
                            `.level_1_activity[data-id="${parent_id}"]`,
                        );

                        if (parent_activity) {
                            befriend.filters.activity_types.updateCircleStates(parent_activity);
                        }
                    } else if (elHasClass(activity_el, 'level_3_activity')) {
                        let level_3_el = activity_el.closest('.level_3');
                        let level_2_id = level_3_el.getAttribute('data-level-2-id');

                        const level_2_activity = section_el.querySelector(
                            `.level_2_activity[data-id="${level_2_id}"]`,
                        );
                        if (level_2_activity) {
                            befriend.filters.activity_types.updateCircleStates(level_2_activity);
                            const parent_id = level_2_activity
                                .closest('.level_2')
                                .getAttribute('data-parent-id');
                            const level_1_activity = section_el.querySelector(
                                `.level_1_activity[data-id="${parent_id}"]`,
                            );
                            if (level_1_activity) {
                                befriend.filters.activity_types.updateCircleStates(
                                    level_1_activity,
                                );
                            }
                        }
                    }

                    //set all to selected if no negatives
                    if (!wasSelected) {
                        if (!befriend.filters.activity_types.hasAnyNegatives()) {
                            addClassEl('active', allActivityEl);
                        }
                    }
                });
            }
        },
        toggleCheckboxes: function (
            is_active,
            is_all,
            parent_el,
            updateTokens = {},
            updateIds = [],
        ) {
            let section = befriend.filters.sections.activityTypes;
            let section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

            let checkboxes = null;

            if (is_all) {
                checkboxes = section_el.getElementsByClassName('checkbox');
            } else if (parent_el) {
                checkboxes = parent_el.getElementsByClassName('checkbox');
            }

            if (checkboxes) {
                for (let checkbox of checkboxes) {
                    let activity_el = checkbox.closest('.activity');
                    let id = checkbox.closest('.activity').getAttribute('data-id');
                    let token = checkbox.closest('.activity').getAttribute('data-token');

                    updateIds.push(parseInt(id));

                    //for server update
                    updateTokens[token] = is_active;

                    if (is_active) {
                        addClassEl('checked', checkbox);
                        befriend.filters.activity_types.updateCircleStates(activity_el);
                    } else {
                        removeClassEl('checked', checkbox);

                        const circle = activity_el.querySelector('.circle');
                        if (circle) {
                            removeClassEl('active', circle);
                        }
                    }
                }
            }
        },
        level1: function () {
            let els = befriend.els.filters.getElementsByClassName('level_1_activity');

            for (let i = 0; i < els.length; i++) {
                let el = els[i];

                el.addEventListener('click', async function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    let token = this.getAttribute('data-token');

                    if (token === 'all') {
                        if (!elHasClass(el, 'active')) {
                            addClassEl('active', el);

                            befriend.filters.activity_types.updateFilterData(null, true, true);
                            befriend.filters.activity_types.toggleCheckboxes(true, true);

                            await befriend.filters.activity_types.updateServer(
                                {
                                    [token]: true,
                                },
                                true,
                            );
                        }

                        return false;
                    }

                    let parent_id = this.getAttribute('data-id');
                    let activity = befriend.activities.activityTypes.data[parent_id];

                    // If no sub-categories, trigger checkbox click
                    if (!activity?.sub || !Object.keys(activity.sub).length) {
                        const checkbox = this.querySelector('.checkbox');
                        if (checkbox) {
                            fireClick(checkbox);
                        }

                        return;
                    }

                    let level_2_el = this.closest('.level_1_row').nextSibling;

                    //remove activity selection and hide level 2 if same activity clicked
                    if (elHasClass(this, 'active')) {
                        removeClassEl('active', this);
                        hideLevel(level_2_el);

                        befriend.filters.activity_types.selected.level_1 = null;
                        befriend.filters.activity_types.selected.level_2 = null;
                        befriend.filters.activity_types.selected.level_3 = null;
                        return;
                    } else {
                        //remove active from any previously selected activity except any
                        let other_els = Array.from(els).filter(
                            (item_el) => item_el.getAttribute('data-token') !== 'all',
                        );
                        removeElsClass(other_els, 'active');
                        addClassEl('active', this);
                        befriend.filters.activity_types.selected.level_1 = activity;
                        befriend.filters.activity_types.selected.level_2 = null;
                        befriend.filters.activity_types.selected.level_3 = null;
                    }

                    let prev_level_2 = befriend.els.filters.querySelector('.level_2.show');

                    //do not proceed if no sub categories
                    if (!activity?.sub || !Object.keys(activity.sub).length) {
                        if (prev_level_2) {
                            hideLevel(prev_level_2);
                        }

                        return;
                    }

                    //hide other level 2s if different from this one
                    if (prev_level_2) {
                        if (prev_level_2 !== level_2_el) {
                            hideLevel(prev_level_2);
                            addClassEl('show', level_2_el);
                        }
                    } else {
                        addClassEl('show', level_2_el);
                    }

                    level_2_el.setAttribute('data-parent-id', parent_id);

                    let level_2_html = ``;

                    let activities_level_2 = [];

                    for (let level_2_id in activity.sub) {
                        let activity = befriend.activities.activityTypes.data[parent_id].sub[level_2_id];

                        if (activity.name.toLowerCase() === 'any') {
                            continue;
                        }

                        if (
                            activities_level_2.length ===
                            befriend.variables.filter_activity_level_2_row_items
                        ) {
                            let row_html = activities_level_2.join('');

                            level_2_html += `<div class="level_2_row">
                                            ${row_html}
                                        </div>`;

                            level_2_html += `<div class="level_3"></div>`;

                            activities_level_2.length = [];
                        }

                        let image_html = '';

                        if (activity.image) {
                            image_html += `<div class="image">
                                        ${activity.image}
                                    </div>`;
                        } else if (activity.emoji) {
                        }

                        let icon_html = ``;

                        if (image_html) {
                            icon_html = `<div class="icon">${image_html}</div>`;
                        }

                        let no_icon_class = icon_html ? '' : 'no_icon';

                        let negative_state =
                            befriend.filters.activity_types.getNegativeState(level_2_id);

                        let is_checked = negative_state === null ? true : !negative_state;

                        let chevron_html = '';

                        if (activity.sub && Object.keys(activity.sub).length) {
                            chevron_html = `<div class="chevron">
                                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001"><path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/></svg>
                                            </div>`;
                        }

                        activities_level_2.push(`
                            <div class="activity level_2_activity" data-id="${level_2_id}" data-token="${activity.token}">
                                ${chevron_html}
                                ${checkboxHtml(is_checked)}
                                ${activity.sub && Object.keys(activity.sub).length ? befriend.filters.activity_types.getCircleHtml('level-2') : ''}

                                <div class="activity_wrapper ${no_icon_class}">
                                    ${icon_html}
                                    <div class="name">${activity.name}</div>
                                </div>
                            </div>`);
                    }

                    if (activities_level_2.length) {
                        let row_html = activities_level_2.join('');
                        level_2_html += `<div class="level_2_row">
                                            ${row_html}
                                        </div>`;
                        level_2_html += `<div class="level_3"></div>`;
                    }

                    level_2_el.innerHTML = `<div class="level_2_container">
                                                ${level_2_html}
                                            </div>`;

                    const level2Activities = level_2_el.getElementsByClassName('level_2_activity');

                    for (let activity_el of level2Activities) {
                        befriend.filters.activity_types.initCheckboxState(this, activity_el);
                        befriend.filters.activity_types.updateCircleStates(activity_el);
                    }

                    befriend.filters.activity_types.updateLevelHeight(2);

                    befriend.filters.activity_types.level2();

                    befriend.filters.activity_types.checkboxEvents();
                });
            }
        },
        level2: function () {
            let level_2_activity_els =
                befriend.els.filters.getElementsByClassName('level_2_activity');

            for (let i = 0; i < level_2_activity_els.length; i++) {
                let el = level_2_activity_els[i];

                el.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    let parent_id = this.closest('.level_2').getAttribute('data-parent-id');
                    let level_2_id = this.getAttribute('data-id');
                    let level_2_activity =
                        befriend.activities.activityTypes.data[parent_id].sub[level_2_id];

                    // If no sub-activities, trigger checkbox click
                    const hasSubActivities =
                        level_2_activity.sub && Object.keys(level_2_activity.sub).length > 0;
                    if (!hasSubActivities) {
                        const checkbox = this.querySelector('.checkbox');
                        if (checkbox) {
                            checkbox.click();
                        }
                        return;
                    }

                    let level_3_el = this.closest('.level_2_row').nextSibling;
                    let closest_level_2_el = this.closest('.level_2');
                    let prev_height_level_2 = closest_level_2_el.getAttribute('data-prev-height');

                    if (elHasClass(this, 'active')) {
                        removeClassEl('active', this);
                        hideLevel(level_3_el);
                        closest_level_2_el.style.height = prev_height_level_2;
                        befriend.filters.activity_types.selected.level_2 = null;
                        befriend.filters.activity_types.selected.level_3 = null;
                        return;
                    }

                    removeElsClass(level_2_activity_els, 'active');
                    addClassEl('active', this);

                    let prev_level_3 = befriend.els.filters.querySelector('.level_3.show');

                    if (prev_level_3) {
                        if (prev_level_3 !== level_3_el) {
                            hideLevel(prev_level_3);
                            addClassEl('show', level_3_el);
                        }
                    } else {
                        addClassEl('show', level_3_el);
                    }

                    level_3_el.setAttribute('data-parent-id', parent_id);
                    level_3_el.setAttribute('data-level-2-id', level_2_id);

                    let level_3_html = ``;
                    let activities_level_3 = [];

                    for (let level_3_id in level_2_activity.sub) {
                        let activity =
                            befriend.activities.activityTypes.data[parent_id].sub[level_2_id].sub[
                                level_3_id
                            ];

                        if (activity.name.toLowerCase() === 'any') {
                            continue;
                        }

                        if (
                            activities_level_3.length ===
                            befriend.variables.filter_activity_level_3_row_items
                        ) {
                            let row_html = activities_level_3.join('');
                            level_3_html += `<div class="level_3_row">${row_html}</div>`;
                            activities_level_3.length = [];
                        }

                        let image_html = '';
                        if (activity.image) {
                            image_html += `<div class="image">${activity.image}</div>`;
                        }

                        let icon_html = image_html ? `<div class="icon">${image_html}</div>` : '';
                        let no_icon_class = icon_html ? '' : 'no_icon';

                        let negative_state =
                            befriend.filters.activity_types.getNegativeState(level_3_id);

                        let is_checked = negative_state === null ? true : !negative_state;

                        activities_level_3.push(`
                <div class="activity level_3_activity" data-id="${level_3_id}" data-token="${activity.token}">
                    ${checkboxHtml(is_checked)}
                    <div class="activity_wrapper ${no_icon_class}">
                        ${icon_html}
                        <div class="name">${activity.name}</div>
                    </div>
                </div>`);
                    }

                    if (activities_level_3.length) {
                        let row_html = activities_level_3.join('');
                        level_3_html += `<div class="level_3_row">${row_html}</div>`;
                    }

                    level_3_el.innerHTML = `<div class="level_3_container">${level_3_html}</div>`;

                    const level3Activities = level_3_el.querySelectorAll('.level_3_activity');

                    for (let activity_el of level3Activities) {
                        befriend.filters.activity_types.initCheckboxState(this, activity_el);
                    }

                    befriend.filters.activity_types.updateLevelHeight(3);
                    requestAnimationFrame(function () {
                        befriend.filters.activity_types.updateLevelHeight(2, true);
                    });

                    befriend.filters.activity_types.checkboxEvents();

                    // Always update the selected level 2 activity
                    befriend.filters.activity_types.selected.level_2 = hasSubActivities
                        ? level_2_activity
                        : null;
                    befriend.filters.activity_types.selected.level_3 = null;

                    // Remove active from level 2 and hide any visible level 3 content
                    if (!hasSubActivities) {
                        removeElsClass(
                            closest_level_2_el.getElementsByClassName('level_2_activity'),
                            'active',
                        );
                        let visible_level_3 = befriend.els.filters.querySelector('.level_3.show');
                        if (visible_level_3) {
                            hideLevel(visible_level_3);
                            closest_level_2_el.style.height = prev_height_level_2;
                        }
                    }

                    befriend.filters.activity_types.level3();
                });
            }
        },
        level3: function () {
            let level_3_activity_els =
                befriend.els.filters.getElementsByClassName('level_3_activity');

            for (let i = 0; i < level_3_activity_els.length; i++) {
                let el = level_3_activity_els[i];

                el.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const checkbox = this.querySelector('.checkbox');

                    fireClick(checkbox);
                });
            }
        },
        updateServer: function (updateTokens, is_active) {
            return new Promise(async (resolve, reject) => {
                try {
                    let r = await befriend.auth.put(`/filters/activity-types`, {
                        activities: updateTokens,
                        active: is_active,
                    });

                    resolve(r.data);
                } catch (e) {
                    console.error(e);
                }

                resolve();
            });
        },
        getCircleHtml: function (level) {
            return `
                <div class="circle ${level}-circle">
                    <div class="count"></div>
                </div>
            `;
        },
        updateCircleStates: function (activity_el) {
            const level = elHasClass(activity_el, 'level_1_activity') ? 1 : 2;
            const circle = activity_el.querySelector(`.circle.level-${level}-circle`);
            if (!circle) return;

            // Check if parent checkbox is enabled
            const checkbox = activity_el.querySelector('.checkbox');
            if (!checkbox || !elHasClass(checkbox, 'checked')) {
                removeClassEl('active', circle);
                return;
            }

            const activity_id = activity_el.getAttribute('data-id');
            let sub_activities;

            if (level === 1) {
                sub_activities = befriend.activities.activityTypes.data[activity_id]?.sub;
            } else {
                const parent_id = activity_el.closest('.level_2').getAttribute('data-parent-id');
                sub_activities = befriend.activities.activityTypes.data[parent_id]?.sub[activity_id]?.sub;
            }

            if (!sub_activities) return;

            let checked_count = 0;
            let total_count = 0;
            let all_sub_checked = true;

            if (level === 1) {
                // Count level 2 items for UI display
                for (let level_2_id in sub_activities) {
                    if (sub_activities[level_2_id]?.name?.toLowerCase() === 'any') {
                        continue;
                    }
                    total_count++;
                    const is_checked =
                        !befriend.filters.activity_types.getNegativeState(level_2_id);
                    if (is_checked) {
                        checked_count++;
                    }

                    // Check sub-activities state without affecting counts
                    if (sub_activities[level_2_id].sub) {
                        for (let level_3_id in sub_activities[level_2_id].sub) {
                            if (
                                sub_activities[level_2_id].sub[level_3_id].name?.toLowerCase() ===
                                'any'
                            ) {
                                continue;
                            }
                            const is_sub_checked =
                                !befriend.filters.activity_types.getNegativeState(level_3_id);
                            if (!is_sub_checked) {
                                all_sub_checked = false;
                            }
                        }
                    }
                }

                // Show circle unless everything is checked
                if (checked_count === total_count && all_sub_checked) {
                    removeClassEl('active', circle);
                } else {
                    circle.querySelector('.count').textContent = checked_count;
                    addClassEl('active', circle);
                }
            } else {
                //level 2
                for (let sub_id in sub_activities) {
                    if (sub_activities[sub_id]?.name?.toLowerCase() === 'any') {
                        continue;
                    }
                    total_count++;
                    const is_checked = !befriend.filters.activity_types.getNegativeState(sub_id);
                    if (is_checked) {
                        checked_count++;
                    }
                }

                if (checked_count === 0 || checked_count === total_count) {
                    removeClassEl('active', circle);
                } else {
                    circle.querySelector('.count').textContent = checked_count;
                    addClassEl('active', circle);
                }
            }
        },
    },
    modes: {
        data: {
            selectedModes: ['mode-solo'], // Default selection
        },
        init: function () {
            let section = befriend.filters.sections.modes;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            // Get stored filter values if they exist
            const filter_data = befriend.filters.data.filters?.['modes'];

            if (filter_data?.items) {
                this.data.selectedModes = Object.values(filter_data.items)
                    .filter((item) => !item.is_negative)
                    .map((item) => item.mode_token);
            }

            const modesHtml = befriend.modes.options
                .map((mode) => {
                    const isSelected = this.data.selectedModes.includes(mode.id);
                    return `
                <button class="mode-button ${mode.id} ${isSelected ? 'selected' : ''}" data-mode="${mode.id}">
                    ${mode.icon}
                    <span class="name">${mode.label}</span>
                </button>
            `;
                })
                .join('');

            filter_options.innerHTML = `
            <div class="filter-option" data-filter-token="${section.token}">
                ${befriend.filters.sendReceiveHtml(true, true, true)}
                <div class="modes-buttons">
                    ${modesHtml}
                </div>
            </div>
        `;

            this.initEvents(section_el);
        },
        initEvents: function (section_el) {
            const modeButtons = section_el.querySelectorAll('.mode-button');

            for (let button of modeButtons) {
                if (button._listener) continue;
                button._listener = true;

                button.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const modeId = button.getAttribute('data-mode');
                    const wasSelected = elHasClass(button, 'selected');

                    // Don't allow deselecting if it's the only selected mode
                    if (wasSelected && this.data.selectedModes.length <= 1) {
                        return;
                    }

                    try {
                        // Optimistically update UI
                        if (wasSelected) {
                            removeClassEl('selected', button);
                            this.data.selectedModes = this.data.selectedModes.filter(
                                (id) => id !== modeId,
                            );
                        } else {
                            addClassEl('selected', button);
                            this.data.selectedModes.push(modeId);
                        }

                        // Save to server
                        await befriend.auth.put('/filters/modes', {
                            mode_token: modeId,
                            active: !wasSelected,
                        });

                        if(befriend.filters.isSectionActive('modes')) {
                            befriend.filters.matches.updateCounts();
                        }
                    } catch (e) {
                        console.error('Error updating modes filter:', e);

                        // Revert UI state on error
                        if (wasSelected) {
                            addClassEl('selected', button);
                            this.data.selectedModes.push(modeId);
                        } else {
                            removeClassEl('selected', button);
                            this.data.selectedModes = this.data.selectedModes.filter(
                                (id) => id !== modeId,
                            );
                        }
                    }
                });
            }
        },
    },
    networks: {
        classes: {
            open: 'show-dropdown',
            removing: 'removing-dropdown',
        },
        els: {
            section: null,
            dropdown: null,
        },
        init: function () {
            let section = befriend.filters.sections.networks;
            this.els.section = befriend.els.filters.querySelector(`.section.${section.token}`);

            const filter_options = this.els.section.querySelector('.filter-options');

            // Get stored filter values if they exist
            let filter_data = befriend.filters.data.filters?.['networks'];
            const networks = befriend.filters.data.options?.networks?.networks || [];

            // Find currently selected network
            let selectedName = 'Verified Networks';

            // If no filter data exists yet, create initial state with verified networks selected
            if (typeof filter_data?.is_all_verified === 'undefined') {
                if (!filter_data) {
                    filter_data = befriend.filters.data.filters.networks = {
                        is_active: true,
                        is_send: true,
                        is_receive: true
                    };
                }

                if (!filter_data?.items || !Object.keys(filter_data?.items).length) {
                    filter_data.is_all_verified = true;
                }
            }

            if (filter_data.is_any_network) {
                selectedName = 'Any Network';
            } else if (filter_data?.items) {
                // Look for verified network first
                const activeNetworks = Object.values(filter_data.items).filter(
                    (item) => item.is_active && !item.deleted,
                );

                let selectedNetwork;

                if (filter_data.is_all_verified === false) {
                    // If is_all_verified is explicitly false, find first self network
                    const selfNetwork = networks.find((n) => n.is_self);

                    if (selfNetwork) {
                        selectedNetwork = selfNetwork;
                    } else if (activeNetworks.length) {
                        // Otherwise check active networks
                        const verifiedNetwork = networks.find(
                            (n) =>
                                n.is_verified &&
                                activeNetworks.some((an) => an.network_token === n.network_token),
                        );

                        if (verifiedNetwork) {
                            selectedNetwork = verifiedNetwork;
                        } else {
                            selectedNetwork = networks.find(
                                (n) => activeNetworks[0].network_token === n.network_token,
                            );
                        }
                    }
                }

                if (selectedNetwork) {
                    // Add +X suffix if multiple active networks
                    if (activeNetworks.length) {
                        selectedName = `<div class="name">${selectedNetwork.network_name}</div><div class="plus">+${activeNetworks.length}</div>`;
                    } else {
                        selectedName = `<div class="name">${selectedNetwork.network_name}</div>`;
                    }
                }
            }

            const html = `
        <div class="filter-option" data-filter-token="${section.token}">
            ${befriend.filters.sendReceiveHtml(true, true, true)}
            <div class="select-container">
                <div class="selected-container">
                    <span class="selected-name">${selectedName}</span>
                    <div class="select-arrow">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001"><path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/></svg>
                    </div>
                </div>
                <div class="select-dropdown">
                    <div class="select-list"></div>
                </div>
            </div>
        </div>`;

            filter_options.innerHTML = html;

            requestAnimationFrame(() => {
                this.els.dropdown = this.els.section.querySelector('.select-dropdown');
                this.els.dropdown.style.height = '0';
            });

            this.initEvents();
        },
        getByToken: function (token) {
            return befriend.filters.data.options?.networks?.networks?.find(
                (network) => network.network_token === token,
            );
        },
        formatNetworksList: function (networks) {
            const any = {
                network_token: 'any',
                network_name: 'Any Network',
                is_special: true,
            };

            const anyVerified = {
                network_token: 'any_verified',
                network_name: 'Verified Networks',
                is_special: true,
            };

            // Sort remaining networks by:
            // self, befriend, verified w/ priority, by priority
            const sortedNetworks = [...networks].sort((a, b) => {
                if (a.is_self !== b.is_self) {
                    return b.is_self - a.is_self;
                }

                if (a.is_befriend !== b.is_befriend) {
                    return b.is_befriend - a.is_befriend;
                }

                if (a.is_verified !== b.is_verified) {
                    return b.is_verified - a.is_verified;
                }

                return a.priority - b.priority;
            });

            return [any, anyVerified, ...sortedNetworks];
        },
        setDropdownHeight: function (shouldOpen) {
            if (shouldOpen) {
                this.els.dropdown.style.height = 'auto';
                const fullHeight = this.els.dropdown.offsetHeight;
                this.els.dropdown.style.height = '0';
                void this.els.dropdown.offsetHeight;
                this.els.dropdown.style.height = `${fullHeight}px`;
            } else {
                this.els.dropdown.style.height = '0';
            }
        },
        toggleDropdown: function (show) {
            if (!show && !elHasClass(this.els.section, this.classes.open)) {
                return;
            }

            clearTimeout(this.els.dropdown._timeout);

            if (show) {
                addClassEl(this.classes.open, this.els.section);

                requestAnimationFrame(() => {
                    befriend.filters.networks.setDropdownHeight(true);
                });
            } else {
                addClassEl(this.classes.removing, this.els.section);
                removeClassEl(this.classes.open, this.els.section);

                requestAnimationFrame(() => {
                    befriend.filters.networks.setDropdownHeight(false);
                });

                this.els.dropdown._timeout = setTimeout(() => {
                    removeClassEl(this.classes.removing, this.els.section);
                }, befriend.variables.secondary_transition_ms);
            }
        },
        isDropdownShown: function () {
            return elHasClass(this.els.section, this.classes.open);
        },
        updateSelectedDisplay: function (selectedContainer, activeItems) {
            if (activeItems.length === 0) {
                selectedContainer.querySelector('.selected-name').textContent = 'Any Network';
                return;
            }

            // Check for "Any Network" first
            const anyNetwork = Array.from(activeItems).find(
                (item) => item.getAttribute('data-token') === 'any',
            );
            if (anyNetwork) {
                selectedContainer.querySelector('.selected-name').textContent = 'Any Network';
                return;
            }

            // Check for "Verified Networks"
            const verifiedNetworks = Array.from(activeItems).find(
                (item) => item.getAttribute('data-token') === 'any_verified',
            );
            if (verifiedNetworks) {
                selectedContainer.querySelector('.selected-name').textContent = 'Verified Networks';
                return;
            }

            // Handle multiple custom networks
            if (activeItems.length > 1) {
                const firstNetwork = activeItems[0].querySelector('.name').textContent;
                selectedContainer.querySelector('.selected-name').innerHTML =
                    `<div class="name">${firstNetwork}</div><div class="plus">+${activeItems.length - 1}</div>`;
            } else {
                let name = activeItems[0].querySelector('.name').textContent;

                selectedContainer.querySelector('.selected-name').innerHTML = `<div class="name">
                                                                                            ${name}
                                                                                        </div>`;
            }
        },
        initEvents: function () {
            const selectContainer = this.els.section.querySelector('.select-container');
            const selectedContainer = selectContainer.querySelector('.selected-container');
            const dropdown = selectContainer.querySelector('.select-dropdown');
            const { networks, counts } = befriend.filters.data.options?.networks;

            selectedContainer.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (!this.isDropdownShown()) {
                    const formattedNetworks = this.formatNetworksList(networks);
                    const filter_data = befriend.filters.data.filters?.['networks'];

                    let listHtml = '';

                    for (let network of formattedNetworks) {
                        let isActive = false;
                        let persons_count = network.persons_count;

                        if (network.network_token === 'any') {
                            persons_count = counts.all;
                        } else if (network.network_token === 'any_verified') {
                            persons_count = counts.verified;
                        }

                        if (persons_count) {
                            persons_count = persons_count.toLocaleString();
                        }

                        if (network.is_self) {
                            isActive = true;
                        } else if (filter_data?.is_any_network) {
                            isActive = true;
                        } else if (filter_data?.is_all_verified) {
                            if (network.network_token === 'any_verified' || network.is_verified) {
                                isActive = true;
                            }
                        }

                        if (!isActive && !['any', 'any_verified'].includes(network.network_token)) {
                            isActive = filter_data?.items
                                ? Object.values(filter_data.items).some(
                                      (item) =>
                                          !item.deleted &&
                                          item.is_active &&
                                          item.network_token === network.network_token,
                                  )
                                : false;
                        }

                        listHtml += `<div class="item ${isActive ? 'active' : ''}" data-token="${network.network_token}">
                        ${checkboxHtml(isActive)}
                        ${
                            network.app_icon
                                ? `
                            <div class="network-icon">
                                <img src="${network.app_icon}" alt="${network.network_name}" />
                            </div>
                        `
                                : ''
                        }
                        <div class="item-content">
                            <div class="name">${network.network_name}</div>
                            <div class="meta">${persons_count} persons</div>
                        </div>
                        ${
                            network.is_verified
                                ? `
                            <div class="verified-badge">Verified</div>
                        `
                                : ''
                        }
                    </div>`;
                    }

                    dropdown.querySelector('.select-list').innerHTML = listHtml;
                    this.toggleDropdown(true);
                } else {
                    this.toggleDropdown(false);
                }
            });

            // Handle network selection
            dropdown.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();

                const filter_data = befriend.filters.data.filters?.['networks'];

                const item = e.target.closest('.item');
                if (!item) return;

                const token = item.getAttribute('data-token');
                let network = befriend.filters.networks.getByToken(token);

                try {
                    // Prevent deselecting own network
                    if (network?.is_self && elHasClass(item, 'active')) {
                        return;
                    }

                    befriend.toggleSpinner(true);

                    const wasActive = elHasClass(item, 'active');
                    const checkbox = item.querySelector('.checkbox');
                    let networkItems = dropdown.querySelectorAll('.item');

                    if (token === 'any') {
                        if (!wasActive) {
                            // Select all networks
                            for (let networkItem of networkItems) {
                                addClassEl('active', networkItem);
                                const cb = networkItem.querySelector('.checkbox');
                                if (cb) {
                                    addClassEl('checked', cb);
                                }
                            }
                        } else {
                            removeClassEl('active', item);
                            removeClassEl('checked', checkbox);

                            let wasAllVerifiedSelected = filter_data?.is_all_verified;

                            for (let networkItem of networkItems) {
                                const cb = networkItem.querySelector('.checkbox');
                                let token = networkItem.getAttribute('data-token');

                                if (token === 'any') {
                                    continue;
                                }

                                if (token === 'any_verified') {
                                    if (!wasAllVerifiedSelected) {
                                        removeClassEl('active', networkItem);
                                        removeClassEl('checked', cb);
                                    }

                                    continue;
                                }

                                let network = befriend.filters.networks.getByToken(token);

                                if (!network || network.is_self) {
                                    continue;
                                }

                                if (wasAllVerifiedSelected) {
                                    if (network.is_verified) {
                                        continue;
                                    }
                                }

                                let wasActive = filter_data?.items
                                    ? Object.values(filter_data.items).some(
                                          (item) =>
                                              !item.deleted &&
                                              item.is_active &&
                                              item.network_token === network.network_token,
                                      )
                                    : false;

                                if (!wasActive) {
                                    removeClassEl('active', networkItem);
                                    removeClassEl('checked', cb);
                                }
                            }
                        }
                    } else if (token === 'any_verified') {
                        if (!wasActive) {
                            addClassEl('active', item);
                            addClassEl('checked', checkbox);

                            for (let networkItem of networkItems) {
                                const cb = networkItem.querySelector('.checkbox');
                                let token = networkItem.getAttribute('data-token');

                                if (['any', 'any_verified'].includes(token)) {
                                    continue;
                                }

                                let network = befriend.filters.networks.getByToken(token);

                                if (network.is_verified) {
                                    addClassEl('active', networkItem);
                                    addClassEl('checked', cb);
                                }
                            }
                        } else {
                            removeClassEl('active', item);
                            removeClassEl('checked', checkbox);

                            for (let networkItem of networkItems) {
                                const cb = networkItem.querySelector('.checkbox');
                                let token = networkItem.getAttribute('data-token');

                                if (['any', 'any_verified'].includes(token)) {
                                    continue;
                                }

                                let network = befriend.filters.networks.getByToken(token);

                                if (!network || network.is_self) {
                                    continue;
                                }

                                let wasActive = filter_data?.items
                                    ? Object.values(filter_data.items).some(
                                          (item) =>
                                              !item.deleted &&
                                              item.is_active &&
                                              item.network_token === network.network_token,
                                      )
                                    : false;

                                if (!wasActive) {
                                    removeClassEl('active', networkItem);
                                    removeClassEl('checked', cb);
                                }
                            }
                        }
                    } else {
                        // Regular network selection/deselection

                        if (!wasActive) {
                            // Add selection
                            addClassEl('active', item);

                            if (checkbox) {
                                addClassEl('checked', checkbox);
                            }
                        } else {
                            removeClassEl('active', item);

                            if (checkbox) {
                                removeClassEl('checked', checkbox);
                            }
                        }
                    }

                    // Update filter data and server
                    await this.updateNetworkState(token, !wasActive);

                    // Update selected name display
                    const activeItems = dropdown.querySelectorAll('.item.active');
                    this.updateSelectedDisplay(selectedContainer, activeItems);
                } catch (e) {
                    console.error('Error updating networks filter:', e);
                    toggleElClass(item, 'active');

                    const checkbox = item.querySelector('.checkbox');

                    if (checkbox) {
                        toggleElClass(checkbox, 'checked');
                    }
                } finally {
                    befriend.toggleSpinner(false);
                }
            });

            // Add hover effects for items
            dropdown.addEventListener('mouseover', (e) => {
                const item = e.target.closest('.item');
                if (item) {
                    const items = dropdown.getElementsByClassName('item');
                    removeElsClass(items, 'hover');
                    addClassEl('hover', item);
                }
            });

            // Initial setup to handle open/closed state
            selectContainer.addEventListener('transitionend', () => {
                if (!this.isDropdownShown()) {
                    dropdown.querySelector('.select-list').innerHTML = '';
                }
            });
        },
        updateNetworkState: async function (token, isActive) {
            let filter_data = befriend.filters.data.filters.networks;

            if (!filter_data) {
                filter_data = befriend.filters.data.filters.networks = {};
            }

            if (!filter_data.items) {
                filter_data.items = {};
            }

            if (token === 'any') {
                filter_data.is_any_network = isActive;
            } else if (token === 'any_verified') {
                filter_data.is_all_verified = isActive;
                filter_data.is_any_network = false;
            } else {
                // Update local state
                //find item
                let filterItem = Object.values(befriend.filters.data.filters.networks.items).find(
                    (item) => item.network_token === token,
                );

                if (filterItem) {
                    filterItem.is_active = isActive;
                    filterItem.deleted = false;
                } else {
                    befriend.filters.data.filters.networks.items[token] = {
                        network_token: token,
                        is_active: isActive,
                        deleted: false,
                    };
                }

                const networks = befriend.filters.data.options?.networks?.networks || [];
                const regularNetworks = networks;
                const verifiedNetworks = networks.filter((n) => n.is_verified);

                // Check current state of all networks
                const activeNetworks = Object.values(filter_data.items)
                    .filter((item) => !item.deleted && item.is_active)
                    .map((item) => item.network_token);

                // Check if all networks are selected
                const allNetworksSelected = regularNetworks.every(
                    (network) => network.is_self || activeNetworks.includes(network.network_token),
                );

                // Check if all verified networks are selected
                const allVerifiedSelected = verifiedNetworks.every(
                    (network) => network.is_self || activeNetworks.includes(network.network_token),
                );

                // Update any_network state
                if (!allNetworksSelected) {
                    filter_data.is_any_network = false;
                }

                // Only keep all_verified true if it was already true and all verified networks are still selected
                if (filter_data.is_all_verified && !allVerifiedSelected) {
                    filter_data.is_all_verified = false;
                }
            }

            let anyItem = this.els.dropdown.querySelector('.item[data-token="any"]');
            let anyVerifiedItem = this.els.dropdown.querySelector(
                '.item[data-token="any_verified"]',
            );

            if (token === 'any') {
            } else if (token === 'any_verified') {
                if (elHasClass(anyItem, 'active') && !filter_data.is_any_network) {
                    fireClick(anyItem);
                }
            } else {
                //enable/disable any/verified network selection after data update
                if (elHasClass(anyItem, 'active') && !filter_data.is_any_network) {
                    fireClick(anyItem);
                } else if (filter_data.is_any_network && !elHasClass(anyItem, 'active')) {
                    fireClick(anyItem);
                } else if (elHasClass(anyVerifiedItem, 'active') && !filter_data.is_all_verified) {
                    fireClick(anyVerifiedItem);
                } else if (filter_data.is_all_verified && !elHasClass(anyVerifiedItem, 'active')) {
                    fireClick(anyVerifiedItem);
                }
            }

            // Update server
            await befriend.auth.put('/filters/networks', {
                network_token: token,
                active: isActive,
                is_any_network: filter_data.is_any_network,
                is_all_verified: filter_data.is_all_verified,
            });

            if(befriend.filters.isSectionActive('networks')) {
                befriend.filters.matches.updateCounts();
            }
        },
    },
    reviews: {
        min: 0,
        max: 5,
        precision: 10,
        ratings: {
            safety: {
                token: 'reviews_safety',
                name: 'Safety',
                current_rating: 4.5,
            },
            trust: {
                token: 'reviews_trust',
                name: 'Trust',
                current_rating: 4.5,
            },
            timeliness: {
                token: 'reviews_timeliness',
                name: 'Timeliness',
                current_rating: 4.5,
            },
            friendliness: {
                token: 'reviews_friendliness',
                name: 'Friendliness',
                current_rating: 4.5,
            },
            fun: {
                token: 'reviews_fun',
                name: 'Fun',
                current_rating: 4.5,
            },
        },
        init: function () {
            let section = befriend.filters.sections.reviews;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            let reviewsHtml = '';

            reviewsHtml += `
            <div class="filter-option include-new" data-filter-token="reviews_new">
                ${befriend.filters.sendReceiveHtml(true, true)}

                <div class="filter-option-name">
                    ${toggleHtml(true, null, 'toggle-24')}
                    <div class="name">Match with new members</div>
                </div>
            </div>`;

            //star ratings
            for (let [key, rating] of Object.entries(this.ratings)) {
                const filter_data = befriend.filters.data.filters?.[rating.token];
                if (filter_data?.filter_value) {
                    rating.current_rating = parseFloat(filter_data.filter_value);
                }

                const isActive =
                    typeof filter_data?.is_active !== 'undefined' ? filter_data.is_active : false;

                reviewsHtml += `
                    <div class="filter-option review review-${key}" data-filter-token="${rating.token}">
                        ${befriend.filters.sendReceiveHtml(true, true)}
                        
                        <div class="toggle-wrapper">
                                ${toggleHtml(false, isActive ? 'On' : 'Off', 'toggle-24')}
                        </div>
                            
                        <div class="filter-option-name">
                            <div class="name">
                                ${rating.name}
                            </div>
                            
                            <div class="rating-display">
                                <div class="value">${rating.current_rating}</div>
                            </div>
                        </div>
                        
                        <div class="stars">
                            <div class="stars-container">
                                ${Array(5)
                                    .fill()
                                    .map(
                                        () => `
                                    <div class="star-container">
                                        <svg class="outline" viewBox="0 0 24 24">
                                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                                        </svg>
                                        <svg class="fill" viewBox="0 0 24 24">
                                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                                        </svg>
                                    </div>
                                `,
                                    )
                                    .join('')}
                            </div>
                            
                            
                            <div class="range-container">
                                <div class="sliders-control">
                                    <div class="slider-track"></div>
                                    <div class="slider-range"></div>
                                    <div class="thumb">
                                        <span class="thumb-inner"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            filter_options.innerHTML = reviewsHtml;

            this.initEvents(section_el);
        },
        initEvents: function (section_el) {
            const self = this;
            const precision = this.precision;
            const reviewFilters = section_el.querySelectorAll('.filter-option.review');

            for (let section of reviewFilters) {
                const type = Array.from(section.classList)
                    .find((cls) => cls.startsWith('review-'))
                    ?.replace('review-', '');

                if (!type || !this.ratings[type]) continue;

                const stars = section.querySelectorAll('.star-container');
                const display = section.querySelector('.rating-display');

                // Slider elements
                const container = section.querySelector('.sliders-control');
                const range = section.querySelector('.slider-range');
                const thumb = section.querySelector('.thumb');
                let isDragging = false;
                let startX, startLeft;

                function setPosition(value) {
                    if (typeof value !== 'number' || isNaN(value)) {
                        value = 0;
                    }
                    const percent = value / self.max;
                    // Use getBoundingClientRect() for more accurate width
                    const width = container.getBoundingClientRect().width;
                    const position = percent * width;
                    thumb.style.left = `${position}px`;
                    range.style.width = `${position}px`;
                    // thumb.querySelector('.thumb-value').textContent = value.toFixed(1);
                }

                function getValueFromPosition(position) {
                    // Use getBoundingClientRect() for more accurate width
                    const width = container.getBoundingClientRect().width;
                    const percent = position / width;
                    const value = percent * self.max;
                    return Math.min(Math.max(value, self.min), self.max);
                }

                const updateRating = (rating, skip_save) => {
                    rating = Math.max(0, Math.min(5, rating));

                    // Update stars
                    for (let i = 0; i < stars.length; i++) {
                        const fill = stars[i].querySelector('.fill');
                        const fillPercentage = Math.max(0, Math.min(100, (rating - i) * 100));

                        fill.style.removeProperty('fill');
                        fill.style.removeProperty('color');

                        if (fillPercentage === 0) {
                            fill.style.fill = 'transparent';
                        } else if (fillPercentage === 100) {
                            fill.style.fill = befriend.variables.brand_color_a;
                            fill.style.removeProperty('clip-path');
                        } else {
                            fill.style.fill = befriend.variables.brand_color_a;
                            fill.style.clipPath = `polygon(0 0, ${fillPercentage}% 0, ${fillPercentage}% 100%, 0 100%)`;
                        }
                    }

                    // Update slider position and display
                    setPosition(rating);
                    display.querySelector('.value').innerHTML = rating.toFixed(1);
                    self.ratings[type].current_rating = rating;

                    if (!skip_save) {
                        self.saveRating(type, rating);
                    }
                };

                function handleStart(e) {
                    isDragging = true;
                    startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                    // Use getBoundingClientRect() for accurate position
                    const thumbRect = thumb.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    startLeft = thumbRect.left - containerRect.left;
                    e.preventDefault();
                }

                function handleMove(e) {
                    if (!isDragging) return;

                    const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                    const containerRect = container.getBoundingClientRect();
                    const position = clientX - containerRect.left;
                    const value = getValueFromPosition(position);
                    const roundedValue = Math.round(value * precision) / precision; // Round to nearest 0.1
                    updateRating(roundedValue);
                }

                function handleEnd() {
                    isDragging = false;
                }

                function handleTrackClick(e) {
                    if (isDragging) return; // Prevent click while dragging

                    const rect = container.getBoundingClientRect();
                    const clickPosition = e.clientX - rect.left;
                    const value = getValueFromPosition(clickPosition);
                    const roundedValue = Math.round(value * precision) / precision;
                    updateRating(roundedValue);
                }

                // Star events
                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];

                    star.addEventListener('touchstart', (e) => {
                        e.preventDefault();

                        const updateStarRating = (event) => {
                            const touch = event.touches[0];
                            const rect = star.getBoundingClientRect();
                            const x = touch.clientX - rect.left;
                            const width = rect.width;
                            const percentage = Math.max(0, Math.min(1, x / width));
                            const rating = i + percentage;
                            updateRating(rating);
                        };

                        updateStarRating(e);

                        const onTouchMove = (event) => {
                            event.preventDefault();
                            updateStarRating(event);
                        };

                        const onTouchEnd = () => {
                            document.removeEventListener('touchmove', onTouchMove);
                            document.removeEventListener('touchend', onTouchEnd);
                        };

                        document.addEventListener('touchmove', onTouchMove);
                        document.addEventListener('touchend', onTouchEnd);
                    });
                }

                thumb.addEventListener('mousedown', handleStart);
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleEnd);

                // Touch events
                thumb.addEventListener('touchstart', handleStart);
                document.addEventListener('touchmove', handleMove);
                document.addEventListener('touchend', handleEnd);

                // Track click event
                container.addEventListener('click', handleTrackClick);

                // Initialize with current rating
                requestAnimationFrame(() => {
                    const currentRating = self.ratings[type].current_rating;
                    updateRating(currentRating, true);
                });
            }
        },
        saveRating: function (type, rating) {
            if (!this._debounceTimers) {
                this._debounceTimers = {};
            }

            if (this._debounceTimers[type]) {
                clearTimeout(this._debounceTimers[type]);
            }

            this._debounceTimers[type] = setTimeout(async () => {
                try {
                    const filter_token = this.ratings[type].token;

                    await befriend.auth.put('/filters/reviews', {
                        filter_token,
                        rating: parseFloat(rating),
                    });

                    if(befriend.filters.isSectionActive('reviews')) {
                        if(befriend.filters.data.filters?.[filter_token]?.is_active) {
                            befriend.filters.matches.updateCounts();
                        }
                    }

                } catch (e) {
                    console.error(`Error saving ${type} rating:`, e);
                }
            }, 500);
        },
    },
    verifications: {
        options: {
            in_person: {
                token: 'verification_in_person',
            },
            linkedin: {
                token: 'verification_linkedin',
            },
        },
        init: function () {
            let section = befriend.filters.sections.verifications;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            // Get stored filter values if they exist
            const inPersonFilter = befriend.filters.data.filters?.[this.options.in_person.token];
            const linkedinFilter = befriend.filters.data.filters?.[this.options.linkedin.token];

            let inPersonActive =
                typeof inPersonFilter?.is_active !== 'undefined' ? inPersonFilter.is_active : false;
            let linkedInActive =
                typeof linkedinFilter?.is_active !== 'undefined' ? linkedinFilter.is_active : false;

            const html = `
                <div class="filter-options-container">
                    <div class="filter-option verification-button" data-filter-token="${this.options.in_person.token}">
                        ${befriend.filters.sendReceiveHtml(true, true)}

                        <div class="content">
                            <div class="verification-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                                    <path d="M256,0C114.6,0,0,114.6,0,256s114.6,256,256,256s256-114.6,256-256S397.4,0,256,0z M256,128c39.8,0,72,32.2,72,72 s-32.2,72-72,72s-72-32.2-72-72S216.2,128,256,128z M256,448c-52.9,0-100.3-23.1-133.2-59.6c26.1-42.4,72.5-70.4,125.2-70.4 c2.7,0,5.3,0.1,7.9,0.3c2.6-0.2,5.2-0.3,7.9-0.3c52.7,0,99.1,28,125.2,70.4C356.3,424.9,308.9,448,256,448z"/>
                                </svg>
                            </div>
                            <div class="text">
                                <div class="name">In-Person</div>
                            </div>

                            ${toggleHtml(inPersonActive, inPersonActive ? 'On' : 'Off', 'toggle-24')}
                        </div>
                    </div>
                    <div class="filter-option verification-button" data-filter-token="${this.options.linkedin.token}">
                        ${befriend.filters.sendReceiveHtml(true, true)}

                        <div class="content">
                            <div class="verification-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                                    <path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/>
                                </svg>
                            </div>
                            <div class="text">
                                <div class="name">LinkedIn</div>
                            </div>
                            
                            ${toggleHtml(linkedInActive, linkedInActive ? 'On' : 'Off', 'toggle-24')}
                        </div>
                    </div>
                </div>
            `;

            filter_options.innerHTML = html;

            // Set initial states based on stored values
            if (inPersonFilter && !inPersonFilter.is_active) {
                const toggle = filter_options.querySelector(
                    `[data-filter-token="${this.options.in_person.token}"] .toggle`,
                );
                removeClassEl('active', toggle);
            }

            if (linkedinFilter && !linkedinFilter.is_active) {
                const toggle = filter_options.querySelector(
                    `[data-filter-token="${this.options.linkedin.token}"] .toggle`,
                );
                removeClassEl('active', toggle);
            }

            this.initEvents(section_el);
        },

        initEvents: function (section_el) {
            const options = section_el.querySelectorAll('.filter-option');

            for (let option of options) {
                option.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    let toggle = option.querySelector('.toggle');

                    fireClick(toggle);
                });
            }
        },
    },
    distance: {
        min: 1,
        max: 60,
        current: 20,
        unit: 'miles',
        _updateTimer: null,
        init: function () {
            let self = this;

            let section = befriend.filters.sections.distance;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            // Get stored filter values if they exist
            const filter_data = befriend.filters.data.filters?.[section.token];

            if (filter_data?.filter_value) {
                this.current = parseInt(filter_data.filter_value);
            }

            const distanceHtml = `
                <div class="filter-option distance-range" data-filter-token="${section.token}">
                    ${befriend.filters.sendReceiveHtml(true, true, true)}
                    
                    <div class="filter-option-name">
                        <span class="name">Max distance <span class="miles-km">(miles)</span></span>
                    </div>
                    <div class="range-container">
                        <div class="sliders-control">
                            <div class="slider-track"></div>
                            <div class="slider-range"></div>
                            <div class="thumb">
                                <span class="thumb-value"></span>
                            </div>
                        </div>
                    </div>
                </div>`;

            filter_options.innerHTML = distanceHtml;

            const container = section_el.querySelector('.sliders-control');
            const range = section_el.querySelector('.slider-range');
            const thumb = section_el.querySelector('.thumb');

            let isDragging = false;
            let startX, startLeft;

            function setPosition(value) {
                const percent = (value - self.min) / (self.max - self.min);
                const position = percent * container.offsetWidth;
                thumb.style.left = `${position}px`;
                range.style.width = `${position}px`;
                thumb.querySelector('.thumb-value').textContent = Math.round(value);
            }

            function getValueFromPosition(position) {
                const percent = position / container.offsetWidth;
                return Math.min(
                    Math.max(percent * (self.max - self.min) + self.min, self.min),
                    self.max,
                );
            }

            function handleStart(e) {
                isDragging = true;
                startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                startLeft = parseFloat(thumb.style.left);
                e.preventDefault();
            }

            function handleMove(e) {
                if (!isDragging) return;

                const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const dx = clientX - startX;
                const newLeft = Math.min(Math.max(0, startLeft + dx), container.offsetWidth);
                const value = getValueFromPosition(newLeft);

                self.current = Math.round(value);
                setPosition(self.current);
                self.debounceUpdateServer();
            }

            function handleEnd() {
                isDragging = false;
            }

            function handleTrackClick(e) {
                const rect = container.getBoundingClientRect();
                const clickPosition = e.clientX - rect.left;
                const value = getValueFromPosition(clickPosition);

                self.current = Math.round(value);
                setPosition(self.current);
                self.debounceUpdateServer();
            }

            // Mouse events
            thumb.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);

            // Touch events
            thumb.addEventListener('touchstart', handleStart);
            document.addEventListener('touchmove', handleMove);
            document.addEventListener('touchend', handleEnd);

            // Track click event
            container.addEventListener('click', handleTrackClick);

            // Initialize position
            requestAnimationFrame(function () {
                setPosition(self.current);
            });
        },
        debounceUpdateServer: function () {
            clearTimeout(this._updateTimer);
            this._updateTimer = setTimeout(() => {
                this.saveDistance();
            }, 500);
        },
        saveDistance: async function () {
            try {
                await befriend.auth.put('/filters/distance', {
                    distance: this.current,
                });

                if(befriend.filters.isSectionActive('distance')) {
                    befriend.filters.matches.updateCounts();
                }
            } catch (e) {
                console.error('Error saving distance:', e);
            }
        },
    },
    age: {
        min: 18,
        max: 80,
        current: {
            min: 18,
            max: 80,
        },
        minGap: 2,
        _updateTimer: null,
        init: function () {
            let self = this;

            let section = befriend.filters.sections.ages;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            // Get stored filter values if they exist
            const filter_data = befriend.filters.data.filters?.['ages'];
            if (filter_data?.filter_value_min) {
                this.current.min = parseInt(filter_data.filter_value_min);

                if (filter_data?.filter_value_max) {
                    this.current.max = parseInt(filter_data.filter_value_max);
                }

                // Ensure loaded values respect the minimum gap
                if (this.current.max - this.current.min < this.minGap) {
                    this.current.max = this.current.min + this.minGap;

                    if (this.current.max > this.max) {
                        this.current.max = this.max;
                        this.current.min = this.max - this.minGap;
                    }
                }
            }

            const ageHtml = `
                 <div class="filter-option age-range" data-filter-token="${section.token}">
                    ${befriend.filters.sendReceiveHtml(true, true, true)}
                    
                    <div class="range-container">
                        <div class="sliders-control">
                            <div class="slider-track"></div>
                            <div class="slider-range"></div>
                            <div class="thumb min-thumb">
                                <span class="thumb-value"></span>
                            </div>
                            <div class="thumb max-thumb">
                                <span class="thumb-value"></span>
                            </div>
                        </div>
                    </div>
                </div>`;

            filter_options.innerHTML = ageHtml;

            // Get elements after they're added to DOM
            const container = section_el.querySelector('.sliders-control');
            const range = section_el.querySelector('.slider-range');
            const minThumb = section_el.querySelector('.min-thumb');
            const maxThumb = section_el.querySelector('.max-thumb');

            let isDragging = null;
            let startX, startLeft;

            function setPosition(thumb, value) {
                const percent = (value - self.min) / (self.max - self.min);
                const position = percent * container.offsetWidth;
                thumb.style.left = `${position}px`;
                value = Math.round(value);

                if (value === befriend.filters.age.max) {
                    value += `<span class="plus">+</span>`;
                }

                thumb.querySelector('.thumb-value').innerHTML = value;
            }

            function updateRange() {
                const minLeft = parseFloat(minThumb.style.left);
                const maxLeft = parseFloat(maxThumb.style.left);
                range.style.left = `${Math.min(minLeft, maxLeft)}px`;
                range.style.width = `${Math.abs(maxLeft - minLeft)}px`;
            }

            function getValueFromPosition(position) {
                const percent = position / container.offsetWidth;
                return Math.min(
                    Math.max(percent * (self.max - self.min) + self.min, self.min),
                    self.max,
                );
            }

            function handleStart(e) {
                isDragging = this;
                startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                startLeft = parseFloat(this.style.left);
                e.preventDefault();
            }

            function handleMove(e) {
                if (!isDragging) return;

                const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const dx = clientX - startX;
                const newLeft = Math.min(Math.max(0, startLeft + dx), container.offsetWidth);
                const value = getValueFromPosition(newLeft);

                if (isDragging === minThumb) {
                    // Ensure minimum thumb doesn't get closer than minGap to maximum thumb
                    const maxValue = self.current.max;
                    if (value <= maxValue - self.minGap) {
                        self.current.min = Math.round(value);
                        setPosition(minThumb, self.current.min);
                    }
                } else if (isDragging === maxThumb) {
                    // Ensure maximum thumb doesn't get closer than minGap to minimum thumb
                    const minValue = self.current.min;
                    if (value >= minValue + self.minGap) {
                        self.current.max = Math.round(value);
                        setPosition(maxThumb, self.current.max);
                    }
                }

                updateRange();
                self.debounceUpdateServer();
            }

            function handleEnd() {
                isDragging = null;
            }

            // Mouse events
            [minThumb, maxThumb].forEach((thumb) => {
                thumb.addEventListener('mousedown', handleStart);
            });
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);

            // Touch events
            [minThumb, maxThumb].forEach((thumb) => {
                thumb.addEventListener('touchstart', handleStart);
            });
            document.addEventListener('touchmove', handleMove);
            document.addEventListener('touchend', handleEnd);

            // Initialize positions
            requestAnimationFrame(function () {
                setPosition(minThumb, befriend.filters.age.current.min);
                setPosition(maxThumb, befriend.filters.age.current.max);
                updateRange();
            });
        },
        debounceUpdateServer: function () {
            clearTimeout(this._updateTimer);
            this._updateTimer = setTimeout(() => {
                this.saveAgeRange();
            }, 500);
        },

        saveAgeRange: async function () {
            try {
                await befriend.auth.put('/filters/age', {
                    min_age: this.current.min,
                    max_age: this.current.max,
                });

                if(befriend.filters.isSectionActive('ages')) {
                    befriend.filters.matches.updateCounts();
                }
            } catch (e) {
                console.error('Error saving age range:', e);
            }
        },
    },
    genders: {
        init: function () {
            let section = befriend.filters.sections.genders;

            const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);
            const filter_options = section_el.querySelector('.filter-options');

            const filter_data = befriend.filters.data.filters?.['genders'];

            let gender_buttons_html = '';

            if (befriend.me.data.genders) {
                for (let gender of befriend.me.data.genders) {
                    let selected = '';

                    const matchingItem = filter_data?.items
                        ? Object.values(filter_data.items).find(
                              (item) => item.gender_id === gender.id,
                          )
                        : null;

                    // Item is selected if it exists and is not negative
                    if (matchingItem && !matchingItem.is_negative) {
                        selected = 'selected';
                    } else if (!filter_data?.items && gender.token === 'any') {
                        // Default to 'any' selected if no filter data exists yet
                        selected = 'selected';
                    }

                    gender_buttons_html += `
                        <div class="item gender-button ${gender.token} ${selected}" data-token="${gender.token}">
                            <div class="name">${gender.name}</div>
                        </div>`;
                }
            }

            let html = `
                <div class="filter-option" data-filter-token="${section.token}">
                    ${befriend.filters.sendReceiveHtml(true, true, true)}
                    
                    <div class="items-container gender-buttons">
                        ${gender_buttons_html}
                    </div>
                </div>
            `;

            filter_options.innerHTML = html;

            this.initEvents(section_el);
        },
        initEvents: function (section_el) {
            const genderButtons = section_el.querySelectorAll('.gender-button');

            for (let button of genderButtons) {
                if (!button._listener) {
                    button._listener = true;

                    button.addEventListener('click', async function (e) {
                        e.preventDefault();
                        e.stopPropagation();

                        let genderToken = this.getAttribute('data-token');
                        let isAny = genderToken === 'any';
                        const anyButton = section_el.querySelector(
                            '.gender-button[data-token="any"]',
                        );
                        const wasSelected = elHasClass(this, 'selected');

                        // If selecting "Any", deselect all others
                        if (isAny && !wasSelected) {
                            for (let btn of genderButtons) {
                                if (btn !== this) {
                                    removeClassEl('selected', btn);
                                }
                            }
                        }
                        // If selecting a specific gender, deselect "Any"
                        else if (!isAny && !wasSelected) {
                            if (anyButton) {
                                removeClassEl('selected', anyButton);
                            }
                        }

                        toggleElClass(this, 'selected');

                        //switch to any if all three selected
                        let allSelected = true;

                        for (let btn of genderButtons) {
                            if (btn.getAttribute('data-token') === 'any' && !wasSelected) {
                                continue;
                            }

                            if (!elHasClass(btn, 'selected')) {
                                allSelected = false;
                            }
                        }

                        if (allSelected) {
                            removeElsClass(genderButtons, 'selected');
                            genderToken = 'any';
                            isAny = true;
                            addClassEl('selected', anyButton);
                        }

                        try {
                            let r = await befriend.auth.put('/filters/gender', {
                                gender_token: genderToken,
                                active: !wasSelected,
                            });

                            if(r.data?.data) {
                                befriend.filters.data.filters['genders'] = r.data.data;
                            }

                            if(befriend.filters.isSectionActive('genders')) {
                                befriend.filters.matches.updateCounts();
                            }
                        } catch (e) {
                            console.error('Error updating gender filter:', e);

                            // Revert UI state on error
                            toggleElClass(this, 'selected');

                            if (isAny && !wasSelected) {
                                for (let btn of genderButtons) {
                                    if (btn !== this) {
                                        toggleElClass(btn, 'selected');
                                    }
                                }
                            }
                        }
                    });
                }
            }
        },
    },
    init: function () {
        return new Promise(async (resolve, reject) => {
            console.log('[init] Filters');

            try {
                if (befriend.user.local.data?.filters?.collapsed) {
                    this.data.collapsed = befriend.user.local.data.filters.collapsed;
                }

                await befriend.filters.getData();

                //init interest sections
                this.movies = this.createInterestsFilter(this.sections.movies.config);
                this.tv_shows = this.createInterestsFilter(this.sections.tv_shows.config);
                this.sports = this.createInterestsFilter(this.sections.sports.config);
                this.music = this.createInterestsFilter(this.sections.music.config);
                this.instruments = this.createInterestsFilter(this.sections.instruments.config);
                this.schools = this.createInterestsFilter(this.sections.schools.config);
                this.work = this.createInterestsFilter(this.sections.work.config);

                //init personal sections
                this.life_stages = this.createMultiSelectFilter('life_stages');
                this.relationships = this.createMultiSelectFilter('relationships');
                this.languages = this.createMultiSelectFilter('languages');
                this.politics = this.createMultiSelectFilter('politics');
                this.religion = this.createMultiSelectFilter('religion');
                this.drinking = this.createMultiSelectFilter('drinking');
                this.smoking = this.createMultiSelectFilter('smoking');

                //sections
                await befriend.filters.matches.init();
                await befriend.filters.initSections();
                befriend.filters.initCollapsible();

                //notifications
                befriend.filters.availability.init();
                befriend.filters.activity_types.init();
                befriend.filters.modes.init();
                befriend.filters.networks.init();
                befriend.filters.reviews.init();
                befriend.filters.verifications.init();

                //general
                befriend.filters.distance.init();
                befriend.filters.age.init();
                befriend.filters.genders.init();

                //interests
                befriend.filters.schools.init();
                befriend.filters.movies.init();
                befriend.filters.tv_shows.init();
                befriend.filters.sports.init();
                befriend.filters.music.init();
                befriend.filters.work.init();
                befriend.filters.instruments.init();

                //personal
                befriend.filters.life_stages.init();
                befriend.filters.relationships.init();
                befriend.filters.languages.init();
                befriend.filters.politics.init();
                befriend.filters.religion.init();
                befriend.filters.drinking.init();
                befriend.filters.smoking.init();

                //settings
                befriend.filters.active.init();
                befriend.filters.sendReceive.init();
                befriend.filters.importance.init();

                befriend.filters.setFilterState();
            } catch (e) {
                console.error(e);
            }
            resolve();
        });
    },
    getData: function () {
        return new Promise(async (resolve, reject) => {
            try {
                let response = await befriend.auth.get('/filters');

                befriend.filters.data.options = response.data;
            } catch (e) {
                console.error(e);
            }

            return resolve();
        });
    },
    sortSecondary: function (originalArr, currentArr) {
        if (!Array.isArray(originalArr) || !Array.isArray(currentArr)) {
            return currentArr;
        }

        return [...currentArr].sort((a, b) => {
            // Keep 'any' at the start if it exists
            if (a === 'any') return -1;
            if (b === 'any') return 1;

            // Get indices from original array
            const indexA = originalArr.indexOf(a);
            const indexB = originalArr.indexOf(b);

            // Keep items not found in original array at the end
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;

            return indexA - indexB;
        });
    },
    initSections: async function () {
        return new Promise(async (resolve, reject) => {
            try {
                let sections_el = befriend.els.filters.querySelector('.sections');

                // First, organize sections into groups
                let groups = {};
                for (let key in this.sections) {
                    let section = this.sections[key];
                    let groupKey = section.group;

                    if (!groups[groupKey]) {
                        groups[groupKey] = {
                            sections: [],
                            name: this.groups.find((g) => g.key === groupKey)?.name,
                        };
                    }
                    groups[groupKey].sections.push({ key, ...section });
                }

                //navigation
                let navHtml = ``;

                // Add navigation buttons
                for (let groupKey in groups) {
                    let group = groups[groupKey];
                    navHtml += `
                    <div class="nav-button" data-group="${groupKey}">
                        ${group.name}
                    </div>`;
                }

                navHtml = `<div class="filters-nav">
                                <div class="nav-scroll">
                                    <div class="nav-buttons">${navHtml}</div>
                                </div>
                           </div>`;

                sections_el.insertAdjacentHTML('beforebegin', navHtml);

                let html = '';

                // Generate HTML for each group and its sections
                for (let groupKey in groups) {
                    let group = groups[groupKey];

                    let section_html = '';

                    // Add sections within this group
                    for (let section of group.sections) {
                        let collapsed_class = this.data.collapsed[section.key] ? 'collapsed' : '';

                        section_html += `<div class="section ${section.token} ${collapsed_class}" data-key="${section.key}">
                        <div class="section-top">
                            <div class="section-icon">${section.icon ? section.icon : ''}</div>
                            <div class="section-name">${section.name}</div>
                            
                            <div class="toggle-wrapper">
                                ${toggleHtml(true)}
                            </div>
                            
                            <div class="chevron">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 360.0005 192.001">
                                    <path id="Down_Arrow" d="M176.001,192.001c-4.092,0-8.188-1.564-11.312-4.688L4.689,27.313C-1.563,21.061-1.563,10.937,4.689,4.689s16.376-6.252,22.624,0l148.688,148.688L324.689,4.689c6.252-6.252,16.376-6.252,22.624,0s6.252,16.376,0,22.624l-160,160c-3.124,3.124-7.22,4.688-11.312,4.688h0Z"/>
                                </svg>
                            </div>
                        </div>
                        <div class="section-container">
                            <div class="filter-options"></div>
                        </div>
                    </div>`;
                    }

                    html += `<div class="group ${groupKey}" data-group="${groupKey}">
                                <div class="group-name">${group.name}</div>
                                <div class="group-sections">${section_html}</div>
                            </div>`;
                }

                sections_el.innerHTML = html;

                await rafAwait();

                befriend.filters.initNavigation();

                befriend.filters.updateSectionHeights();
            } catch (e) {
                console.error(e);
            }

            return resolve();
        });
    },
    initNavigation: function () {
        const nav = befriend.els.filters.querySelector('.filters-nav');
        const navButtons = nav.querySelectorAll('.nav-button');
        const sections = befriend.els.filters.querySelector('.sections');
        const groups = sections.querySelectorAll('.group');
        let isScrolling = false; // Flag to track programmatic scrolling

        // Set first button as active initially
        if (navButtons.length) {
            addClassEl('active', navButtons[0]);
        }

        let groupOffsetTop = befriend.styles.getVariableValue('view-top') + befriend.variables.filters_matches_h + 60;

        // Add click handlers to nav buttons
        for (let button of navButtons) {
            button.addEventListener('click', () => {
                const groupKey = button.getAttribute('data-group');
                const targetGroup = sections.querySelector(`.group[data-group="${groupKey}"]`);

                if (targetGroup) {
                    removeElsClass(navButtons, 'active');
                    addClassEl('active', button);

                    isScrolling = true;

                    // Get the absolute position of the target group relative to the document
                    const targetOffset =
                        targetGroup.getBoundingClientRect().top + window.pageYOffset;

                    // Add padding and scroll
                    window.scrollTo({
                        top: targetOffset - groupOffsetTop,
                        behavior: 'smooth',
                    });

                    // Reset scrolling flag after animation completes
                    setTimeout(() => {
                        isScrolling = false;
                    }, 500);
                }
            });
        }

        // Track scroll position and update active button
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            // Skip scroll handling if we're programmatically scrolling
            if (isScrolling) return;

            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }

            scrollTimeout = setTimeout(() => {
                // Find the currently visible group
                let activeGroup = null;

                for (let group of groups) {
                    // Get the distance from the top of the viewport to the group
                    const rect = group.getBoundingClientRect();

                    if (rect.top <= groupOffsetTop && rect.bottom > groupOffsetTop) {
                        activeGroup = group;
                        break;
                    }
                }

                // Update active button
                if (activeGroup) {
                    const groupKey = activeGroup.getAttribute('data-group');

                    for (let button of navButtons) {
                        if (button.getAttribute('data-group') === groupKey) {
                            addClassEl('active', button);

                            // Scroll button into view if needed
                            const buttonLeft = button.offsetLeft;
                            const buttonWidth = button.offsetWidth;
                            const navWidth = nav.offsetWidth;
                            const navScroll = nav.querySelector('.nav-scroll');
                            const scrollLeft = navScroll.scrollLeft;

                            if (
                                buttonLeft < scrollLeft ||
                                buttonLeft + buttonWidth > scrollLeft + navWidth
                            ) {
                                navScroll.scrollTo({
                                    left: buttonLeft - navWidth / 2 + buttonWidth / 2,
                                    behavior: 'smooth',
                                });
                            }
                        } else {
                            removeClassEl('active', button);
                        }
                    }
                }
            }, 10);
        });
    },
    initCollapsible: function () {
        let sections = befriend.els.filters.getElementsByClassName('section');

        for (let i = 0; i < sections.length; i++) {
            let section = sections[i];
            let section_top = section.querySelector('.section-top');
            let section_container = section.querySelector('.section-container');

            if (!section_top || section_top._listener) {
                continue;
            }

            section_top._listener = true;

            // Set initial height if not already set
            if (!section_container.style.height) {
                let is_collapsed = elHasClass(section, 'collapsed');
                if (is_collapsed) {
                    section_container.style.height = '0';
                } else {
                    setElHeightDynamic(section_container);
                }
            }

            section_top.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (befriend.filters.networks.isDropdownShown()) {
                    return befriend.filters.networks.toggleDropdown(false);
                }

                if (befriend.filters.getActiveAutoCompleteEl()) {
                    return befriend.filters.hideActiveAutoCompleteIf(e.target);
                }

                if (befriend.filters.getActiveAutoCompleteSelectEl()) {
                    return befriend.filters.hideActiveAutoCompleteSelectIf(e.target);
                }

                let is_collapsed = elHasClass(section, 'collapsed');
                let section_key = this.getSectionKey(section);

                if (is_collapsed) {
                    removeClassEl('collapsed', section);
                    setElHeightDynamic(section_container);
                    delete this.data.collapsed[section_key];
                } else {
                    addClassEl('collapsed', section);
                    section_container.style.height = '0';
                    this.data.collapsed[section_key] = true;
                }

                // Save collapsed state to local storage
                befriend.user.setLocal('filters.collapsed', this.data.collapsed);

                //remove secondaries
                if (befriend.filters.secondaries.activeEl) {
                    removeClassEl('secondary-open', section);
                    //remove secondary classes
                    befriend.filters.transitionSecondary(
                        befriend.filters.secondaries.activeEl,
                        false,
                    );
                }

                let secondaryItemsOpen = section.getElementsByClassName('item-secondary-open');

                removeElsClass(secondaryItemsOpen, 'item-secondary-open');
            });
        }
    },
    updateSecondaryPosition: function (section_el, options_el) {
        let secondary_container = section_el.querySelector('.secondary-container');
        let secondaryContainerBox = secondary_container.getBoundingClientRect();
        let item_token = options_el.getAttribute('data-item-token');
        let secondary_item = secondary_container.querySelector(`.item[data-token="${item_token}"]`);
        let item_el = section_el.querySelector(`.item.mine[data-token="${item_token}"]`);

        let secondary_el = item_el.querySelector('.secondary');
        let secondaryBox = secondary_el.getBoundingClientRect();

        let offsetTop = secondaryBox.top - secondaryContainerBox.top;
        let offsetLeft = secondaryBox.left - secondaryContainerBox.left;

        secondary_item.style.width = `${secondary_el.offsetWidth}px`;
        secondary_item.style.top = `${offsetTop}px`;
        secondary_item.style.left = `${offsetLeft}px`;
    },
    updateSectionHeights: function (without_transition) {
        const sections_el = befriend.els.filters.querySelector('.sections');
        const sections = sections_el.getElementsByClassName('section');

        for (let section of sections) {
            const container = section.querySelector('.section-container');
            let itemsContainerEl = section.querySelector('.items-container');
            const is_collapsed = elHasClass(section, 'collapsed');

            if (without_transition) {
                container.style.transition = 'none';
                setTimeout(() => {
                    container.style.removeProperty('transition');
                }, befriend.variables.filters_section_transition_ms);
            }

            if (is_collapsed) {
                container.style.height = '0';
                continue;
            }

            // Clone the container to measure its height without affecting the DOM
            const containerClone = container.cloneNode(true);
            containerClone.style.position = 'absolute';
            containerClone.style.visibility = 'hidden';
            containerClone.style.height = 'auto';
            section.appendChild(containerClone);

            // Find any secondary options containers
            const secondaryOptions = containerClone.querySelectorAll('.secondary .options');

            // Temporarily set their height to 0 to exclude from measurement
            for (let option of secondaryOptions) {
                option.style.height = '0';
                option.style.position = 'absolute'; // Ensure they don't affect layout
            }

            // Get the height excluding expanded dropdowns
            const baseHeight = containerClone.offsetHeight;

            // Find current-selected elements that might have wrapped
            const currentSelectedEls = containerClone.querySelectorAll('.current-selected');
            let maxCurrentSelectedHeight = 0;

            for (let el of currentSelectedEls) {
                const height = el.offsetHeight;
                maxCurrentSelectedHeight = Math.max(maxCurrentSelectedHeight, height);
            }

            //set height on container
            container.style.height = `${baseHeight}px`;

            // Remove the clone
            section.removeChild(containerClone);
        }
    },
    positionSliders: function () {
        const filters_el = befriend.els.filters;
        if (!filters_el) return;

        // Position distance slider
        const distanceSection = filters_el.querySelector('.section.distance');
        if (distanceSection) {
            const container = distanceSection.querySelector('.sliders-control');
            const range = distanceSection.querySelector('.slider-range');
            const thumb = distanceSection.querySelector('.thumb');

            if (container && range && thumb) {
                const value = befriend.filters.distance.current;
                const percent =
                    (value - befriend.filters.distance.min) /
                    (befriend.filters.distance.max - befriend.filters.distance.min);
                const position = percent * container.offsetWidth;

                thumb.style.left = `${position}px`;
                range.style.width = `${position}px`;
                thumb.querySelector('.thumb-value').textContent = Math.round(value);
            }
        }

        // Position age sliders
        const ageSection = filters_el.querySelector('.section.ages');
        if (ageSection) {
            const container = ageSection.querySelector('.sliders-control');
            const range = ageSection.querySelector('.slider-range');
            const minThumb = ageSection.querySelector('.min-thumb');
            const maxThumb = ageSection.querySelector('.max-thumb');

            if (container && range && minThumb && maxThumb) {
                const minPercent =
                    (befriend.filters.age.current.min - befriend.filters.age.min) /
                    (befriend.filters.age.max - befriend.filters.age.min);
                const maxPercent =
                    (befriend.filters.age.current.max - befriend.filters.age.min) /
                    (befriend.filters.age.max - befriend.filters.age.min);

                const minPosition = minPercent * container.offsetWidth;
                const maxPosition = maxPercent * container.offsetWidth;

                minThumb.style.left = `${minPosition}px`;
                maxThumb.style.left = `${maxPosition}px`;
                range.style.left = `${Math.min(minPosition, maxPosition)}px`;
                range.style.width = `${Math.abs(maxPosition - minPosition)}px`;

                minThumb.querySelector('.thumb-value').textContent = Math.round(
                    befriend.filters.age.current.min,
                );
                maxThumb.querySelector('.thumb-value').innerHTML =
                    `${Math.round(befriend.filters.age.current.max)}${befriend.filters.age.current.max === befriend.filters.age.max ? '<span class="plus">+</span>' : ''}`;
            }
        }

        // Position review rating sliders
        const reviewsSection = filters_el.querySelector('.section.reviews');
        if (reviewsSection) {
            const reviewFilters = reviewsSection.querySelectorAll('.filter-option.review');

            for (let section of reviewFilters) {
                const type = Array.from(section.classList)
                    .find((cls) => cls.startsWith('review-'))
                    ?.replace('review-', '');

                if (!type || !befriend.filters.reviews.ratings[type]) continue;

                const container = section.querySelector('.sliders-control');
                const range = section.querySelector('.slider-range');
                const thumb = section.querySelector('.thumb');

                if (container && range && thumb) {
                    const rating = befriend.filters.reviews.ratings[type].current_rating;
                    const percent = rating / befriend.filters.reviews.max;
                    const position = percent * container.offsetWidth;

                    // Update slider position
                    thumb.style.left = `${position}px`;
                    range.style.width = `${position}px`;
                }
            }
        }
    },
    isSectionActive: function (section_key) {
        let filterData;

        if(section_key.startsWith('review')) {
            filterData = befriend.filters.data.filters['reviews'];
        } else if(section_key.startsWith('verification')) {
            filterData = befriend.filters.data.filters['verifications'];
        } else {
            filterData = befriend.filters.data.filters[section_key];
        }

        return filterData?.is_active;
    },
    getSectionKey: function (section_el) {
        return section_el.getAttribute('data-key');
    },
    getFilterToken: function (filterOption) {
        return filterOption.getAttribute('data-filter-token');
    },
    sendReceiveHtml: function (send_enabled, receive_enabled, position_corner) {
        return `<div class="send-receive ${position_corner ? 'position-corner' : ''}">
                    <div class="option send ${send_enabled ? 'enabled' : ''}">
                        <div class="icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 511.998 512.0029">
                                  <path d="M510.539,36.2574c7.1675-21.5056-13.29-41.9661-34.7956-34.7985L18.8108,153.7717c-25.6598,8.5523-24.8644,45.1188,1.1409,52.5476l222.2321,63.4978,63.4949,222.2321c7.4317,26.0082,43.9953,26.8036,52.5476,1.1409L510.539,36.2574Z" fill="black"/>
                                  <path d="M474.7157,56.7382l-142.5848,427.7544-63.373-221.7995L474.7157,56.7382ZM455.2626,37.285l-205.9548,205.9548L27.5111,179.8698,455.2626,37.285Z" fill="white"/>
                            </svg>
                        </div>
<!--                        <div class="text">Send</div>-->
                    </div>
                    <div class="option receive ${receive_enabled ? 'enabled' : ''}">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 426.6667 512">
                          <path d="M394.6667,448H32c-17.6427,0-32-14.3573-32-32,0-9.3653,4.0747-18.2187,11.2-24.32,33.6213-28.416,52.8-69.76,52.8-113.536v-64.8107c0-82.3467,66.9867-149.3333,149.3333-149.3333s149.3333,66.9867,149.3333,149.3333v64.8107c0,43.7973,19.1787,85.12,52.6293,113.3867,7.296,6.2507,11.3707,15.104,11.3707,24.4693,0,17.6427-14.336,32-32,32Z" fill="black"/>
                          
                          <path d="M213.3333,85.3333c-70.592,0-128,57.408-128,128v64.8107c0,50.0907-21.9307,97.344-60.1813,129.6853-2.4533,2.0907-3.8187,5.056-3.8187,8.1707,0,5.888,4.7787,10.6667,10.6667,10.6667h362.6667c5.888,0,10.6667-4.7787,10.6667-10.6667,0-3.1147-1.3653-6.08-3.7333-8.1066-38.3147-32.4053-60.2667-79.68-60.2667-129.7493v-64.8107c0-70.592-57.408-128-128-128h0Z" fill="white"/>
                          
                          <path d="M245.3333,89.1733c-5.888,0-10.6667-4.7787-10.6667-10.6667v-35.84c0-11.7547-9.5787-21.3333-21.3333-21.3333s-21.3333,9.5787-21.3333,21.3333v35.84c0,5.888-4.7787,10.6667-10.6667,10.6667s-10.6667-4.7573-10.6667-10.6667v-35.84c0-23.5307,19.136-42.6667,42.6667-42.6667s42.6667,19.136,42.6667,42.6667v35.84c0,5.9093-4.7787,10.6667-10.6667,10.6667Z" fill="black"/>
                          <path d="M213.3333,512c-41.1733,0-74.6667-33.4933-74.6667-74.6667,0-5.888,4.7787-10.6667,10.6667-10.6667s10.6667,4.7787,10.6667,10.6667c0,29.3973,23.936,53.3333,53.3333,53.3333s53.3333-23.936,53.3333-53.3333c0-5.888,4.7787-10.6667,10.6667-10.6667s10.6667,4.7787,10.6667,10.6667c0,41.1733-33.4933,74.6667-74.6667,74.6667Z" fill="black"/>
                        </svg>
<!--                        <div class="text">Receive</div>-->
                    </div>
                </div>`;
    },
    transitionSecondary: async function (secondary_el, show, on_internal) {
        let section_el = secondary_el.closest('.section');

        if (!section_el) {
            let section_key = secondary_el.getAttribute('data-section');
            section_el = befriend.els.filters.querySelector(`.section.${section_key}`);
        }

        let secondary_container = section_el.querySelector('.secondary-container');
        let item_el = secondary_el.closest('.item');
        let current_selected_el = secondary_el.querySelector('.current-selected');
        let token = item_el.getAttribute('data-token');

        // Find all items with open secondaries in the same section
        const openSecondaryItems = section_el.querySelectorAll('.item-secondary-open');

        // Get the options element for the clicked secondary
        let options_el = secondary_container.querySelector(`.options[data-item-token="${token}"]`);
        let options_item_el = options_el.closest('.item');

        let activeEl = befriend.filters.secondaries.activeEl;

        if (secondary_el._transitionTimeout) {
            clearTimeout(secondary_el._transitionTimeout);
        }

        if (show) {
            // First set the current height of any open options before transitioning
            for (let openItem of openSecondaryItems) {
                if (openItem !== item_el && openItem !== options_item_el) {
                    const openToken = openItem.getAttribute('data-token');
                    const openOptions = secondary_container.querySelector(
                        `.options[data-item-token="${openToken}"]`,
                    );
                    if (openOptions) {
                        // Set current height before transitioning to 0
                        openOptions.style.height = `${openOptions.scrollHeight}px`;
                        // Force reflow
                        void openOptions.offsetHeight;
                        // Now set height to 0 to trigger transition
                        openOptions.style.height = '0';

                        // Remove class from both main item and options item
                        removeClassEl('item-secondary-open', openItem);
                        const openOptionsItem = openOptions.closest('.item');
                        if (openOptionsItem) {
                            removeClassEl('item-secondary-open', openOptionsItem);
                        }
                    }
                }
            }

            // Handle active element from different section
            if (activeEl && activeEl !== secondary_el) {
                let active_section = activeEl.closest('.section');

                if (active_section !== section_el) {
                    let active_item = activeEl.closest('.item');
                    let active_options = active_section.querySelector(
                        `.options[data-item-token="${active_item.getAttribute('data-token')}"]`,
                    );

                    removeClassEl('item-secondary-open', active_item);
                    if (active_options) {
                        const activeOptionsItem = active_options.closest('.item');
                        if (activeOptionsItem) {
                            removeClassEl('item-secondary-open', activeOptionsItem);
                        }
                        active_options.style.height = '0';
                    }

                    setTimeout(() => {
                        removeClassEl('secondary-open', active_section);
                        if (active_options) {
                            active_options.style.removeProperty('height');
                        }
                    }, befriend.variables.secondary_transition_ms);
                }
            }

            befriend.filters.updateSecondaryPosition(section_el, options_el);

            // Set initial height of 0 before showing
            options_el.style.height = '0';
            // Force reflow
            void options_el.offsetHeight;

            addClassEl('secondary-open', section_el);
            // Add class to both main item and options item
            addClassEl('item-secondary-open', item_el);
            addClassEl('item-secondary-open', options_item_el);

            requestAnimationFrame(() => {
                options_item_el.style.height = `${options_el.scrollHeight + current_selected_el.scrollHeight + 2}px`;
                options_el.style.height = `${options_el.scrollHeight}px`;
            });

            befriend.filters.secondaries.activeEl = secondary_el;
        } else {
            const currentHeight = options_el.scrollHeight;
            options_el.style.height = `${currentHeight}px`;
            void options_el.offsetHeight;

            options_el.style.height = '0';

            addClassEl('closing-secondary', options_item_el);
            addClassEl('closing-secondary', item_el);

            secondary_el._transitionTimeout = setTimeout(function () {
                removeClassEl('closing-secondary', options_item_el);
                removeClassEl('closing-secondary', item_el);

                removeClassEl('item-secondary-open', item_el);
                removeClassEl('item-secondary-open', options_item_el);

                if (!befriend.els.filters.querySelector('.item-secondary-open')) {
                    removeClassEl('secondary-open', section_el);
                }

                options_el.style.removeProperty('height');

                if (!on_internal) {
                    if (secondary_el === activeEl) {
                        befriend.filters.secondaries.activeEl = null;
                    }
                }
            }, befriend.variables.secondary_transition_ms);
        }
    },
    hideActiveSecondaryIf: function (target = null) {
        let open_secondary_el = befriend.filters.secondaries.activeEl;

        if (open_secondary_el && !target?.closest('.secondary')) {
            befriend.filters.transitionSecondary(open_secondary_el, false);
        }
    },
    getActiveAutoCompleteEl: function () {
        return befriend.els.filters.querySelector('.autocomplete-container.autocomplete-shown');
    },
    getActiveAutoCompleteSelectEl: function () {
        return befriend.els.filters.querySelector('.search-container .select-container.open');
    },
    hideActiveAutoCompleteIf: function (target = null) {
        let open_el = this.getActiveAutoCompleteEl();

        if (open_el && !target?.closest('.autocomplete-complete-container')) {
            let section_key = open_el.closest('.section')?.getAttribute('data-key');
            befriend.filters[section_key].toggleAutoComplete(false);
        }
    },
    hideActiveAutoCompleteSelectIf: function (target = null) {
        let open_select_el = this.getActiveAutoCompleteSelectEl();

        if (open_select_el && !target?.closest('.select-container')) {
            let section_key = open_select_el.closest('.section')?.getAttribute('data-key');
            befriend.filters[section_key].toggleAutoCompleteSelect(open_select_el, false);
        }
    },
    createMultiSelectFilter(filterName) {
        function getFilterNameStr() {
            if (filterName.toLowerCase().startsWith('relationship')) {
                return 'relationship_status';
            }

            if (filterName.toLowerCase().startsWith('politics')) {
                return filterName;
            }

            return filterName.endsWith('s')
                ? filterName.substring(0, filterName.length - 1)
                : filterName;
        }

        let filterNameStr = getFilterNameStr();

        let section = befriend.filters.sections[filterName];

        return {
            init: function () {
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                addClassEl('multi-select', section_el);

                const filter_options = section_el.querySelector('.filter-options');

                const filter_data = befriend.filters.data.filters?.[filterName];
                const options = befriend.filters.data.options?.[filterName] || [];

                // Determine if "Any" should be selected
                let anySelected = false;

                if (!filter_data) {
                    anySelected = true;
                } else if (filter_data.items) {
                    const hasActiveSelections =
                        filter_data.items &&
                        Object.values(filter_data.items).some(
                            (item) => !item.deleted && !item.is_negative,
                        );

                    const everySelected = options.every((option) => {
                        return (
                            filter_data?.items &&
                            Object.values(filter_data.items).some(
                                (item) =>
                                    item[`${filterNameStr}_id`] === option.id &&
                                    !item.deleted &&
                                    !item.is_negative,
                            )
                        );
                    });

                    if (!hasActiveSelections || everySelected) {
                        anySelected = true;
                    }
                }

                const anyButtonHtml = `
                <div class="item button any ${anySelected ? 'selected' : ''}" data-token="any">
                    <div class="name">Any</div>
                </div>`;

                let optionsHtml = '';

                for (let option of options) {
                    let selected = '';

                    const matchingItem = filter_data?.items
                        ? Object.values(filter_data.items).find(
                              (item) => item[`${filterNameStr}_id`] === option.id,
                          )
                        : null;

                    if (
                        matchingItem &&
                        !matchingItem.is_negative &&
                        !matchingItem.deleted &&
                        !anySelected
                    ) {
                        selected = 'selected';
                    }

                    optionsHtml += `
                    <div class="item button ${option.token} ${selected}" ${matchingItem?.id ? `data-id="${matchingItem.id}"` : ''} data-token="${option.token}">
                        <div class="name">${option.name}</div>
                    </div>`;
                }

                let html = `
                <div class="filter-option" data-filter-token="${section.token}">
                    <div class="items-container">
                        <div class="buttons">
                            ${anyButtonHtml}
                            <div class="options-grid">
                                ${optionsHtml}
                            </div>
                        </div>
                    </div>
                </div>
            `;

                section_el
                    .querySelector('.section-container')
                    .insertAdjacentHTML(
                        'afterbegin',
                        befriend.filters.sendReceiveHtml(true, true, true),
                    );

                filter_options.innerHTML = html;
                this.initEvents(section_el);

                befriend.filters.importance.set(filterName);
            },
            initEvents: function (section_el) {
                const optionButtons = section_el.querySelectorAll(`.button`);
                const anyButton = section_el.querySelector(`.button[data-token="any"]`);
                const regularButtons = Array.from(optionButtons).filter(
                    (btn) => btn.getAttribute(`data-token`) !== 'any',
                );

                for (let button of optionButtons) {
                    if (button._listener) continue;
                    button._listener = true;

                    button.addEventListener('click', async function (e) {
                        e.preventDefault();
                        e.stopPropagation();

                        const token = this.getAttribute(`data-token`);
                        const isAny = token === 'any';
                        const wasSelected = elHasClass(this, 'selected');

                        try {
                            let response;

                            if (isAny) {
                                if (wasSelected) return false;

                                removeElsClass(regularButtons, 'selected');
                                addClassEl('selected', this);

                                response = await befriend.auth.put(section.config.endpoint, {
                                    [`${filterNameStr}_token`]: token,
                                    active: !wasSelected,
                                });
                            } else {
                                toggleElClass(this, 'selected');

                                const allSelected = regularButtons.every((btn) =>
                                    elHasClass(btn, 'selected'),
                                );

                                if (allSelected) {
                                    addClassEl('selected', anyButton);
                                    removeElsClass(regularButtons, 'selected');

                                    response = await befriend.auth.put(section.config.endpoint, {
                                        [`${filterNameStr}_token`]: token,
                                        active: !wasSelected,
                                    });

                                    await befriend.auth.put(section.config.endpoint, {
                                        [`${filterNameStr}_token`]: 'any',
                                        active: true,
                                    });
                                } else {
                                    removeClassEl('selected', anyButton);

                                    response = await befriend.auth.put(section.config.endpoint, {
                                        [`${filterNameStr}_token`]: token,
                                        active: !wasSelected,
                                    });
                                }
                            }

                            if(befriend.filters.isSectionActive(filterName)) {
                                befriend.filters.matches.updateCounts();
                            }

                            if(response?.data?.data) {
                                befriend.filters.data.filters[filterName] = response.data.data;
                            }

                            //add id to item
                            if (response?.data?.id) {
                                if (!button.getAttribute('data-id')) {
                                    button.setAttribute('data-id', response.data.id);
                                }
                            }
                        } catch (e) {
                            console.error(`Error updating ${filterName} filter:`, e);
                            toggleElClass(this, 'selected');
                        }
                    });
                }
            },
        };
    },
    createInterestsFilter: function (config) {
        const defaultConfig = {
            endpoint: null,
            key: '',
            hasCategories: true,
            hasSecondary: false,
            hasDynamicCategories: false,
            hasTabs: false,
            hasTableKey: false,
            hasSelect: false,
            tabs: [],
        };

        config = { ...defaultConfig, ...config };

        return {
            key: config.key,
            data: {
                tableKey: config.hasTabs ? config.tabs[0]?.key : config.key,
                tabs: config.tabs,
                categories: {},
                selected: {
                    filterList: {},
                },
            },
            init: function () {
                let section = befriend.filters.sections[this.key];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                addClassEl('is_interest', section_el);

                if (config.hasTabs) {
                    if (!this.data.tableKey) {
                        this.data.tableKey = this.data.tabs[0].key;
                    }
                    addClassEl('has-tabs', section_el);
                }

                const filter_options = section_el.querySelector('.filter-options');
                const sectionData = befriend.filters.data.options?.[this.key];

                let my_filters_category = '';
                let categories_html = '';

                if (sectionData?.options?.length) {
                    my_filters_category = `
                    <div class="category-btn mine active" data-category="mine">
                        My Filters
                    </div>`;

                    for (let category of sectionData.categories.options) {
                        let heading_html = category.heading
                            ? `<div class="heading">${category.heading}</div>`
                            : '';

                        let image_html = category.image
                            ? `<div class="image">${category.image}</div>`
                            : '';

                        categories_html += `
                        <div class="category-btn ${heading_html ? 'w-heading' : ''}" 
                             ${category.table_key ? `data-table-key="${category.table_key}"` : ''} 
                             data-category="${category.name?.toLowerCase()}"
                             ${category.token ? `data-category-token="${category.token}"` : ''}>
                            
                            ${image_html}
                            <div class="heading-name">
                                ${heading_html}
                                <div class="name">${category.name}</div>
                            </div>
                        </div>`;
                    }
                }

                let searchHtml = '';

                if (sectionData?.autoComplete) {
                    let selectList = config.hasSelect
                        ? befriend.filters[this.key].buildSelectFilterList(sectionData.autoComplete)
                        : '';

                    searchHtml = `
                    <div class="search-container ${selectList ? 'has-select' : ''}">
                        <div class="autocomplete-container">
                            <div class="input-container">
                                <input type="text" class="search-input" 
                                       placeholder="${sectionData.autoComplete.placeholders.main}">
                                <div class="search-icon-container">
                                    <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 611.9975 612.0095">
                                        <path d="M606.203,578.714l-158.011-155.486c41.378-44.956,66.802-104.411,66.802-169.835-.02-139.954-115.296-253.393-257.507-253.393S0,113.439,0,253.393s115.276,253.393,257.487,253.393c61.445,0,117.801-21.253,162.068-56.586l158.624,156.099c7.729,7.614,20.277,7.614,28.006,0,7.747-7.613,7.747-19.971.018-27.585ZM257.487,467.8c-120.326,0-217.869-95.993-217.869-214.407S137.161,38.986,257.487,38.986s217.869,95.993,217.869,214.407-97.542,214.407-217.869,214.407Z"/>
                                    </svg>
                                </div>
                            </div>
                            <div class="autocomplete-list"></div>
                        </div>
                        ${selectList}
                    </div>
                `;
                }

                const html = `
                <div class="filter-options-container">
                    <div class="filter-option" data-filter-token="${section.token}">
                        ${searchHtml}
                        ${
                            categories_html
                                ? `
                            <div class="categories-container">
                                <div class="category-mine">${my_filters_category}</div>
                                <div class="category-filters">${categories_html}</div>
                            </div>
                        `
                                : ''
                        }
                        <div class="items-container">
                            <div class="items ${befriend.me.getRowColsClass(sectionData, 'mine')}"></div>
                        </div>
                        ${config.hasSecondary ? '<div class="secondary-container"></div>' : ''}
                    </div>
                </div>
            `;

                section_el
                    .querySelector('.section-container')
                    .insertAdjacentHTML(
                        'afterbegin',
                        befriend.filters.sendReceiveHtml(true, true, true),
                    );

                filter_options.innerHTML = html;

                let items = this.getStoredItems();

                if (config.hasTabs) {
                    this.addTabs();
                }

                if (config.hasSelect) {
                    addClassEl('has-filter-list', section_el);
                }

                this.events.init();

                requestAnimationFrame(() => {
                    this.renderItems(section_el, items, true);
                    befriend.filters.updateSectionHeights();
                });
            },
            getStoredFilter: function () {
                return befriend.filters.data.filters?.[this.key];
            },
            getStoredItems: function () {
                let items = [];
                const storedFilters = this.getStoredFilter();

                if (storedFilters?.items) {
                    items = Object.values(storedFilters.items)
                        .filter(
                            (item) => !config.hasTableKey || item.table_key === this.data.tableKey,
                        )
                        .filter((item) => !item.deleted)
                        .filter(Boolean);
                }

                return items;
            },
            getItemByToken: function(token) {
                if (!befriend.filters.data.filters?.[this.key]?.items) {
                    return null;
                }

                for (let k in befriend.filters.data.filters[this.key].items) {
                    if (befriend.filters.data.filters[this.key].items[k].token === token) {
                        return befriend.filters.data.filters[this.key].items[k];
                    }
                }

                return null;
            },
            getItemById: function(id) {
                if (!befriend.filters.data.filters?.[this.key]?.items) {
                    return null;
                }

                for (let k in befriend.filters.data.filters[this.key].items) {
                    if (befriend.filters.data.filters[this.key].items[k].id === parseInt(id)) {
                        return befriend.filters.data.filters[this.key].items[k];
                    }
                }

                return null;
            },
            getKeyCol: function (key) {
                if (!config.hasTabs) return null;
                return this.data.tabs.find((tab) => tab.key === key)?.col;
            },
            getTableKey: function (token) {
                if (!config.hasTableKey) return null;
                const sectionData = befriend.filters.data.options?.[this.key];
                return (
                    sectionData?.options.find((item) => item.token === token)?.table_key ||
                    this.data.tableKey
                );
            },
            getFilterHashToken: function () {
                let sectionData = befriend.filters.data.options?.[this.key];
                let filterKey = sectionData?.autoComplete?.filter?.hashKey;

                if (filterKey) {
                    return (
                        befriend.filters[config.key]?.data?.selected?.filterList?.item?.[
                            filterKey
                        ] || null
                    );
                }

                return null;
            },
            getActiveCategory: function () {
                let section_el = befriend.els.filters.querySelector(`.section.${this.key}`);

                return section_el.querySelector(`.category-btn.active`);
            },
            getCategoryByName: function (name) {
                name = name?.trim().toLowerCase();

                const sectionData = befriend.filters.data.options?.[this.key];

                if (sectionData?.categories?.options) {
                    for (let category of sectionData.categories.options) {
                        if (category.name.toLowerCase() === name) {
                            return category;
                        }
                    }
                }
            },
            renderItems: function (section_el, items, is_mine, tableKey) {
                if (config.hasTableKey && !tableKey) {
                    tableKey = this.getTableKey();
                }

                let tab = config.hasTabs
                    ? this.data.tabs.find((tab) => tab.key === tableKey)
                    : null;

                const storedFilters = this.getStoredFilter();
                let section = befriend.filters.sections[this.key];
                const sectionData = befriend.filters.data.options?.[this.key];
                const items_container = section_el.querySelector('.items');
                let secondary_options = null;

                if (config.hasSecondary) {
                    if (config.hasTableKey) {
                        secondary_options = sectionData?.secondary?.[tableKey]?.options;
                    } else {
                        secondary_options = sectionData?.secondary?.[config.key]?.options;
                    }
                }

                let items_html = '';
                let secondaryItems = '';

                if (is_mine) {
                    const hasActiveNonDeletedItems =
                        storedFilters?.items &&
                        Object.values(storedFilters.items)
                            .filter((item) => !config.hasTableKey || item.table_key === tableKey)
                            .some((item) => !item.deleted && item.is_active);

                    items_html = `
                    <div class="item any ${!hasActiveNonDeletedItems ? 'active' : ''}" data-token="any">
                        <div class="name">Any ${tab?.singular || ''}</div>
                    </div>`;

                    // Prepare secondary items if needed
                    if (secondary_options && items?.length) {
                        for (let item of items) {
                            const storedItem = Object.values(storedFilters?.items || {}).find(
                                (stored) => stored.token === item.token,
                            );

                            const selectedSecondary = storedItem?.secondary || [];
                            let isAnyLevel = selectedSecondary.includes('any');

                            let secondary_options_html = '';
                            secondary_options_html += `<div class="option any-level ${isAnyLevel ? 'selected' : ''}" data-option="any">Any Level</div>`;

                            for (let option of secondary_options) {
                                let selected =
                                    !isAnyLevel && selectedSecondary.includes(option)
                                        ? 'selected'
                                        : '';
                                secondary_options_html += `<div class="option ${selected}" data-option="${option}">${option}</div>`;
                            }

                            secondaryItems += `
                            <div class="item ${item.token} ${!storedItem?.secondary?.length ? 'unselected' : ''}" data-token="${item.token}">
                                <div class="current-selected">
                                    ${
                                        storedItem?.secondary?.includes('any')
                                            ? 'Any Level'
                                            : storedItem?.secondary?.length
                                              ? `${storedItem.secondary.length} Selected`
                                              : sectionData.secondary?.[tableKey || config.key]
                                                    ?.unselectedStr
                                    }
                                </div>
                                <svg class="arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 82.1 43.2">
                                    <path d="M41.1,43.2L0,2.2,2.1,0l39,39L80,0l2.1,2.2-41,41Z"/>
                                </svg>
                                <div class="options" data-item-token="${item.token}">${secondary_options_html}</div>
                            </div>`;
                        }
                    }
                }

                let added_item_tokens = {};
                let tableCol = config.hasTableKey ? this.getKeyCol(this.data.tableKey) : null;

                if (storedFilters?.items) {
                    for (let k in storedFilters.items) {
                        let item = storedFilters.items[k];

                        if (!item.deleted && item.is_active) {
                            added_item_tokens[item.token] = item;
                        }
                    }
                }

                // Generate items HTML
                if (items?.length) {
                    for (let item of items) {
                        if (is_mine) {
                            const storedItem = Object.values(storedFilters?.items || {}).find(
                                (stored) => stored.token === item.token,
                            );
                            const isActive =
                                storedItem && !storedItem.deleted && storedItem.is_active;

                            items_html += `
                            <div class="item mine ${isActive ? 'active' : ''}" 
                                 data-id="${storedItem?.id}" 
                                 data-token="${item.token}"
                                 ${config.hasTableKey ? `data-table-key="${tableKey}"` : ''}>
                                <div class="content">
                                    <div class="name">${item.name}</div>
                                    
                                    ${
                                        config.hasSecondary
                                            ? `
                                        <div class="secondary ${!storedItem?.secondary?.length ? 'unselected' : ''}" 
                                             data-section="${section.token}"
                                             data-item-token="${item.token}">
                                            <div class="current-selected">
                                                ${
                                                    storedItem?.secondary?.includes('any')
                                                        ? 'Any Level'
                                                        : storedItem?.secondary?.length
                                                          ? `${storedItem.secondary.length} Selected`
                                                          : sectionData.secondary?.[
                                                                tableKey || config.key
                                                            ]?.unselectedStr
                                                }
                                            </div>
                                            <svg class="arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 82.1 43.2">
                                                <path d="M41.1,43.2L0,2.2,2.1,0l39,39L80,0l2.1,2.2-41,41Z"/>
                                            </svg>
                                        </div>
                                    `
                                            : ''
                                    }
                                    
                                    <div class="remove">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 121.805 14.619">
                                            <path d="M7.308,14.619h107.188c4.037,0,7.309-3.272,7.309-7.31s-3.271-7.309-7.309-7.309H7.308C3.272.001,0,3.273,0,7.31s3.272,7.309,7.308,7.309Z"/>
                                        </svg>
                                    </div>
                                </div>
                            </div>`;
                        } else if (!added_item_tokens[item.token]) {
                            let label = '';
                            let meta = '';

                            if (item.label) {
                                label = `<div class="label">${item.label}</div>`;
                            }

                            if (item.meta) {
                                meta = `<div class="meta">${item.meta}</div>`;
                            }

                            items_html += `
                            <div class="item" data-token="${item.token}"
                                 ${config.hasTableKey ? `data-table-key="${tableKey}"` : ''}>
                                <div class="name-label">
                                    <div class="name">${item.name}</div>
                                    ${label}
                                </div>
                                                
                                ${meta}
                            </div>`;
                        }
                    }
                }

                items_container.innerHTML = items_html;

                let _this = this;

                // Add secondary items to container if needed
                const secondary_container = section_el.querySelector('.secondary-container');

                if (secondaryItems) {
                    secondary_container.innerHTML = secondaryItems;
                }

                if (is_mine) {
                    if (config.hasTabs) {
                        addClassEl('show-tabs', section_el);

                        _this.updateTabCount(section_el);
                    }
                } else {
                    removeClassEl('show-tabs', section_el);
                }

                _this.events.update();

                befriend.filters.importance.set(config.key);
            },
            addTabs: function () {
                if (!config.hasTabs || !this.data?.tabs?.length) {
                    return;
                }

                let section = befriend.filters.sections[this.key];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                let html = this.data.tabs
                    .map(
                        (tab, index) => `
                    <div class="tab ${index === 0 ? 'active' : ''}" data-key="${tab.key}">
                        <div class="name-count">
                            <div class="name">${tab.name}</div>
                        </div>
                    </div>
                `,
                    )
                    .join('');

                let tabs_html = `<div class="tabs-container">${html}</div>`;

                let categories_container = section_el.querySelector('.categories-container');
                categories_container.insertAdjacentHTML('afterend', tabs_html);

                this.events.tabs();
            },
            updateTabCount: function (section_el) {
                if (!config.hasTabs) return;

                const storedFilters = this.getStoredFilter();
                const tabs = section_el.querySelectorAll('.tab');

                for (let tab of tabs) {
                    const key = tab.getAttribute('data-key');
                    const count = Object.values(storedFilters?.items || {}).filter(
                        (item) => item.table_key === key && !item.deleted && item.is_active,
                    ).length;

                    const countEl = tab.querySelector('.count');

                    if (count > 0) {
                        if (countEl) {
                            countEl.textContent = count;
                        } else {
                            tab.insertAdjacentHTML(
                                'beforeend',
                                `<div class="count">${count}</div>`,
                            );
                        }
                    } else if (countEl) {
                        countEl.remove();
                    }
                }
            },
            addItem: async function (itemData = {}, section_el) {
                try {
                    let { token, hashToken, tableKey } = itemData;

                    befriend.toggleSpinner(true);

                    const sectionData = befriend.filters.data.options?.[this.key];
                    const category_mine = section_el.querySelector(`.category-btn.mine`);
                    const secondary_options = config.hasSecondary
                        ? sectionData?.secondary?.[tableKey || config.key]?.options
                        : null;

                    if (config.hasTableKey) {
                        if (!tableKey) {
                            tableKey = this.getTableKey(token);
                        }
                        this.data.tableKey = tableKey;
                    }

                    let hash_token = hashToken || befriend.filters[config.key].getFilterHashToken();

                    let response = await befriend.auth.put(config.endpoint, {
                        ...(config.hasSelect
                            ? { hash_token: hash_token }
                            : {}),
                        ...(config.hasTableKey ? { table_key: tableKey } : {}),
                        token,
                        active: true,
                    });

                    if(befriend.filters.isSectionActive(config.key)) {
                        befriend.filters.matches.updateCounts();
                    }

                    let id = response?.data?.id;

                    // Get current mine items
                    const storedFilters = this.getStoredFilter();

                    let option = sectionData?.options?.find((opt) => opt.token === token);
                    let tableCol = config.hasTableKey ? this.getKeyCol(tableKey) : null;

                    befriend.filters.data.filters[this.key].items[id] = {
                        id,
                        token,
                        hash_token: hash_token,
                        ...(config.hasTableKey
                            ? {
                                  table_key: tableKey,
                                  [tableCol]: option.id,
                              }
                            : {}),
                        name: option.name,
                        is_active: true,
                    };

                    // Add secondary options for new item if needed
                    if (config.hasSecondary && secondary_options) {
                        const secondary_container =
                            section_el.querySelector('.secondary-container');
                        let secondary_options_html = `
                        <div class="option any-level" data-option="any">Any Level</div>
                        ${secondary_options
                            .map((opt) => `<div class="option" data-option="${opt}">${opt}</div>`)
                            .join('')}
                    `;

                        const secondaryItemHtml = `
                        <div class="item ${token}" data-token="${token}">
                            <div class="options" data-item-token="${token}">
                                ${secondary_options_html}
                            </div>
                        </div>`;

                        secondary_container.insertAdjacentHTML('beforeend', secondaryItemHtml);
                    }

                    // Switch to mine category and show updated items
                    if (category_mine) {
                        fireClick(category_mine);
                    } else {
                        //update UI (items)
                        const items = this.getStoredItems();

                        befriend.filters[config.key].renderItems(section_el, items, true);
                    }

                    // Select correct tab if needed
                    if (config.hasTabs) {
                        let tabs_els = section_el.getElementsByClassName('tab');
                        for (let tab of tabs_els) {
                            if (
                                tab.getAttribute('data-key') === tableKey &&
                                !elHasClass(tab, 'active')
                            ) {
                                fireClick(tab);
                            }
                        }
                    }

                    requestAnimationFrame(() => {
                        befriend.filters.updateSectionHeights();
                    });

                    befriend.toggleSpinner(false);
                    return true;
                } catch (e) {
                    console.error(`Error adding ${this.key}:`, e);
                    befriend.toggleSpinner(false);
                    return false;
                }
            },
            isItemAdded: function (item) {
                const storedFilters = this.getStoredFilter();
                if (!storedFilters?.items) return false;

                return Object.values(storedFilters.items).some(
                    (stored) => !stored.deleted && stored.token === item.token,
                );
            },
            toggleAutoComplete: function (show) {
                let section = befriend.filters.sections[this.key];
                const section_el = befriend.els.filters.querySelector(`.section.${section.token}`);

                const autocomplete_container = section_el.querySelector('.autocomplete-container');
                const autocomplete_list = section_el.querySelector('.autocomplete-list');

                if (!autocomplete_list) return;

                if (show) {
                    addClassEl('autocomplete-shown', section_el);
                    addClassEl('autocomplete-shown', autocomplete_container);
                    autocomplete_list.scrollTop = 0;

                    const search_input = section_el.querySelector('.search-input');
                    if (search_input) search_input.focus();
                } else {
                    removeClassEl('autocomplete-shown', section_el);
                    removeClassEl('autocomplete-shown', autocomplete_container);
                }
            },
            toggleAutoCompleteSelect: function (el, show) {
                if (!el) {
                    el = befriend.els.filters.querySelector(
                        '.search-container .select-container.open',
                    );
                }

                let section_el = el.closest('.section');

                let section_key = section_el.getAttribute('data-key');

                if (show) {
                    let input = el.querySelector('.select-input');
                    input.value = '';
                    input.focus();
                    befriend.filters[section_key].updateAutoCompleteSelectList(section_key);

                    //show el
                    addClassEl('open', el);
                    addClassEl('autocomplete-select-open', section_el);

                    section_el.style.zIndex = 100;
                } else {
                    removeClassEl('open', el);
                    removeClassEl('autocomplete-select-open', section_el);

                    section_el.style.removeProperty('z-index');
                }
            },
            buildSelectFilterList: function (data) {
                let items = data?.filter?.list;

                if (!items || !items.length) {
                    return '';
                }

                let list_html = ``;

                for (let item of items) {
                    let emoji = '';

                    if (item.emoji) {
                        emoji = `<div class="emoji">${item.emoji}</div>`;
                    }

                    list_html += `<div class="item" data-id="${item.id}">
                            ${emoji}
                            <div class="name">${item.name}</div>
                        </div>`;
                }

                //selected
                let selected_str = '';

                let filterListObj = befriend.filters[config.key].data.selected.filterList;

                if (filterListObj) {
                    if (
                        befriend.user.local.data.filters &&
                        befriend.user.local.data.filters.filterList &&
                        befriend.user.local.data.filters.filterList[config.key]
                    ) {
                        filterListObj.item =
                            befriend.user.local.data.filters.filterList[config.key];

                        selected_str = filterListObj?.item?.name;
                    } else if (befriend.me.data.me?.country?.name) {
                        selected_str = befriend.me.data.me.country.name;

                        filterListObj.item = befriend.me.data.me.country;
                    }
                }

                return `<div class="select-container">
                        <div class="selected-container">
                          <span class="selected-name">${selected_str}</span>
                          <div class="select-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448.569 256.5604"><g id="Layer_1-2"><path d="M441.9533,40.728l-193.176,205.2496c-13.28,14.1104-35.704,14.1104-48.984,0L6.6157,40.728C-7.8979,25.3056,3.0349,0,24.2125,0h400.1424c21.1792,0,32.112,25.3056,17.5984,40.728h0Z"/></g></svg></div>
                        </div>
                        
                        <div class="select-dropdown">
                          <div class="select-search-container">
                            <input class="select-input" type="text" placeholder="${data.placeholders.list}">
                            <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 611.9975 612.0095"><g id="_x34_"><path d="M606.203,578.714l-158.011-155.486c41.378-44.956,66.802-104.411,66.802-169.835-.02-139.954-115.296-253.393-257.507-253.393S0,113.439,0,253.393s115.276,253.393,257.487,253.393c61.445,0,117.801-21.253,162.068-56.586l158.624,156.099c7.729,7.614,20.277,7.614,28.006,0,7.747-7.613,7.747-19.971.018-27.585ZM257.487,467.8c-120.326,0-217.869-95.993-217.869-214.407S137.161,38.986,257.487,38.986s217.869,95.993,217.869,214.407-97.542,214.407-217.869,214.407Z"/></g></svg>
                          </div>
                          <div class="select-list">${list_html}</div>
                          <div class="no-results">${data.filter.noResults}</div>
                        </div>
                      </div>`;
            },
            updateAutoCompleteSelectList: function () {
                function filterSort(items, search) {
                    if (!search) {
                        // Show selected item at top of list if one exists
                        let selectedItem = this.data.selected.filterList.item;
                        if (selectedItem) {
                            let updated_items = [selectedItem];
                            for (let item of items) {
                                if (item.id !== selectedItem.id) {
                                    updated_items.push(item);
                                }
                            }
                            return updated_items;
                        }
                        return items;
                    }

                    search = search.toLowerCase();
                    const startsWithMatch = [];
                    const wordStartsWithMatch = [];
                    const includesMatch = [];

                    for (let item of items) {
                        let nameLower = item.name.toLowerCase();
                        let words = nameLower.split(' ');

                        if (nameLower.startsWith(search)) {
                            startsWithMatch.push(item);
                        } else if (words.slice(1).some((word) => word.startsWith(search))) {
                            wordStartsWithMatch.push(item);
                        } else if (nameLower.includes(search)) {
                            includesMatch.push(item);
                        }
                    }

                    return [...startsWithMatch, ...wordStartsWithMatch, ...includesMatch];
                }

                const section_el = befriend.els.filters.querySelector(`.section.${this.key}`);
                const select_input = section_el.querySelector('.select-input');
                const search_value = select_input.value;
                const select_list = section_el.querySelector('.select-list');
                const sectionData = befriend.filters.data.options?.[config.key];

                if (!sectionData?.autoComplete?.filter?.list) {
                    return;
                }

                const list_items = sectionData.autoComplete.filter.list;
                const filtered_items = filterSort.call(this, list_items, search_value);
                const select_container = section_el.querySelector('.select-container');

                if (!filtered_items.length) {
                    addClassEl('no-items', select_container);
                    select_list.innerHTML = '';
                    return;
                }

                removeClassEl('no-items', select_container);
                let list_html = filtered_items
                    .map(
                        (item) => `
                <div class="item" data-id="${item.id}">
                    ${item.emoji ? `<div class="emoji">${item.emoji}</div>` : ''}
                    <div class="name">${item.name}</div>
                </div>
            `,
                    )
                    .join('');

                select_list.innerHTML = list_html;

                // Reinitialize event handlers for new items
                this.events.selectList();
            },
            selectAutoCompleteFilterItem: async function (item_id) {
                const sectionData = befriend.filters.data.options?.[config.key];

                if (!sectionData?.autoComplete?.filter?.list) {
                    throw new Error('Filter list not found');
                }

                item_id = parseInt(item_id);

                const selected_item = sectionData.autoComplete.filter.list.find(
                    (item) => item.id === item_id,
                );

                if (!selected_item) {
                    throw new Error('Selected item not found');
                }

                // Update data
                this.data.selected.filterList = {
                    item: selected_item,
                    needsReset: true,
                };

                // Save to local storage if needed
                befriend.user.setLocal(`filters.filterList.${this.key}`, selected_item);

                // Update UI
                const section_el = befriend.els.filters.querySelector(`.section.${this.key}`);
                const select_container = section_el.querySelector('.select-container');
                const selected_name_el = select_container.querySelector('.selected-name');
                selected_name_el.innerHTML = selected_item.name;

                this.toggleAutoCompleteSelect(select_container, false);
            },
            events: {
                init: function () {
                    this.search();

                    if (config.hasCategories) {
                        this.categories();
                    }

                    if (config.hasSelect) {
                        this.selectList();
                    }
                },
                update: function () {
                    this.items();
                    this.remove();

                    if (config.hasSecondary) {
                        this.secondary();
                    }
                },
                tabs: function () {
                    if (!config.hasTabs) return;

                    let section = befriend.filters.sections[config.key];
                    const section_el = befriend.els.filters.querySelector(
                        `.section.${section.token}`,
                    );
                    let tabs_els = section_el
                        .querySelector('.tabs-container')
                        .getElementsByClassName('tab');

                    for (let tab of tabs_els) {
                        if (tab._listener) continue;
                        tab._listener = true;

                        tab.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            if (elHasClass(tab, 'active')) return;

                            let key = tab.getAttribute('data-key');
                            befriend.filters[config.key].data.tableKey = key;

                            removeElsClass(tabs_els, 'active');
                            addClassEl('active', tab);

                            befriend.filters[config.key].renderItems(
                                section_el,
                                befriend.filters[config.key].getStoredItems(),
                                true,
                            );

                            requestAnimationFrame(() => {
                                befriend.filters.updateSectionHeights();
                            });
                        });
                    }
                },
                search: function () {
                    let section = befriend.filters.sections[config.key];
                    const sectionData = befriend.filters.data.options?.[config.key];
                    const section_el = befriend.els.filters.querySelector(
                        `.section.${section.token}`,
                    );

                    const search_input = section_el.querySelector('.search-input');
                    const input_container = section_el.querySelector('.input-container');
                    const autocomplete_list = section_el.querySelector('.autocomplete-list');

                    if (!search_input || search_input._listener) return;
                    search_input._listener = true;

                    let debounceTimer;
                    search_input.addEventListener('input', () => {
                        clearTimeout(debounceTimer);
                        let timeout = search_input.value ? 200 : 0;

                        debounceTimer = setTimeout(async () => {
                            const value = search_input.value.trim();
                            if (value.length < sectionData.autoComplete.minChars) {
                                befriend.filters[config.key].toggleAutoComplete(false);
                                return;
                            }

                            try {
                                let filterId =
                                    befriend.filters[config.key].data.selected.filterList?.item
                                        ?.id || null;

                                let hash_token = befriend.filters[config.key].getFilterHashToken();

                                const response = await befriend.auth.get(
                                    sectionData.autoComplete.endpoint,
                                    {
                                        search: value,
                                        ...(config.hasSelect
                                            ? {
                                                  filterId,
                                                  location: befriend.location.device || null,
                                              }
                                            : {}),
                                        ...(config.hasDynamicCategories
                                            ? {
                                                  category: befriend.filters[
                                                      config.key
                                                  ].getCategoryByName(
                                                      befriend.filters[config.key]
                                                          .getActiveCategory()
                                                          ?.getAttribute('data-category'),
                                                  ),
                                              }
                                            : {}),
                                    },
                                );

                                let items = response?.data?.items || [];

                                if (!sectionData.options) {
                                    sectionData.options = [];
                                }

                                let items_html = '';

                                if (
                                    sectionData.autoComplete?.groups &&
                                    Object.keys(sectionData.autoComplete.groups).length
                                ) {
                                    for (let k in sectionData.autoComplete.groups) {
                                        let group = sectionData.autoComplete.groups[k];

                                        let group_html = '';

                                        let groupItems = items[k] || [];

                                        for (let item of groupItems) {
                                            if (
                                                !sectionData.options.find(
                                                    (existing) => existing.token === item.token,
                                                )
                                            ) {
                                                item._is_internal = true;

                                                if(hash_token) {
                                                    item.hash_token = hash_token;
                                                }

                                                sectionData.options.push(item);
                                            }
                                        }

                                        if (groupItems && groupItems.length) {
                                            for (let item of groupItems) {
                                                if (
                                                    befriend.filters[config.key].isItemAdded(item)
                                                ) {
                                                    continue;
                                                }

                                                let location_html = '';

                                                if (item.city) {
                                                    if (item.state) {
                                                        location_html = `<div class="location">${item.city}, ${item.state}</div>`;
                                                    } else {
                                                        location_html = `<div class="location">${item.city}</div>`;
                                                    }
                                                }

                                                group_html += `<div class="item" data-token="${item.token}" data-table-key="${item.table_key || ''}">
                                                   ${location_html}
                                                   <div class="name">${item.name}</div>
                                              </div>`;
                                            }

                                            if (group_html) {
                                                items_html += `<div class="group">
                                            <div class="group-name">${group.name}</div>
                                            <div class="group-list">${group_html}</div>
                                        </div>`;
                                            }
                                        }
                                    }
                                } else {
                                    //standard items results
                                    // Merge results with options
                                    for (let item of items) {
                                        if (
                                            !sectionData.options.find(
                                                (existing) => existing.token === item.token,
                                            )
                                        ) {
                                            item._is_internal = true;
                                            sectionData.options.push(item);
                                        }
                                    }

                                    // Filter out existing items
                                    const existingTokens = new Set();
                                    const storedFilters =
                                        befriend.filters[config.key].getStoredFilter();

                                    if (storedFilters?.items) {
                                        for (let item of Object.values(storedFilters.items)) {
                                            if (!item.deleted) {
                                                existingTokens.add(item.token);
                                            }
                                        }
                                    }

                                    const filteredItems = response.data.items.filter(
                                        (item) => !existingTokens.has(item.token),
                                    );

                                    if (filteredItems.length) {
                                        for (let item of filteredItems) {
                                            let meta_html = '';

                                            if (item.meta) {
                                                meta_html = `<div class="meta">${item.meta}</div>`;
                                            }

                                            let label_html = '';

                                            if (item.label) {
                                                label_html = `
                                                <div class="label">
                                                    <div class="text">${item.label}</div>
                                                </div>`;
                                            }

                                            items_html += `
                                                <div class="item ${label_html ? 'has-label' : ''}" 
                                                     data-id="${item.id || ''}" 
                                                     data-token="${item.token}"
                                                     data-table-key="${item.table_key || ''}">
                                                    <div class="name-meta">
                                                        <div class="name">${item.name}</div>
                                                        ${meta_html}
                                                    </div>
                                                    ${label_html}
                                                </div>`;
                                        }
                                    }
                                }

                                if (!items_html) {
                                    items_html = '<div class="no-results">No results found</div>';
                                }

                                autocomplete_list.innerHTML = items_html;

                                befriend.filters[config.key].toggleAutoComplete(true);
                            } catch (e) {
                                console.error(`Error searching ${config.key}:`, e);
                            }
                        }, timeout);
                    });

                    // Handle autocomplete item selection
                    autocomplete_list.addEventListener('click', async (e) => {
                        const item = e.target.closest('.item');
                        if (!item) return;

                        const id = item.getAttribute('data-id');
                        const token = item.getAttribute('data-token');
                        const tableKey = item.getAttribute('data-table-key');

                        let itemData = befriend.filters[config.key].getItemByToken(token);

                        let hashToken = itemData?.hash_token || null;

                        if (
                            await befriend.filters[config.key].addItem(
                                { id, token, hashToken, tableKey },
                                section_el,
                            )
                        ) {
                            befriend.filters[config.key].toggleAutoComplete(false);
                            search_input.value = '';
                        }
                    });

                    // Focus/blur handling
                    search_input.addEventListener('focus', () => {
                        addClassEl('input-focus', input_container);
                        if (search_input.value.length >= sectionData.autoComplete.minChars) {
                            befriend.filters[config.key].toggleAutoComplete(true);
                        }
                    });

                    search_input.addEventListener('blur', () => {
                        removeClassEl('input-focus', input_container);
                        setTimeout(() => {
                            // befriend.filters[config.key].toggleAutoComplete(false);
                        }, 100);
                    });
                },
                categories: function () {
                    let section = befriend.filters.sections[config.key];
                    const sectionData = befriend.filters.data.options?.[config.key];
                    const section_el = befriend.els.filters.querySelector(
                        `.section.${section.token}`,
                    );
                    const category_btns = section_el.querySelectorAll('.category-btn');

                    for (let btn of category_btns) {
                        if (btn._listener) continue;
                        btn._listener = true;

                        btn.addEventListener('click', async () => {
                            let t = timeNow();

                            removeElsClass(category_btns, 'active');
                            addClassEl('active', btn);

                            let category = btn.getAttribute('data-category')?.toLowerCase().trim();
                            let category_token = btn.getAttribute('data-category-token')?.trim();
                            let categoryTableKey = btn.getAttribute('data-table-key');

                            try {
                                let items;
                                const added_item_tokens = new Set();
                                const storedFilters =
                                    befriend.filters[config.key].getStoredFilter();

                                // Build set of existing tokens
                                if (storedFilters?.items) {
                                    for (let item of Object.values(storedFilters.items)) {
                                        if (!item.deleted) {
                                            added_item_tokens.add(item.token);
                                        }
                                    }
                                }

                                if (category === 'mine') {
                                    // Get stored items for current table key if using tabs
                                    let table_key = config.hasTableKey
                                        ? befriend.filters[config.key].getTableKey()
                                        : null;

                                    items = Object.values(storedFilters?.items || {})
                                        .filter(
                                            (item) =>
                                                !config.hasTableKey || item.table_key === table_key,
                                        )
                                        .filter((item) => !item.deleted)
                                        .filter(Boolean);
                                } else {
                                    // Try three ways to get category items:

                                    // 1. Check category cache first
                                    if (config.hasDynamicCategories) {
                                        items =
                                            befriend.filters[config.key]?.data?.categories[
                                                category_token
                                            ];
                                    }

                                    // 2. Filter from section data if not found in cache
                                    if (!items?.length) {
                                        items = sectionData?.options
                                            .filter((item) =>
                                                category_token
                                                    ? item.category_token === category_token
                                                    : item.category?.toLowerCase() === category,
                                            )
                                            .filter((item) => !added_item_tokens.has(item.token))
                                            .filter((item) => !item._is_internal);
                                    }

                                    // 3. Fetch from dynamic endpoint if needed
                                    if (config.hasDynamicCategories && !items?.length) {
                                        befriend.toggleSpinner(true);

                                        let data = await befriend.me.getCategoryOptions(
                                            sectionData.categories.endpoint,
                                            category_token,
                                        );

                                        items = data.items;

                                        // Add items to options for lookup
                                        for (let item of data.items) {
                                            if (
                                                !sectionData.options.find(
                                                    (existing) => existing.token === item.token,
                                                )
                                            ) {
                                                item._is_internal = true;
                                                sectionData.options.push(item);
                                            }
                                        }

                                        befriend.toggleSpinner(false);

                                        // Cache the results
                                        befriend.filters[config.key].data.categories[
                                            category_token
                                        ] = items;
                                    }
                                }

                                befriend.filters[config.key].renderItems(
                                    section_el,
                                    items || [],
                                    category === 'mine',
                                    categoryTableKey,
                                );

                                requestAnimationFrame(() => {
                                    befriend.filters.updateSectionHeights();
                                });
                            } catch (e) {
                                console.error(`Error loading ${config.key}:`, e);
                            }
                        });
                    }
                },
                items: function () {
                    let section = befriend.filters.sections[config.key];
                    const section_el = befriend.els.filters.querySelector(
                        `.section.${section.token}`,
                    );
                    let items_els = section_el.getElementsByClassName('item');

                    for (let item of items_els) {
                        if (item._listener) continue;
                        item._listener = true;

                        item.addEventListener('click', async (e) => {
                            if (e.target.closest('.secondary-container')) {
                                return false;
                            }

                            e.preventDefault();
                            e.stopPropagation();

                            const token = item.getAttribute('data-token');
                            const tableKey = item.getAttribute('data-table-key');
                            const wasSelected = elHasClass(item, 'active');

                            let open_secondary = item
                                .closest('.section')
                                .querySelector(`.item-secondary-open`);

                            if (open_secondary) {
                                return befriend.filters.hideActiveSecondaryIf(e.target);
                            }

                            if (befriend.filters.getActiveAutoCompleteEl()) {
                                return befriend.filters.hideActiveAutoCompleteIf(e.target);
                            }

                            if (befriend.filters.getActiveAutoCompleteSelectEl()) {
                                return befriend.filters.hideActiveAutoCompleteSelectIf(e.target);
                            }

                            let itemData = befriend.filters[config.key].getItemByToken(token);

                            // Handle "Any" selection
                            if (elHasClass(item, 'any')) {
                                if (wasSelected) return;

                                try {
                                    befriend.toggleSpinner(true);

                                    const effectiveTableKey = config.hasTableKey
                                        ? befriend.filters[config.key].getTableKey()
                                        : null;

                                    await befriend.auth.put(config.endpoint, {
                                        ...(config.hasTableKey
                                            ? { table_key: effectiveTableKey }
                                            : {}),
                                        token: 'any',
                                        active: true,
                                    });

                                    if(befriend.filters.isSectionActive(config.key)) {
                                        befriend.filters.matches.updateCounts();
                                    }

                                    const anyButton = item;
                                    const otherItems =
                                        section_el.querySelectorAll('.item:not(.any)');

                                    addClassEl('active', anyButton);

                                    // Deactivate other items for current table
                                    for (let otherItem of otherItems) {
                                        const storedItem = befriend.filters[config.key].getItemById(otherItem.getAttribute('data-id'));

                                        if (
                                            storedItem &&
                                            (!config.hasTableKey ||
                                                storedItem.table_key === effectiveTableKey)
                                        ) {
                                            removeClassEl('active', otherItem);
                                            storedItem.is_active = false;
                                        }
                                    }
                                } catch (e) {
                                    console.error(`Error setting any ${config.key}:`, e);
                                }

                                befriend.toggleSpinner(false);

                                if (config.hasTabs) {
                                    befriend.filters[config.key].updateTabCount(section_el);
                                }
                                return;
                            }

                            let hash_token = itemData?.hash_token || befriend.filters[config.key].getFilterHashToken();

                            // Handle mine item toggle
                            if (elHasClass(item, 'mine')) {
                                toggleElClass(item, 'active');

                                try {
                                    befriend.toggleSpinner(true);

                                    const effectiveTableKey = config.hasTableKey
                                        ? befriend.filters[config.key].getTableKey(token)
                                        : null;

                                    await befriend.auth.put(config.endpoint, {
                                        ...(config.hasSelect ? { hash_token: hash_token } : {}),
                                        ...(config.hasTableKey
                                            ? { table_key: effectiveTableKey }
                                            : {}),
                                        token,
                                        active: !wasSelected,
                                    });

                                    if(befriend.filters.isSectionActive(config.key)) {
                                        befriend.filters.matches.updateCounts();
                                    }

                                    // Update any button state based on active items
                                    const activeItems = Array.from(
                                        section_el.querySelectorAll('.item.mine.active'),
                                    ).filter((item) => {
                                        const storedItem = befriend.filters[config.key].getItemById(item.getAttribute('data-id'));

                                        return (
                                            storedItem &&
                                            (!config.hasTableKey ||
                                                storedItem.table_key === effectiveTableKey)
                                        );
                                    });

                                    const anyButton = section_el.querySelector('.item.any');

                                    if (anyButton) {
                                        if (activeItems.length === 0) {
                                            addClassEl('active', anyButton);
                                        } else {
                                            removeClassEl('active', anyButton);
                                        }
                                    }

                                    // Update stored data
                                    let itemData = befriend.filters[config.key].getItemByToken(token);

                                    if(itemData) {
                                        itemData.is_active = !wasSelected;
                                    }
                                } catch (e) {
                                    console.error(`Error toggling ${config.key}:`, e);
                                }

                                befriend.toggleSpinner(false);

                                if (config.hasTabs) {
                                    befriend.filters[config.key].updateTabCount(section_el);
                                }

                                return;
                            }

                            // Handle category item selection
                            try {
                                item.remove();

                                await befriend.filters[config.key].addItem(
                                    { token, tableKey },
                                    section_el,
                                );
                            } catch (e) {
                                console.error(`Error adding ${config.key}:`, e);
                            }
                        });
                    }
                },
                remove: function () {
                    let section = befriend.filters.sections[config.key];
                    const section_el = befriend.els.filters.querySelector(
                        `.section.${section.token}`,
                    );
                    let remove_els = section_el.querySelectorAll('.item .remove');

                    for (let remove_el of remove_els) {
                        if (remove_el._listener) continue;
                        remove_el._listener = true;

                        remove_el.addEventListener('click', async (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            befriend.filters.hideActiveSecondaryIf();
                            befriend.filters.hideActiveAutoCompleteIf();
                            befriend.filters.hideActiveAutoCompleteSelectIf();

                            const item = remove_el.closest('.item');
                            const token = item.getAttribute('data-token');

                            try {
                                let itemData = befriend.filters[config.key].getItemByToken(token);

                                befriend.toggleSpinner(true);

                                let hash_token = itemData.hash_token || befriend.filters[config.key].getFilterHashToken();

                                const tableKey = config.hasTableKey
                                    ? befriend.filters[config.key].getTableKey(token)
                                    : null;

                                await befriend.auth.put(config.endpoint, {
                                    ...(config.hasSelect
                                        ? {
                                              hash_token:
                                                  hash_token,
                                          }
                                        : {}),
                                    ...(config.hasTableKey ? { table_key: tableKey } : {}),
                                    token,
                                    is_delete: true,
                                });

                                if(befriend.filters.isSectionActive(config.key)) {
                                    befriend.filters.matches.updateCounts();
                                }

                                // Remove item and update UI
                                item.remove();

                                const activeItems =
                                    section_el.querySelectorAll('.item.mine.active');
                                if (activeItems.length === 0) {
                                    const anyButton = section_el.querySelector('.item.any');
                                    if (anyButton) addClassEl('active', anyButton);
                                }

                                // Update stored data

                                if(itemData) {
                                    itemData.deleted = true;
                                }
                            } catch (e) {
                                console.error(`Error removing ${config.key}:`, e);
                            }

                            befriend.toggleSpinner(false);

                            if (config.hasTabs) {
                                befriend.filters[config.key].updateTabCount(section_el);
                            }

                            requestAnimationFrame(() => {
                                befriend.filters.updateSectionHeights();
                            });
                        });
                    }
                },
                secondary: function () {
                    if (!config.hasSecondary) {
                        return;
                    }

                    const section = befriend.filters.sections[config.key];
                    const section_el = befriend.els.filters.querySelector(
                        `.section.${section.token}`,
                    );
                    const sectionData = befriend.filters.data.options?.[config.key];

                    // Handle clicks on secondary elements in the items container
                    const secondary_els = section_el.getElementsByClassName('secondary');
                    for (let secondary_el of secondary_els) {
                        if (secondary_el._listener) continue;
                        secondary_el._listener = true;

                        secondary_el.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            befriend.filters.hideActiveAutoCompleteIf();
                            befriend.filters.hideActiveAutoCompleteSelectIf();

                            befriend.filters.transitionSecondary(
                                secondary_el,
                                !befriend.filters.secondaries.activeEl ||
                                    befriend.filters.secondaries.activeEl !== secondary_el,
                            );
                        });
                    }

                    // Handle clicks in the secondary container
                    const secondary_container = section_el.querySelector('.secondary-container');
                    if (!secondary_container._listener) {
                        secondary_container._listener = true;

                        secondary_container.addEventListener('click', async (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            // Handle clicks on current-selected in secondary container
                            const clicked_current_selected = e.target.closest('.current-selected');
                            if (clicked_current_selected) {
                                const secondary_item = clicked_current_selected.closest('.item');
                                if (!secondary_item) return;

                                const itemToken = secondary_item.getAttribute('data-token');
                                const original_item = section_el.querySelector(
                                    `.item.mine[data-token="${itemToken}"]`,
                                );
                                if (!original_item) return;

                                const secondary_el = original_item.querySelector('.secondary');
                                if (!secondary_el) return;

                                befriend.filters.transitionSecondary(
                                    secondary_el,
                                    !befriend.filters.secondaries.activeEl ||
                                        befriend.filters.secondaries.activeEl !== secondary_el,
                                );
                                return;
                            }

                            const secondary_option = e.target.closest('.option');
                            if (!secondary_option) return;

                            const options_el = secondary_option.closest('.options');
                            if (!options_el) return;

                            const itemToken = options_el.getAttribute('data-item-token');
                            const item_el = section_el.querySelector(
                                `.item.mine[data-token="${itemToken}"]`,
                            );
                            const option_value = secondary_option.getAttribute('data-option');
                            const isAnyLevel = option_value === 'any';
                            const anyOption = options_el.querySelector('.option.any-level');
                            const otherOptions =
                                options_el.querySelectorAll('.option:not(.any-level)');
                            const wasSelected = elHasClass(secondary_option, 'selected');
                            const tableKey = item_el.getAttribute('data-table-key');

                            let itemData = befriend.filters[config.key].getItemByToken(itemToken);

                            try {
                                befriend.toggleSpinner(true);

                                // Initialize array if needed
                                if (
                                    !itemData.secondary ||
                                    !Array.isArray(itemData.secondary)
                                ) {
                                    itemData.secondary = [];
                                }

                                if (isAnyLevel) {
                                    // If selecting "Any Level"
                                    if (!wasSelected) {
                                        itemData.secondary = ['any'];
                                        addClassEl('selected', anyOption);
                                        removeElsClass(otherOptions, 'selected');
                                    } else {
                                        return;
                                    }
                                } else {
                                    // If selecting a specific level
                                    if (!wasSelected) {
                                        // Remove 'any' if it was selected
                                        removeArrItem(itemData.secondary, 'any');
                                        removeClassEl('selected', anyOption);

                                        // Add the new selection
                                        itemData.secondary.push(option_value);
                                        addClassEl('selected', secondary_option);
                                    } else {
                                        // Remove the selection
                                        removeArrItem(itemData.secondary, option_value);
                                        removeClassEl('selected', secondary_option);

                                        //set any if no options selected
                                        if (!itemData.secondary.length) {
                                            itemData.secondary.push('any');
                                            addClassEl('selected', anyOption);
                                        }
                                    }
                                }

                                itemData.secondary = befriend.filters.sortSecondary(
                                    sectionData?.secondary?.[tableKey || config.key]?.options,
                                    itemData.secondary,
                                );

                                await befriend.auth.put(config.endpoint, {
                                    token: itemToken,
                                    secondary: itemData.secondary,
                                    table_key: tableKey || config.key,
                                });

                                if(befriend.filters.isSectionActive(config.key)) {
                                    befriend.filters.matches.updateCounts();
                                }

                                // Update text content for both current-selected elements
                                let textContent;
                                if (itemData.secondary.includes('any')) {
                                    textContent = 'Any Level';
                                } else if (itemData.secondary.length) {
                                    textContent = `${itemData.secondary.length} Selected`;
                                } else {
                                    textContent = sectionData.secondary?.[tableKey]?.unselectedStr;
                                }

                                // Update original item's secondary element
                                const original_secondary = item_el?.querySelector('.secondary');
                                if (original_secondary) {
                                    original_secondary.querySelector(
                                        '.current-selected',
                                    ).textContent = textContent;
                                }

                                // Update secondary container's current-selected
                                const secondary_item = secondary_container.querySelector(
                                    `.item[data-token="${itemToken}"]`,
                                );
                                const secondary_current_selected =
                                    secondary_item?.querySelector('.current-selected');
                                if (secondary_current_selected) {
                                    secondary_current_selected.textContent = textContent;
                                }

                                if (itemData.secondary.length === 0) {
                                    addClassEl('unselected', original_secondary);
                                    addClassEl('unselected', secondary_item);
                                } else {
                                    removeClassEl('unselected', original_secondary);
                                    removeClassEl('unselected', secondary_item);
                                }

                                requestAnimationFrame(() => {
                                    befriend.filters.updateSecondaryPosition(
                                        section_el,
                                        options_el,
                                    );
                                    befriend.filters.updateSectionHeights();
                                });
                            } catch (e) {
                                console.error('Error updating secondary:', e);
                            } finally {
                                befriend.toggleSpinner(false);
                            }
                        });
                    }
                },
                selectList: function () {
                    // Selected container click handler
                    const selectedContainers = befriend.els.filters.querySelectorAll(
                        '.search-container .selected-container',
                    );

                    for (let container of selectedContainers) {
                        if (container._listener) continue;
                        container._listener = true;

                        container.addEventListener('click', function () {
                            const parentEl = container.closest('.select-container');
                            const section = container.closest('.section');
                            const sectionKey = section.getAttribute('data-key');

                            befriend.filters[config.key].toggleAutoCompleteSelect(
                                parentEl,
                                !elHasClass(parentEl, 'open'),
                            );

                            if (befriend.filters[config.key].data.selected.filterList?.needsReset) {
                                const list = parentEl.querySelector('.select-list');
                                requestAnimationFrame(() => (list.scrollTop = 0));
                                befriend.filters[config.key].data.selected.filterList.needsReset =
                                    false;
                            }
                        });
                    }

                    // Select list search handler
                    const selectInputs =
                        befriend.els.filters.querySelectorAll('.select-container input');

                    for (let input of selectInputs) {
                        if (input._listener) continue;
                        input._listener = true;

                        input.addEventListener('input', function () {
                            befriend.filters[config.key].updateAutoCompleteSelectList();
                        });
                    }

                    // Select list item click handler
                    const selectItems =
                        befriend.els.filters.querySelectorAll('.select-container .item');

                    for (let item of selectItems) {
                        if (item._listener) continue;
                        item._listener = true;

                        item.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();

                            const id = item.getAttribute('data-id');

                            befriend.filters[config.key].selectAutoCompleteFilterItem(id);
                        });
                    }
                },
            },
        };
    },
    setFilterState: function () {
        if(befriend.filters.data.filters) {
            for(let k in befriend.filters.sections) {
                let d = befriend.filters.sections[k];

                if(!befriend.filters.data.filters[d.token]) {
                    befriend.filters.data.filters[d.token] = {
                        is_active: true,
                        is_send: true,
                        is_receive: true,
                        items: {}
                    }
                }
            }
        }
    }
};
